"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[62547],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(96540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}},84960:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"skills/llm_streaming_response_handler/references/error-recovery","title":"Stream Error Recovery Strategies","description":"Production patterns for handling errors during LLM streaming and providing graceful recovery.","source":"@site/docs/skills/llm_streaming_response_handler/references/error-recovery.md","sourceDirName":"skills/llm_streaming_response_handler/references","slug":"/skills/llm_streaming_response_handler/references/error-recovery","permalink":"/docs/skills/llm_streaming_response_handler/references/error-recovery","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Stream Error Recovery Strategies","sidebar_label":"Stream Error Recovery Strat...","sidebar_position":1}}');var s=r(74848),o=r(28453);const a={title:"Stream Error Recovery Strategies",sidebar_label:"Stream Error Recovery Strat...",sidebar_position:1},i="Stream Error Recovery Strategies",l={},c=[{value:"Error Categories",id:"error-categories",level:2},{value:"1. Network Errors",id:"1-network-errors",level:3},{value:"2. API Errors",id:"2-api-errors",level:3},{value:"3. Stream-Specific Errors",id:"3-stream-specific-errors",level:3},{value:"Pattern 1: Retry with Exponential Backoff",id:"pattern-1-retry-with-exponential-backoff",level:2},{value:"Pattern 2: Rate Limit Handling",id:"pattern-2-rate-limit-handling",level:2},{value:"Pattern 3: Graceful Degradation",id:"pattern-3-graceful-degradation",level:2},{value:"Pattern 4: Resume from Last Token",id:"pattern-4-resume-from-last-token",level:2},{value:"Pattern 5: Client-Side Timeout",id:"pattern-5-client-side-timeout",level:2},{value:"Pattern 6: User-Friendly Error Messages",id:"pattern-6-user-friendly-error-messages",level:2},{value:"Pattern 7: Fallback to Non-Streaming",id:"pattern-7-fallback-to-non-streaming",level:2},{value:"Pattern 8: Error Logging &amp; Monitoring",id:"pattern-8-error-logging--monitoring",level:2},{value:"Pattern 9: Circuit Breaker",id:"pattern-9-circuit-breaker",level:2},{value:"Production Checklist",id:"production-checklist",level:2},{value:"Testing Error Scenarios",id:"testing-error-scenarios",level:2},{value:"Simulate Network Failure",id:"simulate-network-failure",level:3},{value:"Simulate Rate Limit",id:"simulate-rate-limit",level:3},{value:"Simulate Partial Stream",id:"simulate-partial-stream",level:3},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"stream-error-recovery-strategies",children:"Stream Error Recovery Strategies"})}),"\n",(0,s.jsx)(n.p,{children:"Production patterns for handling errors during LLM streaming and providing graceful recovery."}),"\n",(0,s.jsx)(n.h2,{id:"error-categories",children:"Error Categories"}),"\n",(0,s.jsx)(n.h3,{id:"1-network-errors",children:"1. Network Errors"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Connection timeouts"}),"\n",(0,s.jsx)(n.li,{children:"DNS failures"}),"\n",(0,s.jsx)(n.li,{children:"Lost connectivity mid-stream"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-api-errors",children:"2. API Errors"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rate limits (429)"}),"\n",(0,s.jsx)(n.li,{children:"Authentication (401, 403)"}),"\n",(0,s.jsx)(n.li,{children:"Server errors (500, 503)"}),"\n",(0,s.jsx)(n.li,{children:"Invalid requests (400)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-stream-specific-errors",children:"3. Stream-Specific Errors"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Malformed SSE data"}),"\n",(0,s.jsx)(n.li,{children:"Unexpected stream termination"}),"\n",(0,s.jsx)(n.li,{children:"Backpressure overload"}),"\n",(0,s.jsx)(n.li,{children:"Client-side cancellation"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-1-retry-with-exponential-backoff",children:"Pattern 1: Retry with Exponential Backoff"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function streamWithRetry(\n  url: string,\n  options: RequestInit,\n  maxRetries = 3\n): Promise<Response> {\n  let attempt = 0;\n\n  while (attempt < maxRetries) {\n    try {\n      const response = await fetch(url, options);\n\n      // Don't retry on client errors (4xx except rate limit)\n      if (response.status >= 400 && response.status < 500 && response.status !== 429) {\n        throw new Error(`Client error: ${response.status}`);\n      }\n\n      // Don't retry on success\n      if (response.ok) {\n        return response;\n      }\n\n      // Retry on server errors and rate limits\n      throw new Error(`Server error: ${response.status}`);\n\n    } catch (error) {\n      attempt++;\n\n      if (attempt >= maxRetries) {\n        throw error;\n      }\n\n      // Exponential backoff: 1s, 2s, 4s\n      const delay = Math.pow(2, attempt) * 1000;\n      console.log(`Retry ${attempt}/${maxRetries} after ${delay}ms`);\n\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw new Error('Max retries exceeded');\n}\n\n// Usage\nconst response = await streamWithRetry('/api/chat', {\n  method: 'POST',\n  body: JSON.stringify({ prompt })\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-2-rate-limit-handling",children:"Pattern 2: Rate Limit Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function handleRateLimit(response: Response): Promise<void> {\n  if (response.status === 429) {\n    const retryAfter = response.headers.get('Retry-After');\n\n    if (retryAfter) {\n      const delay = parseInt(retryAfter) * 1000;\n      console.log(`Rate limited. Retrying after ${delay}ms`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    } else {\n      // No Retry-After header, use default backoff\n      await new Promise(resolve => setTimeout(resolve, 60000)); // 1 minute\n    }\n  }\n}\n\n// Usage\nconst response = await fetch('/api/chat', { ... });\n\nif (response.status === 429) {\n  await handleRateLimit(response);\n  // Retry request\n  return fetch('/api/chat', { ... });\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-3-graceful-degradation",children:"Pattern 3: Graceful Degradation"}),"\n",(0,s.jsx)(n.p,{children:"Show partial response if stream fails mid-way."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function useStreamingWithFallback() {\n  const [content, setContent] = useState('');\n  const [error, setError] = useState<Error | null>(null);\n  const [isComplete, setIsComplete] = useState(false);\n\n  const stream = async (prompt: string) => {\n    setError(null);\n    setIsComplete(false);\n\n    try {\n      const response = await fetch('/api/chat', {\n        method: 'POST',\n        body: JSON.stringify({ prompt })\n      });\n\n      const reader = response.body!.getReader();\n      const decoder = new TextDecoder();\n\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          setIsComplete(true);\n          break;\n        }\n\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = JSON.parse(line.slice(6));\n            if (data.content) {\n              setContent(prev => prev + data.content);\n            }\n          }\n        }\n      }\n    } catch (err) {\n      setError(err as Error);\n      // Keep partial content visible\n      console.error('Stream failed, showing partial response:', content);\n    }\n  };\n\n  return { content, error, isComplete, stream };\n}\n\n// UI shows partial content + error\n{content && (\n  <div>\n    {content}\n    {error && !isComplete && (\n      <div className=\"error-banner\">\n        \u26a0\ufe0f Connection lost. Showing partial response.\n        <button onClick={() => stream(lastPrompt)}>Resume</button>\n      </div>\n    )}\n  </div>\n)}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-4-resume-from-last-token",children:"Pattern 4: Resume from Last Token"}),"\n",(0,s.jsx)(n.p,{children:"For very long streams, save checkpoints."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface StreamCheckpoint {\n  prompt: string;\n  content: string;\n  lastTokenIndex: number;\n}\n\nasync function streamWithCheckpoints(prompt: string) {\n  let checkpoint: StreamCheckpoint | null = loadCheckpoint(prompt);\n\n  if (checkpoint) {\n    console.log('Resuming from checkpoint:', checkpoint.lastTokenIndex);\n  }\n\n  const response = await fetch('/api/chat', {\n    method: 'POST',\n    body: JSON.stringify({\n      prompt,\n      resumeFrom: checkpoint?.lastTokenIndex || 0\n    })\n  });\n\n  const reader = response.body!.getReader();\n  const decoder = new TextDecoder();\n\n  let tokenIndex = checkpoint?.lastTokenIndex || 0;\n  let content = checkpoint?.content || '';\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      // Process chunk...\n\n      content += newToken;\n      tokenIndex++;\n\n      // Save checkpoint every 100 tokens\n      if (tokenIndex % 100 === 0) {\n        saveCheckpoint({ prompt, content, lastTokenIndex: tokenIndex });\n      }\n    }\n  } catch (error) {\n    // Checkpoint saved, can resume later\n    console.error('Stream interrupted at token', tokenIndex);\n    throw error;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-5-client-side-timeout",children:"Pattern 5: Client-Side Timeout"}),"\n",(0,s.jsx)(n.p,{children:"Prevent infinite hanging."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function streamWithTimeout(\n  url: string,\n  options: RequestInit,\n  timeoutMs = 30000\n): Promise<void> {\n  const controller = new AbortController();\n\n  // Set timeout\n  const timeoutId = setTimeout(() => {\n    controller.abort();\n  }, timeoutMs);\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal\n    });\n\n    // Reset timeout on each chunk\n    const reader = response.body!.getReader();\n    const decoder = new TextDecoder();\n\n    while (true) {\n      // Clear and reset timeout\n      clearTimeout(timeoutId);\n      const chunkTimeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n      const { done, value } = await reader.read();\n\n      clearTimeout(chunkTimeoutId);\n\n      if (done) break;\n\n      // Process chunk...\n    }\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('Request timed out');\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-6-user-friendly-error-messages",children:"Pattern 6: User-Friendly Error Messages"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function getErrorMessage(error: unknown): string {\n  if (error instanceof Error) {\n    // Network errors\n    if (error.message.includes('Failed to fetch')) {\n      return 'Network error. Please check your connection.';\n    }\n\n    // Timeout\n    if (error.name === 'AbortError') {\n      return 'Request timed out. Please try again.';\n    }\n\n    // Generic\n    return error.message;\n  }\n\n  // HTTP errors\n  if (typeof error === 'object' && error !== null && 'status' in error) {\n    const status = (error as any).status;\n\n    switch (status) {\n      case 400:\n        return 'Invalid request. Please try rephrasing.';\n      case 401:\n        return 'Please log in to continue.';\n      case 403:\n        return 'You don\\'t have permission to do this.';\n      case 429:\n        return 'Too many requests. Please wait a moment.';\n      case 500:\n        return 'Server error. Please try again later.';\n      case 503:\n        return 'Service temporarily unavailable.';\n      default:\n        return `Error ${status}: Something went wrong.`;\n    }\n  }\n\n  return 'An unexpected error occurred.';\n}\n\n// UI\n{error && (\n  <div className=\"error-message\">\n    <span>{getErrorMessage(error)}</span>\n    <button onClick={retry}>Try Again</button>\n  </div>\n)}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-7-fallback-to-non-streaming",children:"Pattern 7: Fallback to Non-Streaming"}),"\n",(0,s.jsx)(n.p,{children:"If streaming fails repeatedly, fall back to standard request."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function adaptiveStream(prompt: string): Promise<string> {\n  try {\n    // Try streaming first\n    return await streamResponse(prompt);\n  } catch (error) {\n    console.log('Streaming failed, falling back to standard request');\n\n    // Fallback to non-streaming\n    const response = await fetch('/api/chat', {\n      method: 'POST',\n      body: JSON.stringify({ prompt, stream: false })\n    });\n\n    const data = await response.json();\n    return data.content;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-8-error-logging--monitoring",children:"Pattern 8: Error Logging & Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function streamWithMonitoring(prompt: string) {\n  const startTime = Date.now();\n\n  try {\n    await streamResponse(prompt);\n\n    // Log success\n    await logMetric({\n      event: 'stream_success',\n      duration: Date.now() - startTime,\n      prompt\n    });\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n\n    // Log error with context\n    await logError({\n      event: 'stream_error',\n      error: error.message,\n      duration,\n      prompt,\n      userAgent: navigator.userAgent,\n      timestamp: new Date().toISOString()\n    });\n\n    // Send to error tracking (Sentry, etc.)\n    if (window.Sentry) {\n      window.Sentry.captureException(error, {\n        tags: {\n          component: 'chat-stream',\n          duration\n        }\n      });\n    }\n\n    throw error;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-9-circuit-breaker",children:"Pattern 9: Circuit Breaker"}),"\n",(0,s.jsx)(n.p,{children:"Stop trying after repeated failures."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class CircuitBreaker {\n  private failures = 0;\n  private lastFailureTime = 0;\n  private state: 'closed' | 'open' | 'half-open' = 'closed';\n\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    // Circuit open: reject immediately\n    if (this.state === 'open') {\n      const timeSinceFailure = Date.now() - this.lastFailureTime;\n\n      if (timeSinceFailure < 60000) { // 1 minute cooldown\n        throw new Error('Circuit breaker open. Try again later.');\n      }\n\n      // Try half-open\n      this.state = 'half-open';\n    }\n\n    try {\n      const result = await fn();\n\n      // Success: reset\n      this.failures = 0;\n      this.state = 'closed';\n\n      return result;\n    } catch (error) {\n      this.failures++;\n      this.lastFailureTime = Date.now();\n\n      // Trip circuit after 3 failures\n      if (this.failures >= 3) {\n        this.state = 'open';\n      }\n\n      throw error;\n    }\n  }\n}\n\nconst breaker = new CircuitBreaker();\n\n// Usage\ntry {\n  await breaker.execute(() => streamResponse(prompt));\n} catch (error) {\n  // Handle error or show cached response\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"production-checklist",children:"Production Checklist"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u25a1 Retry logic with exponential backoff\n\u25a1 Rate limit handling (Retry-After header)\n\u25a1 Graceful degradation (show partial)\n\u25a1 User-friendly error messages\n\u25a1 Timeout enforcement\n\u25a1 Error logging to monitoring service\n\u25a1 Circuit breaker for repeated failures\n\u25a1 Fallback to non-streaming\n\u25a1 Checkpoint saving for long streams\n\u25a1 Network status detection\n\u25a1 Offline mode (show cached)\n\u25a1 Cancel button always works\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"testing-error-scenarios",children:"Testing Error Scenarios"}),"\n",(0,s.jsx)(n.h3,{id:"simulate-network-failure",children:"Simulate Network Failure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Test: Network interruption\nif (process.env.NODE_ENV === 'development') {\n  // Randomly fail 10% of requests\n  if (Math.random() < 0.1) {\n    throw new Error('Simulated network failure');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"simulate-rate-limit",children:"Simulate Rate Limit"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Test: Rate limit response\nreturn new Response('Too many requests', {\n  status: 429,\n  headers: {\n    'Retry-After': '5' // 5 seconds\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"simulate-partial-stream",children:"Simulate Partial Stream"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Test: Stream fails halfway\ncontroller.enqueue(encoder.encode('data: First half\\n\\n'));\nawait new Promise(resolve => setTimeout(resolve, 1000));\ncontroller.error(new Error('Connection lost'));\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling",children:"MDN: Error Handling"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://martinfowler.com/bliki/CircuitBreaker.html",children:"Circuit Breaker Pattern"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/",children:"Retry Best Practices"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);