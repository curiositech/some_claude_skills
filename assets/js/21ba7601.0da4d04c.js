"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[51709],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},l=i.createContext(r);function s(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(l.Provider,{value:n},e.children)}},75639:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"skills/color_theory_palette_harmony_expert/references/diversity-algorithms","title":"Diversity Algorithms: Preventing Color Monotony","description":"Problem","source":"@site/docs/skills/color_theory_palette_harmony_expert/references/diversity-algorithms.md","sourceDirName":"skills/color_theory_palette_harmony_expert/references","slug":"/skills/color_theory_palette_harmony_expert/references/diversity-algorithms","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/diversity-algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Diversity Algorithms: Preventing Color Monotony","sidebar_label":"Diversity Algorithms: Preve...","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Color Arrangement Patterns","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/arrangement-patterns"},"next":{"title":"Implementation Guide","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/implementation-guide"}}');var r=t(74848),l=t(28453);const s={title:"Diversity Algorithms: Preventing Color Monotony",sidebar_label:"Diversity Algorithms: Preve...",sidebar_position:2},o="Diversity Algorithms: Preventing Color Monotony",a={},d=[{value:"Problem",id:"problem",level:2},{value:"Method 1: Maximal Marginal Relevance (MMR)",id:"method-1-maximal-marginal-relevance-mmr",level:2},{value:"Formula",id:"formula",level:3},{value:"Greedy Algorithm",id:"greedy-algorithm",level:3},{value:"Tuning \u03bb",id:"tuning-\u03bb",level:3},{value:"Method 2: Determinantal Point Processes (DPPs)",id:"method-2-determinantal-point-processes-dpps",level:2},{value:"Kernel Matrix",id:"kernel-matrix",level:3},{value:"Key Property",id:"key-property",level:3},{value:"Sampling Algorithm",id:"sampling-algorithm",level:3},{value:"Advantages over MMR",id:"advantages-over-mmr",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Method 3: Submodular Maximization",id:"method-3-submodular-maximization",level:2},{value:"Submodular Function",id:"submodular-function",level:3},{value:"Example",id:"example",level:3},{value:"Comparison Summary",id:"comparison-summary",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Issue: Collage feels monotonous despite diversity penalty",id:"issue-collage-feels-monotonous-despite-diversity-penalty",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"diversity-algorithms-preventing-color-monotony",children:"Diversity Algorithms: Preventing Color Monotony"})}),"\n",(0,r.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"Without diversity constraints, optimization may select all similar colors (e.g., all blue skies)."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal:"})," Encourage variety in selected photo palettes while maintaining harmony."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"method-1-maximal-marginal-relevance-mmr",children:"Method 1: Maximal Marginal Relevance (MMR)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Concept:"})," Select photos that are both relevant (harmonious) and diverse (different from already selected)."]}),"\n",(0,r.jsx)(n.h3,{id:"formula",children:"Formula"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Score(photo_i) = \u03bb \xb7 Harmony(photo_i, global_palette)\n                 - (1 - \u03bb) \xb7 max_j\u2208Selected Similarity(photo_i, photo_j)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u03bb \u2208 [0, 1]: Diversity parameter (0.7 = 70% harmony, 30% diversity)"}),"\n",(0,r.jsx)(n.li,{children:"Harmony: How well photo_i fits global palette (negative EMD)"}),"\n",(0,r.jsx)(n.li,{children:"Similarity: Max similarity to any already-selected photo"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"greedy-algorithm",children:"Greedy Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def select_photos_with_mmr(candidate_photos, target_palette, k, lambda_param=0.7):\n    """\n    Select k photos using Maximal Marginal Relevance.\n\n    Balances harmony with target palette and diversity among selected photos.\n\n    Args:\n        candidate_photos: [(photo_id, palette_LAB), ...]\n        target_palette: Global target palette\n        k: Number of photos to select\n        lambda_param: 0.7 = prefer harmony, 0.3 = prefer diversity\n\n    Returns:\n        List of k selected photo_ids\n    """\n    selected = []\n    remaining = list(candidate_photos)\n\n    # Select first photo: highest harmony\n    best_photo = max(remaining,\n                     key=lambda x: -sinkhorn_emd(x[1], target_palette))\n    selected.append(best_photo)\n    remaining.remove(best_photo)\n\n    # Select remaining k-1 photos\n    for _ in range(k - 1):\n        best_score = -float(\'inf\')\n        best_photo = None\n\n        for photo_id, palette in remaining:\n            # Harmony term (negative EMD = high harmony)\n            harmony = -sinkhorn_emd(palette, target_palette)\n\n            # Diversity term (max similarity to any selected photo)\n            max_similarity = 0\n            for selected_id, selected_palette in selected:\n                # Similarity = negative EMD (closer = more similar)\n                similarity = -sinkhorn_emd(palette, selected_palette)\n                max_similarity = max(max_similarity, similarity)\n\n            # MMR score\n            mmr_score = lambda_param * harmony - (1 - lambda_param) * max_similarity\n\n            if mmr_score > best_score:\n                best_score = mmr_score\n                best_photo = (photo_id, palette)\n\n        if best_photo:\n            selected.append(best_photo)\n            remaining.remove(best_photo)\n\n    return [photo_id for photo_id, _ in selected]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"tuning-\u03bb",children:"Tuning \u03bb"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u03bb = 1.0: Pure harmony, no diversity (may select all blues)"}),"\n",(0,r.jsx)(n.li,{children:"\u03bb = 0.7: Balanced (recommended for collages)"}),"\n",(0,r.jsx)(n.li,{children:"\u03bb = 0.5: Equal harmony and diversity"}),"\n",(0,r.jsx)(n.li,{children:"\u03bb = 0.3: Heavy diversity (may sacrifice harmony)"}),"\n",(0,r.jsx)(n.li,{children:"\u03bb = 0.0: Pure diversity (maximally different palettes)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"method-2-determinantal-point-processes-dpps",children:"Method 2: Determinantal Point Processes (DPPs)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Concept:"})," Probabilistic model that encodes both quality and diversity via a kernel matrix."]}),"\n",(0,r.jsx)(n.h3,{id:"kernel-matrix",children:"Kernel Matrix"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"K[i, j] = Quality(i) \xb7 Quality(j) \xb7 Similarity(i, j)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Quality(i): How good photo i is (aesthetic score, harmony with target)"}),"\n",(0,r.jsx)(n.li,{children:"Similarity(i, j): How similar photos i and j are (negative EMD)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-property",children:"Key Property"}),"\n",(0,r.jsx)(n.p,{children:"DPP naturally repels similar items. Probability of selecting a set S:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"P(S) \u221d det(K_S)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where K_S is the submatrix of K indexed by S."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Intuition:"})," Determinant is large when rows/columns are linearly independent \u2192 diverse sets favored."]}),"\n",(0,r.jsx)(n.h3,{id:"sampling-algorithm",children:"Sampling Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def sample_diverse_subset_dpp(photos_with_palettes, target_palette, k):\n    """\n    Sample k photos using Determinantal Point Process.\n\n    Automatically balances quality and diversity.\n\n    Args:\n        photos_with_palettes: [(photo_id, palette, aesthetic_score), ...]\n        target_palette: Global palette to match\n        k: Number of photos to sample\n\n    Returns:\n        List of k sampled photo_ids\n    """\n    n = len(photos_with_palettes)\n\n    # Compute quality scores\n    qualities = np.zeros(n)\n    for i, (pid, palette, aesthetic) in enumerate(photos_with_palettes):\n        harmony = -sinkhorn_emd(palette, target_palette)  # Higher = better\n        qualities[i] = aesthetic * 0.5 + harmony * 0.5  # Combine aesthetic & harmony\n\n    # Normalize qualities to [0, 1]\n    qualities = (qualities - qualities.min()) / (qualities.max() - qualities.min())\n\n    # Compute similarity matrix (negative EMD)\n    S = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                S[i, j] = 1.0\n            else:\n                emd = sinkhorn_emd(photos_with_palettes[i][1],\n                                   photos_with_palettes[j][1])\n                similarity = np.exp(-emd / 50)  # Convert distance to similarity\n                S[i, j] = S[j, i] = similarity\n\n    # Kernel matrix K = Q \xb7 S \xb7 Q (element-wise)\n    Q = np.diag(qualities)\n    K = Q @ S @ Q\n\n    # Sample k items using DPP\n    selected_indices = dpp_sample(K, k)\n\n    return [photos_with_palettes[i][0] for i in selected_indices]\n\n\ndef dpp_sample(K, k):\n    """\n    Sample k items from DPP with kernel K.\n\n    Uses eigenvalue decomposition method.\n    """\n    # Eigenvalue decomposition\n    eigenvalues, eigenvectors = np.linalg.eigh(K)\n\n    # Sample elementary DPP\n    selected = []\n    for i in range(len(eigenvalues) - 1, -1, -1):\n        if len(selected) >= k:\n            break\n        # Include eigenvalue with probability proportional to its magnitude\n        if np.random.rand() < eigenvalues[i] / (1 + eigenvalues[i]):\n            selected.append(i)\n\n    # Project to original space\n    items = np.random.choice(len(K), k, replace=False)\n    return items\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advantages-over-mmr",children:"Advantages over MMR"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Probabilistic: Can sample multiple diverse sets"}),"\n",(0,r.jsx)(n.li,{children:"Theoretically principled: Negative correlation built into model"}),"\n",(0,r.jsx)(n.li,{children:"Handles quality and diversity jointly"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More complex to implement"}),"\n",(0,r.jsx)(n.li,{children:"Requires eigenvalue decomposition (O(n\xb3))"}),"\n",(0,r.jsx)(n.li,{children:"Less intuitive to tune"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation:"})," Use MMR for simplicity and control, DPPs for elegant probabilistic diversity."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"method-3-submodular-maximization",children:"Method 3: Submodular Maximization"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Concept:"})," Define a submodular function (diminishing returns property) and greedily maximize it."]}),"\n",(0,r.jsx)(n.h3,{id:"submodular-function",children:"Submodular Function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"F(S) = Harmony(S, target) + Diversity(S)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Harmony(S, target): How well set S matches target palette"}),"\n",(0,r.jsx)(n.li,{children:"Diversity(S): Spread of colors in S (entropy, determinant, etc.)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Property:"})," Greedy algorithm achieves (1 - 1/e) \u2248 63% of optimal for submodular functions."]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def submodular_photo_selection(photos, target_palette, k):\n    """\n    Select k photos via submodular maximization.\n\n    Objective: F(S) = \u03b1\xb7Harmony(S) + \u03b2\xb7Diversity(S)\n    """\n    selected = []\n\n    def marginal_gain(photo, selected):\n        """Gain from adding photo to selected set."""\n        # Harmony term: How much closer to target?\n        current_palette = aggregate_palettes([p[1] for p in selected])\n        new_palette = aggregate_palettes([p[1] for p in selected + [photo]])\n\n        harmony_gain = (sinkhorn_emd(current_palette, target_palette)\n                       - sinkhorn_emd(new_palette, target_palette))\n\n        # Diversity term: How different from selected?\n        if not selected:\n            diversity_gain = 1.0  # First photo always diverse\n        else:\n            diversity_gain = min(\n                sinkhorn_emd(photo[1], s[1]) for s in selected\n            ) / 50  # Normalize\n\n        return 0.5 * harmony_gain + 0.5 * diversity_gain\n\n    # Greedy selection\n    remaining = list(photos)\n    for _ in range(k):\n        best_photo = max(remaining, key=lambda p: marginal_gain(p, selected))\n        selected.append(best_photo)\n        remaining.remove(best_photo)\n\n    return [photo_id for photo_id, _ in selected]\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"comparison-summary",children:"Comparison Summary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Complexity"}),(0,r.jsx)(n.th,{children:"Control"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"MMR"})}),(0,r.jsx)(n.td,{children:"O(k\xb7n)"}),(0,r.jsx)(n.td,{children:"\u03bb parameter"}),(0,r.jsx)(n.td,{children:"Real-time, tunable"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"DPP"})}),(0,r.jsx)(n.td,{children:"O(n\xb3)"}),(0,r.jsx)(n.td,{children:"Kernel design"}),(0,r.jsx)(n.td,{children:"Sampling multiple sets"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Submodular"})}),(0,r.jsx)(n.td,{children:"O(k\xb7n)"}),(0,r.jsx)(n.td,{children:"Function weights"}),(0,r.jsx)(n.td,{children:"Theoretical guarantees"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation:"})," Start with MMR (\u03bb=0.7) for most collage applications."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"issue-collage-feels-monotonous-despite-diversity-penalty",children:"Issue: Collage feels monotonous despite diversity penalty"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution:"})," Increase MMR diversity parameter (lower \u03bb from 0.7 to 0.5) or use DPP sampling."]})]})}function m(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);