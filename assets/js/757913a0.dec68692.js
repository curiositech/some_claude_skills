"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[54304],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var r=t(96540);const s={},i=r.createContext(s);function l(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:n},e.children)}},89130:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>g,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"skills/dag_result_aggregator/index","title":"\ud83d\udce6 Dag Result Aggregator","description":"Combines and synthesizes outputs from parallel DAG branches. Handles merge strategies, conflict resolution, and result formatting. Activate on \'aggregate results\', \'combine outputs\', \'merge branches\', \'synthesize results\', \'fan-in\'. NOT for execution (use dag-parallel-executor) or scheduling (use dag-task-scheduler).","source":"@site/docs/skills/dag_result_aggregator/index.md","sourceDirName":"skills/dag_result_aggregator","slug":"/skills/dag_result_aggregator/","permalink":"/docs/skills/dag_result_aggregator/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Result Aggregator","sidebar_position":1}}');var s=t(74848),i=t(28453);const l={sidebar_label:"Dag Result Aggregator",sidebar_position:1},a="\ud83d\udce6 Dag Result Aggregator",o={},c=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Result Collection",id:"1-result-collection",level:3},{value:"2. Merge Strategies",id:"2-merge-strategies",level:3},{value:"3. Result Transformation",id:"3-result-transformation",level:3},{value:"4. Conflict Resolution",id:"4-conflict-resolution",level:3},{value:"Aggregation Patterns",id:"aggregation-patterns",level:2},{value:"Pattern 1: Union Merge",id:"pattern-1-union-merge",level:3},{value:"Pattern 2: Intersection Merge",id:"pattern-2-intersection-merge",level:3},{value:"Pattern 3: Priority Merge",id:"pattern-3-priority-merge",level:3},{value:"Pattern 4: Weighted Average",id:"pattern-4-weighted-average",level:3},{value:"Pattern 5: Deep Merge",id:"pattern-5-deep-merge",level:3},{value:"Conflict Resolution Strategies",id:"conflict-resolution-strategies",level:2},{value:"Aggregation Configuration",id:"aggregation-configuration",level:2},{value:"Result Formatting",id:"result-formatting",level:2},{value:"Standard Output Format",id:"standard-output-format",level:3},{value:"Aggregation Report",id:"aggregation-report",level:3},{value:"Handling Partial Results",id:"handling-partial-results",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"-dag-result-aggregator",children:"\ud83d\udce6 Dag Result Aggregator"})}),"\n",(0,s.jsx)(n.p,{children:"Combines and synthesizes outputs from parallel DAG branches. Handles merge strategies, conflict resolution, and result formatting. Activate on 'aggregate results', 'combine outputs', 'merge branches', 'synthesize results', 'fan-in'. NOT for execution (use dag-parallel-executor) or scheduling (use dag-task-scheduler)."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dag"})," ",(0,s.jsx)(n.code,{children:"orchestration"})," ",(0,s.jsx)(n.code,{children:"aggregation"})," ",(0,s.jsx)(n.code,{children:"merge"})," ",(0,s.jsx)(n.code,{children:"fan-in"})]}),"\n",(0,s.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/skills/dag_parallel_executor",children:"Dag Parallel Executor"})}),": Receives results from parallel execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/skills/dag_output_validator",children:"Dag Output Validator"})}),": Validates aggregated results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/skills/dag_context_bridger",children:"Dag Context Bridger"})}),": Bridges aggregated context forward"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You are a DAG Result Aggregator, an expert at combining outputs from parallel DAG branches into unified results. You handle various merge strategies, resolve conflicts between parallel outputs, and format results for downstream consumption."}),"\n",(0,s.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,s.jsx)(n.h3,{id:"1-result-collection",children:"1. Result Collection"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gather outputs from all parallel branches"}),"\n",(0,s.jsx)(n.li,{children:"Track completion status of dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Handle partial results from failed branches"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-merge-strategies",children:"2. Merge Strategies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Select appropriate merge strategy based on data types"}),"\n",(0,s.jsx)(n.li,{children:"Handle conflicts between parallel outputs"}),"\n",(0,s.jsx)(n.li,{children:"Preserve important information from all branches"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-result-transformation",children:"3. Result Transformation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Format aggregated results for downstream nodes"}),"\n",(0,s.jsx)(n.li,{children:"Apply schema transformations"}),"\n",(0,s.jsx)(n.li,{children:"Validate output structure"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-conflict-resolution",children:"4. Conflict Resolution"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Detect conflicts in parallel outputs"}),"\n",(0,s.jsx)(n.li,{children:"Apply resolution strategies"}),"\n",(0,s.jsx)(n.li,{children:"Document resolution decisions"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"aggregation-patterns",children:"Aggregation Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"pattern-1-union-merge",children:"Pattern 1: Union Merge"}),"\n",(0,s.jsx)(n.p,{children:"Combine all results into a single collection."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function unionMerge<T>(\n  results: Map<NodeId, T[]>\n): T[] {\n  const merged: T[] = [];\n  for (const items of results.values()) {\n    merged.push(...items);\n  }\n  return merged;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when"}),": Collecting independent data from multiple sources."]}),"\n",(0,s.jsx)(n.h3,{id:"pattern-2-intersection-merge",children:"Pattern 2: Intersection Merge"}),"\n",(0,s.jsx)(n.p,{children:"Keep only results present in all branches."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function intersectionMerge<T>(\n  results: Map<NodeId, Set<T>>\n): Set<T> {\n  const sets = Array.from(results.values());\n  if (sets.length === 0) return new Set();\n\n  return sets.reduce((acc, set) =>\n    new Set([...acc].filter(x => set.has(x)))\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when"}),": Finding consensus across parallel analyses."]}),"\n",(0,s.jsx)(n.h3,{id:"pattern-3-priority-merge",children:"Pattern 3: Priority Merge"}),"\n",(0,s.jsx)(n.p,{children:"Use results from highest-priority branch, fallback to others."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function priorityMerge<T>(\n  results: Map<NodeId, T>,\n  priorities: Map<NodeId, number>\n): T {\n  const sorted = Array.from(results.entries())\n    .sort((a, b) =>\n      (priorities.get(b[0]) ?? 0) - (priorities.get(a[0]) ?? 0)\n    );\n\n  return sorted[0]?.[1];\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when"}),": Multiple branches produce alternatives with different reliability."]}),"\n",(0,s.jsx)(n.h3,{id:"pattern-4-weighted-average",children:"Pattern 4: Weighted Average"}),"\n",(0,s.jsx)(n.p,{children:"Combine numeric results with weights."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function weightedAverage(\n  results: Map<NodeId, number>,\n  weights: Map<NodeId, number>\n): number {\n  let sum = 0;\n  let totalWeight = 0;\n\n  for (const [nodeId, value] of results) {\n    const weight = weights.get(nodeId) ?? 1;\n    sum += value * weight;\n    totalWeight += weight;\n  }\n\n  return totalWeight > 0 ? sum / totalWeight : 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when"}),": Combining confidence scores or numeric assessments."]}),"\n",(0,s.jsx)(n.h3,{id:"pattern-5-deep-merge",children:"Pattern 5: Deep Merge"}),"\n",(0,s.jsx)(n.p,{children:"Recursively merge object structures."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function deepMerge(\n  results: Map<NodeId, object>,\n  conflictStrategy: ConflictStrategy\n): object {\n  const merged = {};\n\n  for (const [nodeId, obj] of results) {\n    for (const [key, value] of Object.entries(obj)) {\n      if (key in merged) {\n        merged[key] = resolveConflict(\n          merged[key],\n          value,\n          conflictStrategy\n        );\n      } else {\n        merged[key] = value;\n      }\n    }\n  }\n\n  return merged;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when"}),": Combining structured data from parallel branches."]}),"\n",(0,s.jsx)(n.h2,{id:"conflict-resolution-strategies",children:"Conflict Resolution Strategies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ConflictStrategy =\n  | 'first-wins'     // Keep first value encountered\n  | 'last-wins'      // Use most recent value\n  | 'highest-wins'   // For numeric: keep highest\n  | 'lowest-wins'    // For numeric: keep lowest\n  | 'concatenate'    // For strings/arrays: combine\n  | 'error'          // Throw on conflict\n  | 'custom';        // Use custom resolver\n\nfunction resolveConflict(\n  existing: unknown,\n  incoming: unknown,\n  strategy: ConflictStrategy\n): unknown {\n  switch (strategy) {\n    case 'first-wins':\n      return existing;\n\n    case 'last-wins':\n      return incoming;\n\n    case 'highest-wins':\n      return Math.max(\n        Number(existing),\n        Number(incoming)\n      );\n\n    case 'lowest-wins':\n      return Math.min(\n        Number(existing),\n        Number(incoming)\n      );\n\n    case 'concatenate':\n      if (Array.isArray(existing)) {\n        return [...existing, ...(incoming as unknown[])];\n      }\n      return `${existing}\\n${incoming}`;\n\n    case 'error':\n      throw new ConflictError(\n        `Conflict detected: ${existing} vs ${incoming}`\n      );\n\n    default:\n      return incoming;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"aggregation-configuration",children:"Aggregation Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"aggregation:\n  nodeId: aggregate-results\n  inputs:\n    - sourceNode: branch-a\n      field: findings\n    - sourceNode: branch-b\n      field: findings\n    - sourceNode: branch-c\n      field: findings\n\n  strategy:\n    type: deep-merge\n    conflictResolution: last-wins\n\n  transformations:\n    - deduplicate:\n        field: items\n        key: id\n    - sort:\n        field: items\n        by: relevance\n        order: desc\n    - limit:\n        field: items\n        max: 100\n\n  output:\n    schema:\n      type: object\n      properties:\n        combinedFindings:\n          type: array\n        metadata:\n          type: object\n"})}),"\n",(0,s.jsx)(n.h2,{id:"result-formatting",children:"Result Formatting"}),"\n",(0,s.jsx)(n.h3,{id:"standard-output-format",children:"Standard Output Format"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AggregatedResult {\n  // Aggregation metadata\n  aggregationId: string;\n  aggregatedAt: Date;\n  sourceNodes: NodeId[];\n  strategy: string;\n\n  // Aggregated data\n  data: unknown;\n\n  // Conflict information\n  conflicts: ConflictRecord[];\n  resolutions: ResolutionRecord[];\n\n  // Statistics\n  stats: {\n    totalInputs: number;\n    successfulInputs: number;\n    failedInputs: number;\n    conflictsResolved: number;\n  };\n}\n\ninterface ConflictRecord {\n  field: string;\n  values: Array<{\n    nodeId: NodeId;\n    value: unknown;\n  }>;\n  resolution: unknown;\n  strategy: ConflictStrategy;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"aggregation-report",children:"Aggregation Report"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'aggregationReport:\n  nodeId: combine-analysis\n  completedAt: "2024-01-15T10:01:30Z"\n\n  inputs:\n    - nodeId: analyze-code\n      status: completed\n      outputSize: 2500\n    - nodeId: analyze-tests\n      status: completed\n      outputSize: 1800\n    - nodeId: analyze-docs\n      status: failed\n      error: "Timeout exceeded"\n\n  aggregation:\n    strategy: union-merge\n    totalItems: 45\n    uniqueItems: 38\n    duplicatesRemoved: 7\n\n  conflicts:\n    - field: severity\n      count: 3\n      resolution: highest-wins\n\n  output:\n    type: array\n    itemCount: 38\n    schema: Finding[]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"handling-partial-results",children:"Handling Partial Results"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function aggregateWithPartialResults(\n  expected: NodeId[],\n  results: Map<NodeId, TaskResult>,\n  config: AggregationConfig\n): AggregatedResult {\n  const successful = new Map<NodeId, unknown>();\n  const failed: NodeId[] = [];\n\n  for (const nodeId of expected) {\n    const result = results.get(nodeId);\n    if (result?.status === 'completed') {\n      successful.set(nodeId, result.output);\n    } else {\n      failed.push(nodeId);\n    }\n  }\n\n  // Check if we have enough results\n  const successRate = successful.size / expected.length;\n  if (successRate < config.minimumSuccessRate) {\n    throw new InsufficientResultsError(\n      `Only ${successRate * 100}% of branches succeeded`\n    );\n  }\n\n  // Aggregate available results\n  return aggregate(successful, config);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Results from ",(0,s.jsx)(n.code,{children:"dag-parallel-executor"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": Via ",(0,s.jsx)(n.code,{children:"dag-output-validator"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context"}),": Forward via ",(0,s.jsx)(n.code,{children:"dag-context-bridger"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Errors"}),": Report to ",(0,s.jsx)(n.code,{children:"dag-failure-analyzer"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle Failures Gracefully"}),": Partial results are often acceptable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document Conflicts"}),": Track what was resolved and how"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validate Output"}),": Ensure aggregated result meets schema"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Preserve Provenance"}),": Track which node contributed what"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimize Memory"}),": Stream large result sets when possible"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Many inputs. One output. Unified results."})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);