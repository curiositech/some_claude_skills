"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[30633],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var s=t(96540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},45058:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"skills/mcp_creator/references/testing-debugging","title":"MCP Testing and Debugging Guide","description":"Testing Tools","source":"@site/docs/skills/mcp_creator/references/testing-debugging.md","sourceDirName":"skills/mcp_creator/references","slug":"/skills/mcp_creator/references/testing-debugging","permalink":"/docs/skills/mcp_creator/references/testing-debugging","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"MCP Testing and Debugging Guide","sidebar_label":"MCP Testing and Debugging G...","sidebar_position":3}}');var i=t(74848),r=t(28453);const o={title:"MCP Testing and Debugging Guide",sidebar_label:"MCP Testing and Debugging G...",sidebar_position:3},l="MCP Testing and Debugging Guide",a={},c=[{value:"Testing Tools",id:"testing-tools",level:2},{value:"MCP Inspector (Official)",id:"mcp-inspector-official",level:3},{value:"Manual Testing with Node",id:"manual-testing-with-node",level:3},{value:"Unit Testing",id:"unit-testing",level:2},{value:"Testing Tool Handlers",id:"testing-tool-handlers",level:3},{value:"Testing Input Validation",id:"testing-input-validation",level:3},{value:"Testing Rate Limiter",id:"testing-rate-limiter",level:3},{value:"Testing API Client",id:"testing-api-client",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"Full Server Test",id:"full-server-test",level:3},{value:"Debugging Techniques",id:"debugging-techniques",level:2},{value:"Structured Logging",id:"structured-logging",level:3},{value:"Request Tracing",id:"request-tracing",level:3},{value:"Error Debugging",id:"error-debugging",level:3},{value:"Performance Profiling",id:"performance-profiling",level:2},{value:"Simple Timing",id:"simple-timing",level:3},{value:"Memory Monitoring",id:"memory-monitoring",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:2},{value:"Issue: Server Hangs on Startup",id:"issue-server-hangs-on-startup",level:3},{value:"Issue: Memory Leaks",id:"issue-memory-leaks",level:3},{value:"Issue: Rate Limit Errors from API",id:"issue-rate-limit-errors-from-api",level:3},{value:"Issue: Timeout Errors",id:"issue-timeout-errors",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"mcp-testing-and-debugging-guide",children:"MCP Testing and Debugging Guide"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-tools",children:"Testing Tools"}),"\n",(0,i.jsx)(n.h3,{id:"mcp-inspector-official",children:"MCP Inspector (Official)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install globally\nnpm install -g @modelcontextprotocol/inspector\n\n# Run inspector\nnpx @modelcontextprotocol/inspector\n\n# Connect to your server\n# In inspector UI: Connect to stdio server\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Inspector capabilities:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"List available tools and resources"}),"\n",(0,i.jsx)(n.li,{children:"Execute tool calls with custom arguments"}),"\n",(0,i.jsx)(n.li,{children:"View request/response JSON"}),"\n",(0,i.jsx)(n.li,{children:"Test error handling"}),"\n",(0,i.jsx)(n.li,{children:"Profile performance"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"manual-testing-with-node",children:"Manual Testing with Node"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// test-client.ts\nimport { Client } from "@modelcontextprotocol/sdk/client/index.js";\nimport { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";\nimport { spawn } from "child_process";\n\nasync function testServer() {\n  // Spawn server process\n  const serverProcess = spawn("node", ["dist/index.js"]);\n\n  const transport = new StdioClientTransport({\n    command: "node",\n    args: ["dist/index.js"],\n  });\n\n  const client = new Client({\n    name: "test-client",\n    version: "1.0.0",\n  }, {\n    capabilities: {},\n  });\n\n  await client.connect(transport);\n\n  // List tools\n  const tools = await client.listTools();\n  console.log("Available tools:", tools);\n\n  // Call a tool\n  const result = await client.callTool({\n    name: "my_tool",\n    arguments: { input: "test" },\n  });\n  console.log("Result:", result);\n\n  await client.close();\n}\n\ntestServer().catch(console.error);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,i.jsx)(n.h3,{id:"testing-tool-handlers",children:"Testing Tool Handlers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// __tests__/handlers.test.ts\nimport { describe, it, expect, beforeEach, vi } from "vitest";\nimport { handleMyTool } from "../src/handlers";\n\ndescribe("handleMyTool", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it("should validate input correctly", async () => {\n    await expect(handleMyTool({ input: "" }))\n      .rejects.toThrow("Input is required");\n  });\n\n  it("should process valid input", async () => {\n    const result = await handleMyTool({ input: "test" });\n\n    expect(result).toHaveProperty("success", true);\n    expect(result).toHaveProperty("data");\n  });\n\n  it("should handle options correctly", async () => {\n    const result = await handleMyTool({\n      input: "test",\n      options: { format: "text" },\n    });\n\n    expect(typeof result).toBe("string");\n  });\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing-input-validation",children:"Testing Input Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// __tests__/validation.test.ts\nimport { describe, it, expect } from "vitest";\nimport { z } from "zod";\nimport { MyToolSchema } from "../src/schemas";\n\ndescribe("MyToolSchema", () => {\n  it("should accept valid input", () => {\n    const input = { userId: "abc123", action: "read" };\n    expect(() => MyToolSchema.parse(input)).not.toThrow();\n  });\n\n  it("should reject missing required fields", () => {\n    const input = { action: "read" };\n    expect(() => MyToolSchema.parse(input)).toThrow();\n  });\n\n  it("should reject invalid userId format", () => {\n    const input = { userId: "invalid!!!", action: "read" };\n    expect(() => MyToolSchema.parse(input)).toThrow();\n  });\n\n  it("should reject invalid enum values", () => {\n    const input = { userId: "abc123", action: "invalid" };\n    expect(() => MyToolSchema.parse(input)).toThrow();\n  });\n\n  it("should apply defaults", () => {\n    const input = { userId: "abc123", action: "read" };\n    const result = MyToolSchema.parse(input);\n    expect(result.options?.limit).toBe(10);\n  });\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing-rate-limiter",children:"Testing Rate Limiter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// __tests__/rate-limiter.test.ts\nimport { describe, it, expect, beforeEach, vi } from "vitest";\nimport { RateLimiter } from "../src/rate-limiter";\n\ndescribe("RateLimiter", () => {\n  let limiter: RateLimiter;\n\n  beforeEach(() => {\n    vi.useFakeTimers();\n    limiter = new RateLimiter(10, 60000); // 10 per minute\n  });\n\n  it("should allow requests under limit", () => {\n    for (let i = 0; i < 10; i++) {\n      expect(limiter.canProceed("user1")).toBe(true);\n    }\n  });\n\n  it("should block requests over limit", () => {\n    for (let i = 0; i < 10; i++) {\n      limiter.canProceed("user1");\n    }\n    expect(limiter.canProceed("user1")).toBe(false);\n  });\n\n  it("should reset after window expires", () => {\n    for (let i = 0; i < 10; i++) {\n      limiter.canProceed("user1");\n    }\n\n    // Advance time by 1 minute\n    vi.advanceTimersByTime(60000);\n\n    expect(limiter.canProceed("user1")).toBe(true);\n  });\n\n  it("should track users independently", () => {\n    for (let i = 0; i < 10; i++) {\n      limiter.canProceed("user1");\n    }\n\n    expect(limiter.canProceed("user1")).toBe(false);\n    expect(limiter.canProceed("user2")).toBe(true);\n  });\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing-api-client",children:"Testing API Client"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// __tests__/api-client.test.ts\nimport { describe, it, expect, beforeEach, vi } from "vitest";\nimport { apiRequest } from "../src/api-client";\n\n// Mock fetch\nglobal.fetch = vi.fn();\n\ndescribe("apiRequest", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it("should make successful request", async () => {\n    (fetch as any).mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({ data: "test" }),\n    });\n\n    const result = await apiRequest("/endpoint");\n    expect(result).toEqual({ data: "test" });\n  });\n\n  it("should retry on 5xx errors", async () => {\n    (fetch as any)\n      .mockResolvedValueOnce({ ok: false, status: 500, text: async () => "Error" })\n      .mockResolvedValueOnce({ ok: true, json: async () => ({ data: "success" }) });\n\n    const result = await apiRequest("/endpoint");\n    expect(result).toEqual({ data: "success" });\n    expect(fetch).toHaveBeenCalledTimes(2);\n  });\n\n  it("should not retry on 4xx errors", async () => {\n    (fetch as any).mockResolvedValueOnce({\n      ok: false,\n      status: 400,\n      text: async () => "Bad request",\n    });\n\n    await expect(apiRequest("/endpoint")).rejects.toThrow();\n    expect(fetch).toHaveBeenCalledTimes(1);\n  });\n\n  it("should handle timeout", async () => {\n    vi.useFakeTimers();\n\n    (fetch as any).mockImplementationOnce(() => new Promise(() => {})); // Never resolves\n\n    const promise = apiRequest("/endpoint", { timeout: 1000 });\n\n    vi.advanceTimersByTime(1000);\n\n    await expect(promise).rejects.toThrow("timeout");\n  });\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,i.jsx)(n.h3,{id:"full-server-test",children:"Full Server Test"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// __tests__/integration.test.ts\nimport { describe, it, expect, beforeAll, afterAll } from "vitest";\nimport { spawn, ChildProcess } from "child_process";\nimport { Client } from "@modelcontextprotocol/sdk/client/index.js";\nimport { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";\n\ndescribe("MCP Server Integration", () => {\n  let client: Client;\n  let serverProcess: ChildProcess;\n\n  beforeAll(async () => {\n    const transport = new StdioClientTransport({\n      command: "node",\n      args: ["dist/index.js"],\n      env: {\n        ...process.env,\n        API_KEY: "test-key",\n        API_BASE_URL: "http://localhost:3000",\n      },\n    });\n\n    client = new Client({ name: "test", version: "1.0.0" }, { capabilities: {} });\n    await client.connect(transport);\n  });\n\n  afterAll(async () => {\n    await client.close();\n  });\n\n  it("should list tools", async () => {\n    const { tools } = await client.listTools();\n\n    expect(tools).toBeInstanceOf(Array);\n    expect(tools.length).toBeGreaterThan(0);\n    expect(tools[0]).toHaveProperty("name");\n    expect(tools[0]).toHaveProperty("inputSchema");\n  });\n\n  it("should execute tool successfully", async () => {\n    const result = await client.callTool({\n      name: "example_tool",\n      arguments: { input: "test" },\n    });\n\n    expect(result.content).toBeInstanceOf(Array);\n    expect(result.content[0].type).toBe("text");\n  });\n\n  it("should handle invalid arguments", async () => {\n    await expect(\n      client.callTool({\n        name: "example_tool",\n        arguments: { input: "" },\n      })\n    ).rejects.toThrow();\n  });\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"debugging-techniques",children:"Debugging Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"structured-logging",children:"Structured Logging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Add to your server\nconst DEBUG = process.env.DEBUG === "true";\n\nfunction debug(message: string, data?: unknown) {\n  if (DEBUG) {\n    console.error(JSON.stringify({\n      timestamp: new Date().toISOString(),\n      level: "debug",\n      message,\n      data,\n    }));\n  }\n}\n\n// In handlers\ndebug("Tool called", { name, args });\ndebug("API response", { status, body });\n'})}),"\n",(0,i.jsx)(n.h3,{id:"request-tracing",children:"Request Tracing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { randomUUID } from "crypto";\n\ninterface RequestContext {\n  requestId: string;\n  startTime: number;\n  tool: string;\n}\n\nconst activeRequests = new Map<string, RequestContext>();\n\nfunction startRequest(tool: string): string {\n  const requestId = randomUUID();\n  activeRequests.set(requestId, {\n    requestId,\n    startTime: Date.now(),\n    tool,\n  });\n  console.error(`[${requestId}] START ${tool}`);\n  return requestId;\n}\n\nfunction endRequest(requestId: string, success: boolean) {\n  const ctx = activeRequests.get(requestId);\n  if (ctx) {\n    const duration = Date.now() - ctx.startTime;\n    console.error(`[${requestId}] END ${ctx.tool} ${success ? "OK" : "FAIL"} ${duration}ms`);\n    activeRequests.delete(requestId);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"error-debugging",children:"Error Debugging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Detailed error logging\nfunction logError(error: unknown, context: Record<string, unknown>) {\n  const errorInfo = {\n    timestamp: new Date().toISOString(),\n    type: error instanceof Error ? error.constructor.name : typeof error,\n    message: error instanceof Error ? error.message : String(error),\n    stack: error instanceof Error ? error.stack : undefined,\n    context,\n  };\n\n  console.error("ERROR:", JSON.stringify(errorInfo, null, 2));\n}\n\n// Usage in handlers\ntry {\n  // ... handler code\n} catch (error) {\n  logError(error, { tool: name, args: sanitizedArgs });\n  throw error;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-profiling",children:"Performance Profiling"}),"\n",(0,i.jsx)(n.h3,{id:"simple-timing",children:"Simple Timing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'function withTiming<T>(\n  name: string,\n  fn: () => Promise<T>\n): Promise<T> {\n  const start = process.hrtime.bigint();\n\n  return fn().finally(() => {\n    const end = process.hrtime.bigint();\n    const durationMs = Number(end - start) / 1_000_000;\n    console.error(`TIMING ${name}: ${durationMs.toFixed(2)}ms`);\n  });\n}\n\n// Usage\nconst result = await withTiming("api_call", () => apiRequest("/endpoint"));\n'})}),"\n",(0,i.jsx)(n.h3,{id:"memory-monitoring",children:"Memory Monitoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'function logMemory() {\n  const usage = process.memoryUsage();\n  console.error("MEMORY:", {\n    heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,\n    heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)}MB`,\n    external: `${Math.round(usage.external / 1024 / 1024)}MB`,\n  });\n}\n\n// Log periodically\nsetInterval(logMemory, 60000);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,i.jsx)(n.h3,{id:"issue-server-hangs-on-startup",children:"Issue: Server Hangs on Startup"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": Blocking initialization (missing await, sync I/O)\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Ensure all initialization is async"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// \u274c Bad\nconst config = fs.readFileSync("config.json");  // Blocks\n\n// \u2705 Good\nconst config = await fs.promises.readFile("config.json");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"issue-memory-leaks",children:"Issue: Memory Leaks"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": Unbounded caches, event listener accumulation\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Set limits, cleanup old entries"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Add TTL and max size to caches\nclass BoundedCache<T> {\n  private store = new Map<string, { value: T; expires: number }>();\n  private maxSize: number;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  set(key: string, value: T, ttlMs: number) {\n    // Evict oldest if at capacity\n    if (this.store.size >= this.maxSize) {\n      const oldest = this.store.keys().next().value;\n      this.store.delete(oldest);\n    }\n    this.store.set(key, { value, expires: Date.now() + ttlMs });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"issue-rate-limit-errors-from-api",children:"Issue: Rate Limit Errors from API"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": Not respecting Retry-After header\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Parse and respect rate limit headers"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'if (response.status === 429) {\n  const retryAfter = response.headers.get("Retry-After");\n  const waitMs = retryAfter\n    ? parseInt(retryAfter) * 1000\n    : 60000;  // Default 1 minute\n\n  console.error(`Rate limited, waiting ${waitMs}ms`);\n  await new Promise(r => setTimeout(r, waitMs));\n  // Retry...\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"issue-timeout-errors",children:"Issue: Timeout Errors"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": No timeout on external requests\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Always set timeouts"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const controller = new AbortController();\nconst timeout = setTimeout(() => controller.abort(), 30000);\n\ntry {\n  const response = await fetch(url, { signal: controller.signal });\n} finally {\n  clearTimeout(timeout);\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);