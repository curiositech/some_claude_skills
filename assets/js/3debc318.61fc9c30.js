"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[63374],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},48369:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>g,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"skills/dag_iteration_detector/index","title":"\ud83d\udce6 Dag Iteration Detector","description":"Identifies when task outputs require iteration based on quality signals, unmet requirements, or explicit feedback. Triggers appropriate re-execution strategies. Activate on \'needs iteration\', \'retry needed\', \'not good enough\', \'try again\', \'refine output\'. NOT for feedback generation (use dag-feedback-synthesizer) or convergence tracking (use dag-convergence-monitor).","source":"@site/docs/skills/dag_iteration_detector/index.md","sourceDirName":"skills/dag_iteration_detector","slug":"/skills/dag_iteration_detector/","permalink":"/docs/skills/dag_iteration_detector/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Iteration Detector","sidebar_position":1}}');var r=t(74848),s=t(28453);const a={sidebar_label:"Dag Iteration Detector",sidebar_position:1},o="\ud83d\udce6 Dag Iteration Detector",c={},l=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Iteration Trigger Detection",id:"1-iteration-trigger-detection",level:3},{value:"2. Iteration Strategy Selection",id:"2-iteration-strategy-selection",level:3},{value:"3. Iteration Budget Management",id:"3-iteration-budget-management",level:3},{value:"4. Improvement Potential Assessment",id:"4-improvement-potential-assessment",level:3},{value:"Detection Architecture",id:"detection-architecture",level:2},{value:"Trigger Detection",id:"trigger-detection",level:2},{value:"Strategy Selection",id:"strategy-selection",level:2},{value:"Iteration Budget",id:"iteration-budget",level:2},{value:"Improvement Assessment",id:"improvement-assessment",level:2},{value:"Decision Report",id:"decision-report",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"-dag-iteration-detector",children:"\ud83d\udce6 Dag Iteration Detector"})}),"\n",(0,r.jsx)(n.p,{children:"Identifies when task outputs require iteration based on quality signals, unmet requirements, or explicit feedback. Triggers appropriate re-execution strategies. Activate on 'needs iteration', 'retry needed', 'not good enough', 'try again', 'refine output'. NOT for feedback generation (use dag-feedback-synthesizer) or convergence tracking (use dag-convergence-monitor)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"dag"})," ",(0,r.jsx)(n.code,{children:"feedback"})," ",(0,r.jsx)(n.code,{children:"iteration"})," ",(0,r.jsx)(n.code,{children:"refinement"})," ",(0,r.jsx)(n.code,{children:"quality"})]}),"\n",(0,r.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_feedback_synthesizer",children:"Dag Feedback Synthesizer"})}),": Synthesizes feedback for iteration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_convergence_monitor",children:"Dag Convergence Monitor"})}),": Tracks iteration progress"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_output_validator",children:"Dag Output Validator"})}),": Uses validation results"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_confidence_scorer",children:"Dag Confidence Scorer"})}),": Uses confidence thresholds"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You are a DAG Iteration Detector, an expert at identifying when task outputs require additional iteration. You analyze quality signals, validation results, confidence scores, and explicit feedback to determine when re-execution is needed and what type of iteration strategy is appropriate."}),"\n",(0,r.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,r.jsx)(n.h3,{id:"1-iteration-trigger-detection",children:"1. Iteration Trigger Detection"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Analyze validation failures"}),"\n",(0,r.jsx)(n.li,{children:"Check confidence thresholds"}),"\n",(0,r.jsx)(n.li,{children:"Detect incomplete outputs"}),"\n",(0,r.jsx)(n.li,{children:"Process explicit feedback"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-iteration-strategy-selection",children:"2. Iteration Strategy Selection"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Determine retry vs refinement"}),"\n",(0,r.jsx)(n.li,{children:"Select appropriate iteration type"}),"\n",(0,r.jsx)(n.li,{children:"Configure iteration parameters"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-iteration-budget-management",children:"3. Iteration Budget Management"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Track iteration counts"}),"\n",(0,r.jsx)(n.li,{children:"Enforce iteration limits"}),"\n",(0,r.jsx)(n.li,{children:"Prevent infinite loops"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-improvement-potential-assessment",children:"4. Improvement Potential Assessment"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Estimate likelihood of improvement"}),"\n",(0,r.jsx)(n.li,{children:"Assess diminishing returns"}),"\n",(0,r.jsx)(n.li,{children:"Recommend escalation when needed"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"detection-architecture",children:"Detection Architecture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface IterationDecision {\n  needsIteration: boolean;\n  triggers: IterationTrigger[];\n  strategy: IterationStrategy;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  budget: IterationBudget;\n  recommendation: IterationRecommendation;\n}\n\ninterface IterationTrigger {\n  type: TriggerType;\n  source: string;\n  severity: number;  // 0-1\n  details: string;\n  fixable: boolean;\n}\n\ntype TriggerType =\n  | 'validation_failure'\n  | 'low_confidence'\n  | 'incomplete_output'\n  | 'explicit_feedback'\n  | 'hallucination_detected'\n  | 'requirement_unmet'\n  | 'quality_threshold'\n  | 'user_rejection';\n\ninterface IterationStrategy {\n  type: 'retry' | 'refine' | 'expand' | 'simplify' | 'escalate';\n  modifications: StrategyModification[];\n  contextAdjustments: ContextAdjustment[];\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"trigger-detection",children:"Trigger Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface QualitySignals {\n  validation: ValidationResult;\n  confidence: ConfidenceScore;\n  hallucination: HallucinationReport;\n  userFeedback?: UserFeedback;\n  requirements: RequirementStatus[];\n}\n\nfunction detectIterationTriggers(\n  output: TaskOutput,\n  signals: QualitySignals,\n  config: DetectionConfig\n): IterationTrigger[] {\n  const triggers: IterationTrigger[] = [];\n\n  // Check validation failures\n  if (!signals.validation.valid) {\n    triggers.push(...extractValidationTriggers(signals.validation));\n  }\n\n  // Check confidence threshold\n  if (signals.confidence.calibrated < config.minConfidence) {\n    triggers.push({\n      type: 'low_confidence',\n      source: 'confidence-scorer',\n      severity: 1 - signals.confidence.calibrated,\n      details: `Confidence ${(signals.confidence.calibrated * 100).toFixed(0)}% below threshold ${(config.minConfidence * 100).toFixed(0)}%`,\n      fixable: true,\n    });\n  }\n\n  // Check for hallucinations\n  if (signals.hallucination.overallRisk !== 'low') {\n    triggers.push(...extractHallucinationTriggers(signals.hallucination));\n  }\n\n  // Check explicit user feedback\n  if (signals.userFeedback?.sentiment === 'negative') {\n    triggers.push({\n      type: 'explicit_feedback',\n      source: 'user',\n      severity: 0.9,\n      details: signals.userFeedback.message,\n      fixable: true,\n    });\n  }\n\n  // Check unmet requirements\n  const unmetRequirements = signals.requirements.filter(r => !r.met);\n  for (const req of unmetRequirements) {\n    triggers.push({\n      type: 'requirement_unmet',\n      source: 'requirement-checker',\n      severity: req.priority === 'required' ? 0.9 : 0.5,\n      details: `Requirement not met: ${req.description}`,\n      fixable: req.fixable,\n    });\n  }\n\n  // Check for incomplete output\n  const completeness = assessCompleteness(output);\n  if (completeness < config.minCompleteness) {\n    triggers.push({\n      type: 'incomplete_output',\n      source: 'completeness-checker',\n      severity: 1 - completeness,\n      details: `Output ${(completeness * 100).toFixed(0)}% complete, minimum ${(config.minCompleteness * 100).toFixed(0)}%`,\n      fixable: true,\n    });\n  }\n\n  return triggers;\n}\n\nfunction extractValidationTriggers(validation: ValidationResult): IterationTrigger[] {\n  return validation.errors.map(error => ({\n    type: 'validation_failure' as const,\n    source: 'output-validator',\n    severity: error.severity === 'critical' ? 1.0 : 0.7,\n    details: `${error.path}: ${error.message}`,\n    fixable: !['TYPE_MISMATCH', 'SCHEMA_VIOLATION'].includes(error.code),\n  }));\n}\n\nfunction extractHallucinationTriggers(report: HallucinationReport): IterationTrigger[] {\n  return report.findings\n    .filter(f => f.severity !== 'warning')\n    .map(finding => ({\n      type: 'hallucination_detected' as const,\n      source: 'hallucination-detector',\n      severity: finding.severity === 'confirmed' ? 1.0 : 0.7,\n      details: `${finding.type}: ${finding.claim}`,\n      fixable: true,\n    }));\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"strategy-selection",children:"Strategy Selection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function selectIterationStrategy(\n  triggers: IterationTrigger[],\n  history: IterationHistory,\n  context: TaskContext\n): IterationStrategy {\n  // Analyze trigger patterns\n  const triggerTypes = new Set(triggers.map(t => t.type));\n  const avgSeverity = triggers.reduce((sum, t) => sum + t.severity, 0) / triggers.length;\n\n  // Check iteration history\n  const previousAttempts = history.attempts;\n  const lastStrategy = history.lastStrategy;\n\n  // If same triggers after retry, try refinement\n  if (lastStrategy?.type === 'retry' && hasSameTriggers(triggers, history.lastTriggers)) {\n    return {\n      type: 'refine',\n      modifications: generateRefinementModifications(triggers),\n      contextAdjustments: [\n        { type: 'add_guidance', content: 'Focus on specific issues identified' },\n        { type: 'increase_detail', factor: 1.5 },\n      ],\n    };\n  }\n\n  // Validation failures - retry with fixes\n  if (triggerTypes.has('validation_failure')) {\n    return {\n      type: 'retry',\n      modifications: [\n        { type: 'fix_errors', targets: triggers.filter(t => t.type === 'validation_failure') },\n      ],\n      contextAdjustments: [\n        { type: 'add_schema_guidance', schema: context.expectedSchema },\n      ],\n    };\n  }\n\n  // Low confidence - expand with more detail\n  if (triggerTypes.has('low_confidence')) {\n    return {\n      type: 'expand',\n      modifications: [\n        { type: 'request_evidence', areas: extractLowConfidenceAreas(triggers) },\n        { type: 'request_sources' },\n      ],\n      contextAdjustments: [\n        { type: 'add_guidance', content: 'Provide more evidence and reasoning' },\n      ],\n    };\n  }\n\n  // Hallucinations - retry with verification emphasis\n  if (triggerTypes.has('hallucination_detected')) {\n    return {\n      type: 'retry',\n      modifications: [\n        { type: 'remove_claims', claims: extractFalseClaims(triggers) },\n        { type: 'require_verification' },\n      ],\n      contextAdjustments: [\n        { type: 'add_guidance', content: 'Verify all factual claims before including' },\n        { type: 'restrict_sources', allowedSources: context.verifiedSources },\n      ],\n    };\n  }\n\n  // Too many iterations - escalate\n  if (previousAttempts >= context.maxIterations - 1) {\n    return {\n      type: 'escalate',\n      modifications: [\n        { type: 'flag_for_human', reason: 'Max iterations reached' },\n      ],\n      contextAdjustments: [],\n    };\n  }\n\n  // Default: simple retry\n  return {\n    type: 'retry',\n    modifications: [],\n    contextAdjustments: [\n      { type: 'add_guidance', content: 'Address the identified issues' },\n    ],\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"iteration-budget",children:"Iteration Budget"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface IterationBudget {\n  maxIterations: number;\n  currentIteration: number;\n  remainingIterations: number;\n  tokenBudget: number;\n  usedTokens: number;\n  remainingTokens: number;\n  timeoutMs: number;\n  elapsedMs: number;\n  remainingMs: number;\n}\n\nfunction checkIterationBudget(\n  current: IterationBudget,\n  estimatedCost: IterationCost\n): BudgetCheck {\n  const checks = {\n    iterations: current.remainingIterations > 0,\n    tokens: current.remainingTokens >= estimatedCost.tokens,\n    time: current.remainingMs >= estimatedCost.estimatedMs,\n  };\n\n  return {\n    canIterate: checks.iterations && checks.tokens && checks.time,\n    blockers: Object.entries(checks)\n      .filter(([_, ok]) => !ok)\n      .map(([resource]) => resource),\n    warnings: generateBudgetWarnings(current, estimatedCost),\n  };\n}\n\nfunction updateBudget(\n  budget: IterationBudget,\n  iterationResult: IterationResult\n): IterationBudget {\n  return {\n    ...budget,\n    currentIteration: budget.currentIteration + 1,\n    remainingIterations: budget.remainingIterations - 1,\n    usedTokens: budget.usedTokens + iterationResult.tokensUsed,\n    remainingTokens: budget.remainingTokens - iterationResult.tokensUsed,\n    elapsedMs: budget.elapsedMs + iterationResult.durationMs,\n    remainingMs: budget.remainingMs - iterationResult.durationMs,\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"improvement-assessment",children:"Improvement Assessment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface ImprovementAssessment {\n  likelihood: number;          // 0-1 probability of improvement\n  expectedGain: number;        // 0-1 expected quality improvement\n  diminishingReturns: boolean; // Whether we're seeing diminishing returns\n  recommendation: 'iterate' | 'accept' | 'escalate' | 'abort';\n}\n\nfunction assessImprovementPotential(\n  history: IterationHistory,\n  triggers: IterationTrigger[],\n  budget: IterationBudget\n): ImprovementAssessment {\n  // Calculate improvement trend\n  const qualityScores = history.iterations.map(i => i.qualityScore);\n  const trend = calculateTrend(qualityScores);\n\n  // Check for plateauing\n  const recentScores = qualityScores.slice(-3);\n  const variance = calculateVariance(recentScores);\n  const isPlateauing = variance < 0.02 && recentScores.length >= 3;\n\n  // Estimate likelihood based on trigger fixability\n  const fixableTriggers = triggers.filter(t => t.fixable);\n  const fixabilityRatio = fixableTriggers.length / triggers.length;\n\n  // Calculate expected gain\n  const avgTriggerSeverity = triggers.reduce((sum, t) => sum + t.severity, 0) / triggers.length;\n  const expectedGain = fixabilityRatio * avgTriggerSeverity * (isPlateauing ? 0.3 : 0.7);\n\n  // Determine recommendation\n  let recommendation: ImprovementAssessment['recommendation'];\n\n  if (budget.remainingIterations === 0) {\n    recommendation = 'accept'; // Out of budget\n  } else if (isPlateauing && trend < 0.01) {\n    recommendation = 'escalate'; // Not improving\n  } else if (expectedGain < 0.1) {\n    recommendation = 'accept'; // Not worth iterating\n  } else if (fixabilityRatio < 0.3) {\n    recommendation = 'escalate'; // Can't fix most issues\n  } else {\n    recommendation = 'iterate';\n  }\n\n  return {\n    likelihood: fixabilityRatio * (1 - (isPlateauing ? 0.5 : 0)),\n    expectedGain,\n    diminishingReturns: isPlateauing,\n    recommendation,\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"decision-report",children:"Decision Report"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'iterationDecision:\n  taskId: code-review-task\n  outputId: review-attempt-2\n  decidedAt: "2024-01-15T10:30:00Z"\n\n  decision:\n    needsIteration: true\n    priority: high\n\n  triggers:\n    - type: validation_failure\n      source: output-validator\n      severity: 0.8\n      details: "$.analysis.security: Required field \'security\' is missing"\n      fixable: true\n\n    - type: low_confidence\n      source: confidence-scorer\n      severity: 0.4\n      details: "Confidence 62% below threshold 75%"\n      fixable: true\n\n    - type: requirement_unmet\n      source: requirement-checker\n      severity: 0.6\n      details: "Requirement not met: Must include performance analysis"\n      fixable: true\n\n  strategy:\n    type: refine\n    modifications:\n      - type: fix_errors\n        targets: ["security field", "performance analysis"]\n      - type: request_evidence\n        areas: ["security assessment", "performance metrics"]\n    contextAdjustments:\n      - type: add_guidance\n        content: "Add security section and performance analysis with metrics"\n      - type: increase_detail\n        factor: 1.3\n\n  budget:\n    maxIterations: 5\n    currentIteration: 2\n    remainingIterations: 3\n    tokenBudget: 50000\n    usedTokens: 12500\n    remainingTokens: 37500\n\n  assessment:\n    likelihood: 0.75\n    expectedGain: 0.35\n    diminishingReturns: false\n    recommendation: iterate\n\n  nextSteps:\n    - "Add security analysis section"\n    - "Include performance metrics"\n    - "Increase evidence and citations"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input"}),": Quality signals from validation, confidence, hallucination detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output"}),": Iteration decisions to ",(0,r.jsx)(n.code,{children:"dag-dynamic-replanner"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feedback"}),": Sends triggers to ",(0,r.jsx)(n.code,{children:"dag-feedback-synthesizer"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tracking"}),": Reports to ",(0,r.jsx)(n.code,{children:"dag-convergence-monitor"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-Signal Analysis"}),": Don't rely on single trigger"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Budget Awareness"}),": Always check remaining budget"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trend Detection"}),": Identify plateauing early"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Escalation Path"}),": Know when to stop iterating"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Strategy Variety"}),": Don't repeat failed strategies"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Smart iteration. Know when to retry. Know when to stop."})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);