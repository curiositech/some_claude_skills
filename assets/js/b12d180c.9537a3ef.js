"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3410],{21936:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"skills/dag_capability_ranker/index","title":"\ud83d\udce6 Dag Capability Ranker","description":"Ranks skill matches by fit, performance history, and contextual relevance. Applies multi-factor scoring including success rate, resource usage, and task alignment. Activate on \'rank skills\', \'best skill for\', \'skill ranking\', \'compare skills\', \'optimal skill\'. NOT for semantic matching (use dag-semantic-matcher) or skill catalog (use dag-skill-registry).","source":"@site/docs/skills/dag_capability_ranker/index.md","sourceDirName":"skills/dag_capability_ranker","slug":"/skills/dag_capability_ranker/","permalink":"/docs/skills/dag_capability_ranker/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Capability Ranker","sidebar_position":1}}');var s=i(74848),a=i(28453);const c={sidebar_label:"Dag Capability Ranker",sidebar_position:1},r="\ud83d\udce6 Dag Capability Ranker",o={},l=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Multi-Factor Scoring",id:"1-multi-factor-scoring",level:3},{value:"2. Historical Analysis",id:"2-historical-analysis",level:3},{value:"3. Contextual Ranking",id:"3-contextual-ranking",level:3},{value:"4. Recommendation Generation",id:"4-recommendation-generation",level:3},{value:"Ranking Algorithm",id:"ranking-algorithm",level:2},{value:"Factor Calculation",id:"factor-calculation",level:2},{value:"Weight Determination",id:"weight-determination",level:2},{value:"Final Score Computation",id:"final-score-computation",level:2},{value:"Ranking Explanation",id:"ranking-explanation",level:2},{value:"Output Format",id:"output-format",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"-dag-capability-ranker",children:"\ud83d\udce6 Dag Capability Ranker"})}),"\n",(0,s.jsx)(e.p,{children:"Ranks skill matches by fit, performance history, and contextual relevance. Applies multi-factor scoring including success rate, resource usage, and task alignment. Activate on 'rank skills', 'best skill for', 'skill ranking', 'compare skills', 'optimal skill'. NOT for semantic matching (use dag-semantic-matcher) or skill catalog (use dag-skill-registry)."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,s.jsx)(e.h2,{id:"tags",children:"Tags"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"dag"})," ",(0,s.jsx)(e.code,{children:"registry"})," ",(0,s.jsx)(e.code,{children:"ranking"})," ",(0,s.jsx)(e.code,{children:"scoring"})," ",(0,s.jsx)(e.code,{children:"optimization"})]}),"\n",(0,s.jsx)(e.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"/docs/skills/dag_semantic_matcher",children:"Dag Semantic Matcher"})}),": Ranks matches from semantic search"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"/docs/skills/dag_skill_registry",children:"Dag Skill Registry"})}),": Uses performance data for ranking"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"/docs/skills/dag_graph_builder",children:"Dag Graph Builder"})}),": Provides ranked recommendations"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"You are a DAG Capability Ranker, an expert at ranking skill candidates based on multiple factors. You consider semantic match quality, historical performance, resource efficiency, and contextual fit to recommend the optimal skill for each task."}),"\n",(0,s.jsx)(e.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,s.jsx)(e.h3,{id:"1-multi-factor-scoring",children:"1. Multi-Factor Scoring"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Combine semantic match scores with performance data"}),"\n",(0,s.jsx)(e.li,{children:"Weight factors based on task requirements"}),"\n",(0,s.jsx)(e.li,{children:"Normalize scores for fair comparison"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"2-historical-analysis",children:"2. Historical Analysis"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Consider past success rates"}),"\n",(0,s.jsx)(e.li,{children:"Factor in average execution times"}),"\n",(0,s.jsx)(e.li,{children:"Account for resource usage patterns"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"3-contextual-ranking",children:"3. Contextual Ranking"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Adjust rankings based on current context"}),"\n",(0,s.jsx)(e.li,{children:"Consider skill pairings and synergies"}),"\n",(0,s.jsx)(e.li,{children:"Account for resource constraints"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"4-recommendation-generation",children:"4. Recommendation Generation"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Provide ranked recommendations"}),"\n",(0,s.jsx)(e.li,{children:"Explain ranking rationale"}),"\n",(0,s.jsx)(e.li,{children:"Suggest alternatives for edge cases"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"ranking-algorithm",children:"Ranking Algorithm"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface RankingFactors {\n  semanticScore: number;      // From semantic matcher (0-1)\n  successRate: number;        // Historical success (0-1)\n  efficiency: number;         // Tokens/time efficiency (0-1)\n  contextFit: number;         // Fit with current context (0-1)\n  pairingBonus: number;       // Bonus for good pairings (0-0.2)\n}\n\ninterface RankingWeights {\n  semantic: number;\n  success: number;\n  efficiency: number;\n  context: number;\n}\n\ninterface RankedSkill {\n  skillId: string;\n  rank: number;\n  finalScore: number;\n  factors: RankingFactors;\n  explanation: string;\n}\n\nfunction rankSkills(\n  candidates: MatchResult[],\n  registry: SkillRegistry,\n  context: RankingContext\n): RankedSkill[] {\n  const weights = determineWeights(context);\n\n  const scored = candidates.map(match => {\n    const skill = registry.skills.get(match.skillId);\n    const factors = calculateFactors(match, skill, context);\n    const finalScore = computeFinalScore(factors, weights);\n\n    return {\n      skillId: match.skillId,\n      rank: 0, // Set after sorting\n      finalScore,\n      factors,\n      explanation: generateRankingExplanation(factors, weights),\n    };\n  });\n\n  // Sort by final score descending\n  scored.sort((a, b) => b.finalScore - a.finalScore);\n\n  // Assign ranks\n  scored.forEach((item, index) => {\n    item.rank = index + 1;\n  });\n\n  return scored;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"factor-calculation",children:"Factor Calculation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"function calculateFactors(\n  match: MatchResult,\n  skill: SkillMetadata,\n  context: RankingContext\n): RankingFactors {\n  return {\n    semanticScore: match.score,\n    successRate: calculateSuccessRate(skill),\n    efficiency: calculateEfficiency(skill, context),\n    contextFit: calculateContextFit(skill, context),\n    pairingBonus: calculatePairingBonus(skill, context),\n  };\n}\n\nfunction calculateSuccessRate(skill: SkillMetadata): number {\n  const stats = skill.stats;\n\n  // Need minimum executions for confidence\n  if (stats.totalExecutions < 10) {\n    return 0.5; // Neutral score for new skills\n  }\n\n  // Apply confidence interval based on sample size\n  const confidence = Math.min(stats.totalExecutions / 100, 1);\n  const adjusted = stats.successRate * confidence + 0.7 * (1 - confidence);\n\n  return adjusted;\n}\n\nfunction calculateEfficiency(\n  skill: SkillMetadata,\n  context: RankingContext\n): number {\n  const stats = skill.stats;\n\n  // Token efficiency\n  const maxTokens = context.tokenBudget ?? 10000;\n  const tokenScore = 1 - Math.min(stats.averageTokens / maxTokens, 1);\n\n  // Time efficiency\n  const maxTime = context.timeoutMs ?? 60000;\n  const timeScore = 1 - Math.min(stats.averageDuration / maxTime, 1);\n\n  // Combined efficiency (weighted average)\n  return tokenScore * 0.6 + timeScore * 0.4;\n}\n\nfunction calculateContextFit(\n  skill: SkillMetadata,\n  context: RankingContext\n): number {\n  let score = 0.5; // Baseline\n\n  // Check if skill category matches task domain\n  if (context.domain && skill.category.toLowerCase().includes(context.domain)) {\n    score += 0.2;\n  }\n\n  // Check required tools availability\n  const availableTools = new Set(context.availableTools ?? []);\n  const requiredTools = skill.allowedTools;\n  const toolsAvailable = requiredTools.every(t => availableTools.has(t));\n  if (toolsAvailable) {\n    score += 0.2;\n  }\n\n  // Check recent successful use in similar context\n  if (context.previousSuccesses?.includes(skill.id)) {\n    score += 0.1;\n  }\n\n  return Math.min(score, 1);\n}\n\nfunction calculatePairingBonus(\n  skill: SkillMetadata,\n  context: RankingContext\n): number {\n  let bonus = 0;\n\n  const alreadySelected = context.selectedSkills ?? [];\n\n  for (const pairing of skill.pairsWith) {\n    if (alreadySelected.includes(pairing.skillId)) {\n      switch (pairing.strength) {\n        case 'required':\n          bonus += 0.2;\n          break;\n        case 'recommended':\n          bonus += 0.1;\n          break;\n        case 'optional':\n          bonus += 0.05;\n          break;\n      }\n    }\n  }\n\n  return Math.min(bonus, 0.2);\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"weight-determination",children:"Weight Determination"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"function determineWeights(context: RankingContext): RankingWeights {\n  // Default weights\n  const weights: RankingWeights = {\n    semantic: 0.4,\n    success: 0.3,\n    efficiency: 0.2,\n    context: 0.1,\n  };\n\n  // Adjust based on context priorities\n  if (context.priority === 'reliability') {\n    weights.success = 0.5;\n    weights.semantic = 0.3;\n    weights.efficiency = 0.1;\n  } else if (context.priority === 'speed') {\n    weights.efficiency = 0.4;\n    weights.semantic = 0.3;\n    weights.success = 0.2;\n  } else if (context.priority === 'accuracy') {\n    weights.semantic = 0.5;\n    weights.success = 0.3;\n    weights.efficiency = 0.1;\n  }\n\n  // Normalize weights to sum to 1\n  const total = Object.values(weights).reduce((a, b) => a + b, 0);\n  for (const key of Object.keys(weights) as (keyof RankingWeights)[]) {\n    weights[key] /= total;\n  }\n\n  return weights;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"final-score-computation",children:"Final Score Computation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"function computeFinalScore(\n  factors: RankingFactors,\n  weights: RankingWeights\n): number {\n  const baseScore = (\n    factors.semanticScore * weights.semantic +\n    factors.successRate * weights.success +\n    factors.efficiency * weights.efficiency +\n    factors.contextFit * weights.context\n  );\n\n  // Apply pairing bonus\n  return Math.min(baseScore + factors.pairingBonus, 1);\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"ranking-explanation",children:"Ranking Explanation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"function generateRankingExplanation(\n  factors: RankingFactors,\n  weights: RankingWeights\n): string {\n  const contributions = [\n    {\n      factor: 'Semantic match',\n      score: factors.semanticScore,\n      weight: weights.semantic,\n      contribution: factors.semanticScore * weights.semantic,\n    },\n    {\n      factor: 'Success history',\n      score: factors.successRate,\n      weight: weights.success,\n      contribution: factors.successRate * weights.success,\n    },\n    {\n      factor: 'Efficiency',\n      score: factors.efficiency,\n      weight: weights.efficiency,\n      contribution: factors.efficiency * weights.efficiency,\n    },\n    {\n      factor: 'Context fit',\n      score: factors.contextFit,\n      weight: weights.context,\n      contribution: factors.contextFit * weights.context,\n    },\n  ];\n\n  // Sort by contribution\n  contributions.sort((a, b) => b.contribution - a.contribution);\n\n  // Build explanation\n  const topFactors = contributions.slice(0, 2);\n  const parts = topFactors.map(f =>\n    `${f.factor}: ${(f.score * 100).toFixed(0)}%`\n  );\n\n  let explanation = `Ranked by: ${parts.join(', ')}`;\n\n  if (factors.pairingBonus > 0) {\n    explanation += ` (+${(factors.pairingBonus * 100).toFixed(0)}% pairing bonus)`;\n  }\n\n  return explanation;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"output-format",children:"Output Format"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:'rankingResults:\n  query: "Review TypeScript code for bugs"\n  context:\n    priority: reliability\n    domain: code\n    tokenBudget: 5000\n\n  weights:\n    semantic: 0.30\n    success: 0.50\n    efficiency: 0.10\n    context: 0.10\n\n  rankings:\n    - rank: 1\n      skillId: code-reviewer\n      finalScore: 0.89\n      factors:\n        semanticScore: 0.92\n        successRate: 0.94\n        efficiency: 0.75\n        contextFit: 0.80\n        pairingBonus: 0.05\n      explanation: "Ranked by: Success history: 94%, Semantic match: 92% (+5% pairing bonus)"\n\n    - rank: 2\n      skillId: typescript-expert\n      finalScore: 0.78\n      factors:\n        semanticScore: 0.80\n        successRate: 0.88\n        efficiency: 0.70\n        contextFit: 0.75\n        pairingBonus: 0\n      explanation: "Ranked by: Success history: 88%, Semantic match: 80%"\n\n    - rank: 3\n      skillId: security-auditor\n      finalScore: 0.72\n      factors:\n        semanticScore: 0.78\n        successRate: 0.82\n        efficiency: 0.60\n        contextFit: 0.65\n        pairingBonus: 0\n      explanation: "Ranked by: Success history: 82%, Semantic match: 78%"\n\n  recommendation:\n    primary: code-reviewer\n    alternatives: [typescript-expert, security-auditor]\n    confidence: 0.85\n'})}),"\n",(0,s.jsx)(e.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Input"}),": Candidates from ",(0,s.jsx)(e.code,{children:"dag-semantic-matcher"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Data"}),": Performance stats from ",(0,s.jsx)(e.code,{children:"dag-skill-registry"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Output"}),": Ranked recommendations for ",(0,s.jsx)(e.code,{children:"dag-graph-builder"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Learning"}),": Feedback to ",(0,s.jsx)(e.code,{children:"dag-pattern-learner"})]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance Factors"}),": Don't over-weight any single factor"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Require History"}),": Be cautious with new skills"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Explain Rankings"}),": Transparency builds trust"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Learn from Outcomes"}),": Adjust weights based on results"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consider Context"}),": What works in one context may not in another"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.p,{children:"Multi-factor ranking. Optimal selection. Data-driven decisions."})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>c,x:()=>r});var t=i(96540);const s={},a=t.createContext(s);function c(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:c(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);