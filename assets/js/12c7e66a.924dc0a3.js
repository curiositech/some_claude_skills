"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8826],{8007:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"skills/mcp_creator/references/architecture-patterns","title":"MCP Architecture Patterns","description":"Transport Layers","source":"@site/docs/skills/mcp_creator/references/architecture-patterns.md","sourceDirName":"skills/mcp_creator/references","slug":"/skills/mcp_creator/references/architecture-patterns","permalink":"/docs/skills/mcp_creator/references/architecture-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"MCP Architecture Patterns","sidebar_label":"MCP Architecture Patterns","sidebar_position":1}}');var t=s(74848),i=s(28453);const a={title:"MCP Architecture Patterns",sidebar_label:"MCP Architecture Patterns",sidebar_position:1},o="MCP Architecture Patterns",c={},l=[{value:"Transport Layers",id:"transport-layers",level:2},{value:"Stdio Transport (Recommended for CLI)",id:"stdio-transport-recommended-for-cli",level:3},{value:"SSE Transport (HTTP)",id:"sse-transport-http",level:3},{value:"Custom Transport",id:"custom-transport",level:3},{value:"Server Lifecycle",id:"server-lifecycle",level:2},{value:"Initialization Pattern",id:"initialization-pattern",level:3},{value:"Health Check Pattern",id:"health-check-pattern",level:3},{value:"Resource Management",id:"resource-management",level:2},{value:"Connection Pool Pattern",id:"connection-pool-pattern",level:3},{value:"Resource Cleanup Pattern",id:"resource-cleanup-pattern",level:3},{value:"State Management",id:"state-management",level:2},{value:"Stateless Design (Preferred)",id:"stateless-design-preferred",level:3},{value:"Stateful Design (When Necessary)",id:"stateful-design-when-necessary",level:3},{value:"Capabilities Declaration",id:"capabilities-declaration",level:2},{value:"Tools Capability",id:"tools-capability",level:3},{value:"Resources Capability",id:"resources-capability",level:3},{value:"Prompts Capability",id:"prompts-capability",level:3},{value:"Multi-Server Coordination",id:"multi-server-coordination",level:2},{value:"Shared Configuration",id:"shared-configuration",level:3},{value:"Service Registry Pattern",id:"service-registry-pattern",level:3},{value:"Logging Best Practices",id:"logging-best-practices",level:2},{value:"Structured Logging",id:"structured-logging",level:3},{value:"Audit Logging",id:"audit-logging",level:3},{value:"Versioning Strategy",id:"versioning-strategy",level:2},{value:"Semantic Versioning",id:"semantic-versioning",level:3},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"mcp-architecture-patterns",children:"MCP Architecture Patterns"})}),"\n",(0,t.jsx)(n.h2,{id:"transport-layers",children:"Transport Layers"}),"\n",(0,t.jsx)(n.h3,{id:"stdio-transport-recommended-for-cli",children:"Stdio Transport (Recommended for CLI)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";\n\n// Best for: CLI tools, local development, Claude Code integration\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros"}),": Simple, no network config, secure (process-level isolation)\n",(0,t.jsx)(n.strong,{children:"Cons"}),": Single client, no remote access"]}),"\n",(0,t.jsx)(n.h3,{id:"sse-transport-http",children:"SSE Transport (HTTP)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";\nimport express from "express";\n\nconst app = express();\napp.use("/sse", async (req, res) => {\n  const transport = new SSEServerTransport("/messages", res);\n  await server.connect(transport);\n});\napp.listen(3000);\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros"}),": Multiple clients, remote access, browser-compatible\n",(0,t.jsx)(n.strong,{children:"Cons"}),": More complex, requires HTTP server"]}),"\n",(0,t.jsx)(n.h3,{id:"custom-transport",children:"Custom Transport"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class CustomTransport implements Transport {\n  async start(): Promise<void> { /* Initialize connection */ }\n  async close(): Promise<void> { /* Cleanup */ }\n  async send(message: JSONRPCMessage): Promise<void> { /* Send message */ }\n  onMessage?: (message: JSONRPCMessage) => void;\n  onError?: (error: Error) => void;\n  onClose?: () => void;\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"server-lifecycle",children:"Server Lifecycle"}),"\n",(0,t.jsx)(n.h3,{id:"initialization-pattern",children:"Initialization Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'class MCPServer {\n  private pool: Pool | null = null;\n  private cache: Cache | null = null;\n\n  async initialize(): Promise<void> {\n    // 1. Validate configuration\n    this.validateConfig();\n\n    // 2. Initialize connections (parallel)\n    const [pool, cache] = await Promise.all([\n      this.initDatabase(),\n      this.initCache(),\n    ]);\n\n    this.pool = pool;\n    this.cache = cache;\n\n    // 3. Warm caches if needed\n    await this.warmCaches();\n\n    // 4. Register signal handlers\n    this.registerShutdownHandlers();\n  }\n\n  private registerShutdownHandlers(): void {\n    const shutdown = async () => {\n      console.error("Shutting down...");\n      await this.pool?.end();\n      await this.cache?.quit();\n      process.exit(0);\n    };\n\n    process.on("SIGTERM", shutdown);\n    process.on("SIGINT", shutdown);\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"health-check-pattern",children:"Health Check Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'server.setRequestHandler(ListToolsRequestSchema, async () => ({\n  tools: [\n    {\n      name: "health_check",\n      description: "Check server health and dependencies",\n      inputSchema: { type: "object", properties: {} },\n    },\n    // ... other tools\n  ],\n}));\n\nasync function healthCheck(): Promise<HealthStatus> {\n  const checks = await Promise.allSettled([\n    checkDatabase(),\n    checkCache(),\n    checkExternalApi(),\n  ]);\n\n  return {\n    status: checks.every(c => c.status === "fulfilled") ? "healthy" : "degraded",\n    checks: {\n      database: checks[0].status === "fulfilled" ? "ok" : "failed",\n      cache: checks[1].status === "fulfilled" ? "ok" : "failed",\n      externalApi: checks[2].status === "fulfilled" ? "ok" : "failed",\n    },\n    timestamp: new Date().toISOString(),\n  };\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"resource-management",children:"Resource Management"}),"\n",(0,t.jsx)(n.h3,{id:"connection-pool-pattern",children:"Connection Pool Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Pool, PoolConfig } from "pg";\n\nconst poolConfig: PoolConfig = {\n  connectionString: process.env.DATABASE_URL,\n  max: 20,                        // Max connections\n  idleTimeoutMillis: 30000,       // Close idle connections after 30s\n  connectionTimeoutMillis: 2000,  // Fail fast if can\'t connect\n  statement_timeout: 30000,       // Kill queries after 30s\n};\n\nconst pool = new Pool(poolConfig);\n\n// Monitor pool health\npool.on("error", (err) => {\n  console.error("Unexpected pool error:", err);\n});\n\npool.on("connect", () => {\n  console.error("New client connected to pool");\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"resource-cleanup-pattern",children:"Resource Cleanup Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'class ResourceManager {\n  private resources: Set<Disposable> = new Set();\n\n  register<T extends Disposable>(resource: T): T {\n    this.resources.add(resource);\n    return resource;\n  }\n\n  async disposeAll(): Promise<void> {\n    const errors: Error[] = [];\n\n    for (const resource of this.resources) {\n      try {\n        await resource.dispose();\n      } catch (error) {\n        errors.push(error as Error);\n      }\n    }\n\n    this.resources.clear();\n\n    if (errors.length > 0) {\n      throw new AggregateError(errors, "Resource disposal failed");\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"state-management",children:"State Management"}),"\n",(0,t.jsx)(n.h3,{id:"stateless-design-preferred",children:"Stateless Design (Preferred)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Each request is self-contained\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  // Get state from request or external store\n  const session = await getSession(request.params.sessionId);\n\n  // Process\n  const result = await processWithSession(session, request.params);\n\n  // Persist state externally\n  await saveSession(session);\n\n  return result;\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"stateful-design-when-necessary",children:"Stateful Design (When Necessary)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// For WebSockets, long-running connections\nclass StatefulServer {\n  private sessions: Map<string, Session> = new Map();\n\n  async handleConnection(clientId: string): Promise<Session> {\n    const session = new Session(clientId);\n    this.sessions.set(clientId, session);\n\n    // Set TTL for cleanup\n    setTimeout(() => this.cleanup(clientId), 3600000); // 1 hour\n\n    return session;\n  }\n\n  private cleanup(clientId: string): void {\n    const session = this.sessions.get(clientId);\n    if (session?.isExpired()) {\n      session.dispose();\n      this.sessions.delete(clientId);\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"capabilities-declaration",children:"Capabilities Declaration"}),"\n",(0,t.jsx)(n.h3,{id:"tools-capability",children:"Tools Capability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const server = new Server(\n  { name: "my-server", version: "1.0.0" },\n  {\n    capabilities: {\n      tools: {},  // Enable tools\n    },\n  }\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"resources-capability",children:"Resources Capability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const server = new Server(\n  { name: "my-server", version: "1.0.0" },\n  {\n    capabilities: {\n      resources: {\n        subscribe: true,  // Enable resource subscriptions\n      },\n    },\n  }\n);\n\n// Define resources\nserver.setRequestHandler(ListResourcesRequestSchema, async () => ({\n  resources: [\n    {\n      uri: "config://settings",\n      name: "Server Settings",\n      description: "Current server configuration",\n      mimeType: "application/json",\n    },\n  ],\n}));\n\n// Read resource\nserver.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n  if (request.params.uri === "config://settings") {\n    return {\n      contents: [{\n        uri: request.params.uri,\n        mimeType: "application/json",\n        text: JSON.stringify(getConfig()),\n      }],\n    };\n  }\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"prompts-capability",children:"Prompts Capability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const server = new Server(\n  { name: "my-server", version: "1.0.0" },\n  {\n    capabilities: {\n      prompts: {},  // Enable prompts\n    },\n  }\n);\n\nserver.setRequestHandler(ListPromptsRequestSchema, async () => ({\n  prompts: [\n    {\n      name: "analyze_code",\n      description: "Analyze code for issues",\n      arguments: [\n        { name: "code", description: "Code to analyze", required: true },\n        { name: "language", description: "Programming language" },\n      ],\n    },\n  ],\n}));\n'})}),"\n",(0,t.jsx)(n.h2,{id:"multi-server-coordination",children:"Multi-Server Coordination"}),"\n",(0,t.jsx)(n.h3,{id:"shared-configuration",children:"Shared Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// config.ts - Shared across servers\nexport const CONFIG = {\n  database: {\n    host: process.env.DB_HOST,\n    port: parseInt(process.env.DB_PORT || "5432"),\n    database: process.env.DB_NAME,\n  },\n  redis: {\n    url: process.env.REDIS_URL,\n  },\n  rateLimit: {\n    requestsPerMinute: 100,\n    burstSize: 20,\n  },\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"service-registry-pattern",children:"Service Registry Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// For discovering other MCP servers\nclass ServiceRegistry {\n  private services: Map<string, ServiceInfo> = new Map();\n\n  register(name: string, info: ServiceInfo): void {\n    this.services.set(name, info);\n  }\n\n  discover(name: string): ServiceInfo | undefined {\n    return this.services.get(name);\n  }\n\n  async healthCheckAll(): Promise<Record<string, boolean>> {\n    const results: Record<string, boolean> = {};\n\n    for (const [name, info] of this.services) {\n      try {\n        const response = await fetch(`${info.url}/health`);\n        results[name] = response.ok;\n      } catch {\n        results[name] = false;\n      }\n    }\n\n    return results;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"logging-best-practices",children:"Logging Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"structured-logging",children:"Structured Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import pino from "pino";\n\nconst logger = pino({\n  level: process.env.LOG_LEVEL || "info",\n  formatters: {\n    level: (label) => ({ level: label }),\n  },\n  timestamp: pino.stdTimeFunctions.isoTime,\n});\n\n// In handlers\nlogger.info({ tool: "my_tool", args: sanitizedArgs }, "Tool invoked");\nlogger.error({ err, tool: "my_tool" }, "Tool failed");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"audit-logging",children:"Audit Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'interface AuditLog {\n  timestamp: string;\n  tool: string;\n  userId?: string;\n  args: Record<string, unknown>;\n  result: "success" | "failure";\n  duration: number;\n  errorCode?: string;\n}\n\nasync function auditLog(entry: AuditLog): Promise<void> {\n  // To file, database, or external service\n  await appendToAuditLog(entry);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"versioning-strategy",children:"Versioning Strategy"}),"\n",(0,t.jsx)(n.h3,{id:"semantic-versioning",children:"Semantic Versioning"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const server = new Server(\n  {\n    name: "my-server",\n    version: "2.1.0",  // MAJOR.MINOR.PATCH\n  },\n  { capabilities: { tools: {} } }\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"backwards-compatibility",children:"Backwards Compatibility"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Support old and new parameter names\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const args = request.params.arguments;\n\n  // Support both old and new field names\n  const userId = args.userId || args.user_id;  // New or legacy\n\n  // Deprecation warning\n  if (args.user_id) {\n    console.warn("user_id is deprecated, use userId");\n  }\n});\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(96540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);