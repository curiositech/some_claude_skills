"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[60473],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(96540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},32125:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"skills/physics_rendering_expert/references/tangle-physics","title":"Tangle Physics","description":"Multi-rope collision, Capstan friction, and dynamic constraint creation.","source":"@site/docs/skills/physics_rendering_expert/references/tangle-physics.md","sourceDirName":"skills/physics_rendering_expert/references","slug":"/skills/physics_rendering_expert/references/tangle-physics","permalink":"/docs/skills/physics_rendering_expert/references/tangle-physics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Tangle Physics","sidebar_label":"Tangle Physics","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Knot Garden Physics","permalink":"/docs/skills/physics_rendering_expert/references/knot-garden-physics"},"next":{"title":"Collage Layout Expert","permalink":"/docs/skills/collage_layout_expert/"}}');var s=i(74848),a=i(28453);const r={title:"Tangle Physics",sidebar_label:"Tangle Physics",sidebar_position:4},l="Tangle Physics",o={},c=[{value:"Critical Insight",id:"critical-insight",level:2},{value:"Segment-Segment Distance",id:"segment-segment-distance",level:2},{value:"TangleConstraint: Dynamic Constraint Creation",id:"tangleconstraint-dynamic-constraint-creation",level:2},{value:"Capstan Equation",id:"capstan-equation",level:2},{value:"Tangle Formation Detection",id:"tangle-formation-detection",level:2},{value:"Tangle Lifecycle",id:"tangle-lifecycle",level:2},{value:"Tangle Decision Tree",id:"tangle-decision-tree",level:2},{value:"Anti-Patterns",id:"anti-patterns",level:2},{value:"Detection Without Physics",id:"detection-without-physics",level:3},{value:"Treating All Crossings as Tangles",id:"treating-all-crossings-as-tangles",level:3},{value:"Capsule Collision for Tangle Physics",id:"capsule-collision-for-tangle-physics",level:3},{value:"Ignoring Directional Friction",id:"ignoring-directional-friction",level:3},{value:"Immediate Lock on Contact",id:"immediate-lock-on-contact",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tangle-physics",children:"Tangle Physics"})}),"\n",(0,s.jsx)(n.p,{children:"Multi-rope collision, Capstan friction, and dynamic constraint creation."}),"\n",(0,s.jsx)(n.h2,{id:"critical-insight",children:"Critical Insight"}),"\n",(0,s.jsx)(n.p,{children:"Tangle DETECTION is not tangle PHYSICS. Detecting crossings for braid words is different from simulating the physical constraint that forms when ropes interlock."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Detection only"}),": Ropes pass through each other, we just record the event\n",(0,s.jsx)(n.strong,{children:"Physical tangle"}),": Ropes cannot pass through; crossing creates a new constraint point"]}),"\n",(0,s.jsx)(n.h2,{id:"segment-segment-distance",children:"Segment-Segment Distance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"float segment_distance(vec3 p1, vec3 p2, vec3 q1, vec3 q2) {\n    vec3 u = p2 - p1, v = q2 - q1, w = p1 - q1;\n    float a = dot(u,u), b = dot(u,v), c = dot(v,v);\n    float d = dot(u,w), e = dot(v,w);\n    float denom = a*c - b*b;\n\n    float s = clamp((b*e - c*d) / denom, 0, 1);\n    float t = clamp((a*e - b*d) / denom, 0, 1);\n\n    return length((q1 + t*v) - (p1 + s*u));\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tangleconstraint-dynamic-constraint-creation",children:"TangleConstraint: Dynamic Constraint Creation"}),"\n",(0,s.jsx)(n.p,{children:"When a physical tangle forms, create a constraint between closest particles:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class TangleConstraint {\n    Particle* p1;           // Closest particle on rope A\n    Particle* p2;           // Closest particle on rope B\n    float rest_distance;    // Distance at formation (typically rope_diameter)\n    float friction;         // Capstan friction coefficient\n    float wrap_angle;       // Accumulated wrap (affects friction)\n    bool is_locked;         // Has tightened past threshold\n\n    void solve() {\n        vec3 delta = p2->predicted - p1->predicted;\n        float dist = length(delta);\n\n        float effective_rest = is_locked ?\n            rest_distance * 0.5f :  // Tightened\n            rest_distance;          // Initial\n\n        if (dist < effective_rest) return; // Don't push apart\n\n        float error = dist - effective_rest;\n        float w_sum = p1->inverse_mass + p2->inverse_mass;\n\n        // Apply friction-scaled correction (Capstan effect)\n        float friction_factor = exp(friction * wrap_angle);\n        vec3 correction = (error / (dist * w_sum)) * delta;\n        correction *= min(friction_factor, 3.0f); // Cap for stability\n\n        p1->predicted += p1->inverse_mass * correction;\n        p2->predicted -= p2->inverse_mass * correction;\n    }\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"capstan-equation",children:"Capstan Equation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"T2 = T1 x e^(mu*theta)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"T1"})," = tension on one side"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"T2"})," = tension on other side (amplified by wrap)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mu"})," = friction coefficient (0.3-0.8 for rope on rope)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"theta"})," = wrap angle in radians"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implication"}),": 90\xb0 wrap with mu=0.5 gives 2.2x amplification. 360\xb0 wrap gives 23x. This is why knots tighten!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"float capstan_friction(float tension_in, float wrap_angle, float mu = 0.5f) {\n    return tension_in * exp(mu * wrap_angle);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tangle-formation-detection",children:"Tangle Formation Detection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"TangleCandidate check_tangle_formation(\n    Particle& a1, Particle& a2,  // Segment A\n    Particle& b1, Particle& b2,  // Segment B\n    float rope_diameter\n) {\n    auto [closest_a, closest_b, dist] = segment_closest_points(a1, a2, b1, b2);\n\n    if (dist > rope_diameter) return {.forms_physical_tangle = false};\n\n    // Check if tension would tighten (not just touch and separate)\n    vec3 tension_a = (a2.predicted - a1.predicted).normalized();\n    vec3 tension_b = (b2.predicted - b1.predicted).normalized();\n    vec3 separation = (closest_b - closest_a).normalized();\n\n    float pull_a = dot(tension_a, separation);\n    float pull_b = dot(tension_b, -separation);\n\n    bool would_tighten = (pull_a > 0.3f) || (pull_b > 0.3f);\n    float wrap_angle = acos(clamp(dot(tension_a, tension_b), -1.0f, 1.0f));\n\n    return {\n        .crossing_point = (closest_a + closest_b) * 0.5f,\n        .wrap_angle = wrap_angle,\n        .forms_physical_tangle = would_tighten && wrap_angle > 0.5f // ~30 degrees\n    };\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tangle-lifecycle",children:"Tangle Lifecycle"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Detection"}),": Segment distance < threshold"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Formation"}),": Tension + geometry = physical constraint created"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tightening"}),": Under continued tension, rest_distance decreases"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Locking"}),': Past threshold, tangle becomes "locked"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Breaking"}),": Extreme force OR deliberate untangling action"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"tangle-decision-tree",children:"Tangle Decision Tree"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Should this crossing become a TangleConstraint?"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Distance < rope_diameter? -> Continue"}),"\n",(0,s.jsx)(n.li,{children:"Already have a TangleConstraint for this pair? -> Skip (update existing)"}),"\n",(0,s.jsx)(n.li,{children:"Would tension tighten (not separate) the ropes? -> Continue"}),"\n",(0,s.jsxs)(n.li,{children:["Wrap angle > 30 degrees? -> ",(0,s.jsx)(n.strong,{children:"Create TangleConstraint"})]}),"\n",(0,s.jsx)(n.li,{children:"Otherwise -> Ignore (transient contact)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to break a TangleConstraint?"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Distance > 2x rest_distance for sustained period -> Break"}),"\n",(0,s.jsx)(n.li,{children:'External "untangle" action triggered -> Break'}),"\n",(0,s.jsx)(n.li,{children:"is_locked == true -> Much harder to break"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"anti-patterns",children:"Anti-Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"detection-without-physics",children:"Detection Without Physics"}),"\n",(0,s.jsx)(n.p,{children:"Recording braid words but ropes pass through each other. Create TangleConstraints when crossings form."}),"\n",(0,s.jsx)(n.h3,{id:"treating-all-crossings-as-tangles",children:"Treating All Crossings as Tangles"}),"\n",(0,s.jsx)(n.p,{children:"Every segment intersection creates a constraint. Check tension direction and wrap angle first."}),"\n",(0,s.jsx)(n.h3,{id:"capsule-collision-for-tangle-physics",children:"Capsule Collision for Tangle Physics"}),"\n",(0,s.jsx)(n.p,{children:"Causes instability and tunneling. Use point-based collision with adaptive particle placement."}),"\n",(0,s.jsx)(n.h3,{id:"ignoring-directional-friction",children:"Ignoring Directional Friction"}),"\n",(0,s.jsx)(n.p,{children:"Symmetric friction feels wrong. Apply Capstan equation with wrap angle."}),"\n",(0,s.jsx)(n.h3,{id:"immediate-lock-on-contact",children:"Immediate Lock on Contact"}),"\n",(0,s.jsx)(n.p,{children:"Real tangles form gradually under tension. Use gradual tightening over time."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);