"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[73469],{27249:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"skills/physics_rendering_expert/references/implementations","title":"Physics Implementation Reference","description":"Detailed code implementations for rope/cable physics simulation.","source":"@site/docs/skills/physics_rendering_expert/references/implementations.md","sourceDirName":"skills/physics_rendering_expert/references","slug":"/skills/physics_rendering_expert/references/implementations","permalink":"/docs/skills/physics_rendering_expert/references/implementations","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Physics Implementation Reference","sidebar_label":"Physics Implementation Refe...","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Core Physics Algorithms","permalink":"/docs/skills/physics_rendering_expert/references/core-algorithms"},"next":{"title":"Knot Garden Physics","permalink":"/docs/skills/physics_rendering_expert/references/knot-garden-physics"}}');var s=t(74848),a=t(28453);const r={title:"Physics Implementation Reference",sidebar_label:"Physics Implementation Refe...",sidebar_position:2},o="Physics Implementation Reference",l={},c=[{value:"Complete PBD Rope Implementation",id:"complete-pbd-rope-implementation",level:2},{value:"Quaternion Implementation",id:"quaternion-implementation",level:2},{value:"Dual Quaternion (Rotation + Translation)",id:"dual-quaternion-rotation--translation",level:2},{value:"Three-Dog Leash Tangle System",id:"three-dog-leash-tangle-system",level:2},{value:"Jacobi Solver (GPU-Parallel)",id:"jacobi-solver-gpu-parallel",level:2},{value:"TangleConstraint Implementation (JavaScript)",id:"tangleconstraint-implementation-javascript",level:2},{value:"Tangle Detection and Management",id:"tangle-detection-and-management",level:3},{value:"Capstan Friction Utility",id:"capstan-friction-utility",level:3},{value:"Performance Benchmarks",id:"performance-benchmarks",level:2},{value:"References",id:"references",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"physics-implementation-reference",children:"Physics Implementation Reference"})}),"\n",(0,s.jsx)(e.p,{children:"Detailed code implementations for rope/cable physics simulation."}),"\n",(0,s.jsx)(e.h2,{id:"complete-pbd-rope-implementation",children:"Complete PBD Rope Implementation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"#include <vector>\n#include <glm/glm.hpp>\n\nstruct Particle {\n    glm::vec3 position;\n    glm::vec3 predicted_position;\n    glm::vec3 velocity;\n    float mass;\n    float inverse_mass;  // Precomputed 1/mass (or 0 for static)\n\n    Particle(glm::vec3 pos, float m)\n        : position(pos), predicted_position(pos), velocity(0.0f), mass(m)\n    {\n        inverse_mass = (m > 0.0f) ? 1.0f / m : 0.0f;\n    }\n};\n\nclass RopeSimulation {\nprivate:\n    std::vector<Particle> particles;\n    std::vector<std::pair<int, int>> distance_constraints;\n    std::vector<float> rest_lengths;\n\n    float gravity = -9.81f;\n    float damping = 0.99f;\n    int solver_iterations = 5;\n\npublic:\n    RopeSimulation(glm::vec3 start, glm::vec3 end, int num_particles) {\n        for (int i = 0; i < num_particles; ++i) {\n            float t = static_cast<float>(i) / (num_particles - 1);\n            glm::vec3 pos = glm::mix(start, end, t);\n            particles.emplace_back(pos, 1.0f);\n\n            if (i == 0) particles[i].inverse_mass = 0.0f; // Fixed\n        }\n\n        for (int i = 0; i < num_particles - 1; ++i) {\n            distance_constraints.emplace_back(i, i + 1);\n            float length = glm::length(particles[i + 1].position - particles[i].position);\n            rest_lengths.push_back(length);\n        }\n    }\n\n    void update(float dt) {\n        // Step 1: Predict positions\n        for (auto& p : particles) {\n            if (p.inverse_mass == 0.0f) continue;\n            glm::vec3 acceleration(0.0f, gravity, 0.0f);\n            p.velocity += acceleration * dt;\n            p.velocity *= damping;\n            p.predicted_position = p.position + p.velocity * dt;\n        }\n\n        // Step 2: Solve constraints\n        for (int iter = 0; iter < solver_iterations; ++iter) {\n            solve_distance_constraints();\n            solve_collision_constraints();\n            solve_bending_constraints();\n        }\n\n        // Step 3: Update velocities and positions\n        for (auto& p : particles) {\n            if (p.inverse_mass == 0.0f) continue;\n            p.velocity = (p.predicted_position - p.position) / dt;\n            p.position = p.predicted_position;\n        }\n    }\n\n    void solve_distance_constraints() {\n        for (size_t i = 0; i < distance_constraints.size(); ++i) {\n            int idx1 = distance_constraints[i].first;\n            int idx2 = distance_constraints[i].second;\n            Particle& p1 = particles[idx1];\n            Particle& p2 = particles[idx2];\n\n            glm::vec3 delta = p2.predicted_position - p1.predicted_position;\n            float distance = glm::length(delta);\n            if (distance < 1e-6f) continue;\n\n            float constraint_error = distance - rest_lengths[i];\n            float w_sum = p1.inverse_mass + p2.inverse_mass;\n            if (w_sum < 1e-6f) continue;\n\n            glm::vec3 correction = (constraint_error / (distance * w_sum)) * delta;\n            p1.predicted_position += p1.inverse_mass * correction;\n            p2.predicted_position -= p2.inverse_mass * correction;\n        }\n    }\n\n    void solve_collision_constraints() {\n        float ground_y = 0.0f;\n        for (auto& p : particles) {\n            if (p.predicted_position.y < ground_y) {\n                p.predicted_position.y = ground_y;\n                p.velocity.y = 0.0f;\n                p.velocity.x *= 0.8f;\n                p.velocity.z *= 0.8f;\n            }\n        }\n    }\n\n    void solve_bending_constraints() {\n        for (size_t i = 1; i < particles.size() - 1; ++i) {\n            Particle& p_prev = particles[i - 1];\n            Particle& p_curr = particles[i];\n            Particle& p_next = particles[i + 1];\n\n            glm::vec3 v1 = p_curr.predicted_position - p_prev.predicted_position;\n            glm::vec3 v2 = p_next.predicted_position - p_curr.predicted_position;\n\n            float len1 = glm::length(v1);\n            float len2 = glm::length(v2);\n            if (len1 < 1e-6f || len2 < 1e-6f) continue;\n\n            glm::vec3 n1 = v1 / len1;\n            glm::vec3 n2 = v2 / len2;\n            float cos_angle = glm::dot(n1, n2);\n            float desired_cos = 0.5f;  // ~60 degrees max bend\n\n            if (cos_angle < desired_cos) {\n                glm::vec3 axis = glm::cross(n1, n2);\n                float axis_len = glm::length(axis);\n                if (axis_len > 1e-6f) {\n                    axis /= axis_len;\n                    p_curr.predicted_position += axis * 0.1f;\n                }\n            }\n        }\n    }\n\n    const std::vector<Particle>& get_particles() const { return particles; }\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"quaternion-implementation",children:"Quaternion Implementation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"struct Quaternion {\n    float x, y, z, w;\n\n    static Quaternion identity() { return {0.0f, 0.0f, 0.0f, 1.0f}; }\n\n    static Quaternion from_axis_angle(glm::vec3 axis, float angle) {\n        float half_angle = angle * 0.5f;\n        float s = std::sin(half_angle);\n        return {axis.x * s, axis.y * s, axis.z * s, std::cos(half_angle)};\n    }\n\n    Quaternion operator*(const Quaternion& q) const {\n        return {\n            w * q.x + x * q.w + y * q.z - z * q.y,\n            w * q.y - x * q.z + y * q.w + z * q.x,\n            w * q.z + x * q.y - y * q.x + z * q.w,\n            w * q.w - x * q.x - y * q.y - z * q.z\n        };\n    }\n\n    glm::vec3 rotate(glm::vec3 v) const {\n        Quaternion v_quat = {v.x, v.y, v.z, 0.0f};\n        Quaternion result = (*this) * v_quat * conjugate();\n        return {result.x, result.y, result.z};\n    }\n\n    Quaternion conjugate() const { return {-x, -y, -z, w}; }\n\n    void normalize() {\n        float len = std::sqrt(x*x + y*y + z*z + w*w);\n        x /= len; y /= len; z /= len; w /= len;\n    }\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"dual-quaternion-rotation--translation",children:"Dual Quaternion (Rotation + Translation)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"struct DualQuaternion {\n    Quaternion real;  // Rotation\n    Quaternion dual;  // Translation (encoded)\n\n    static DualQuaternion from_rotation_translation(Quaternion rotation, glm::vec3 translation) {\n        Quaternion t_quat = {translation.x, translation.y, translation.z, 0.0f};\n        Quaternion dual_part = (t_quat * rotation) * 0.5f;\n        return {rotation, dual_part};\n    }\n\n    glm::vec3 transform_point(glm::vec3 p) const {\n        Quaternion t_quat = (dual * 2.0f) * real.conjugate();\n        glm::vec3 translation = {t_quat.x, t_quat.y, t_quat.z};\n        return real.rotate(p) + translation;\n    }\n\n    static DualQuaternion blend(const std::vector<DualQuaternion>& dqs,\n                                 const std::vector<float>& weights) {\n        DualQuaternion result = {{0,0,0,0}, {0,0,0,0}};\n        for (size_t i = 0; i < dqs.size(); ++i) {\n            float sign = (i > 0 && dot(dqs[i].real, dqs[0].real) < 0) ? -1.0f : 1.0f;\n            result.real.x += weights[i] * sign * dqs[i].real.x;\n            result.real.y += weights[i] * sign * dqs[i].real.y;\n            result.real.z += weights[i] * sign * dqs[i].real.z;\n            result.real.w += weights[i] * sign * dqs[i].real.w;\n            result.dual.x += weights[i] * sign * dqs[i].dual.x;\n            result.dual.y += weights[i] * sign * dqs[i].dual.y;\n            result.dual.z += weights[i] * sign * dqs[i].dual.z;\n            result.dual.w += weights[i] * sign * dqs[i].dual.w;\n        }\n        result.real.normalize();\n        return result;\n    }\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"three-dog-leash-tangle-system",children:"Three-Dog Leash Tangle System"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"class ThreeDogLeashSystem {\nprivate:\n    struct Dog {\n        glm::vec3 position;\n        glm::vec3 velocity;\n        int leash_id;\n    };\n\n    std::vector<Dog> dogs;\n    std::vector<RopeSimulation> leashes;\n    glm::vec3 handler_position;\n\npublic:\n    ThreeDogLeashSystem() {\n        dogs.push_back({glm::vec3(-2, 0, 0), glm::vec3(0), 0});\n        dogs.push_back({glm::vec3(0, 0, 2), glm::vec3(0), 1});\n        dogs.push_back({glm::vec3(2, 0, 0), glm::vec3(0), 2});\n        handler_position = glm::vec3(0, 1.5f, 0);\n\n        for (int i = 0; i < 3; ++i) {\n            leashes.emplace_back(handler_position, dogs[i].position, 20);\n        }\n    }\n\n    void update(float dt) {\n        // Update dog behavior\n        for (auto& dog : dogs) {\n            glm::vec3 random_accel = glm::vec3(\n                random_range(-1.0f, 1.0f), 0.0f, random_range(-1.0f, 1.0f)\n            );\n            dog.velocity += random_accel * dt;\n            dog.velocity *= 0.95f;\n            dog.position += dog.velocity * dt;\n        }\n\n        // Update leashes\n        for (size_t i = 0; i < leashes.size(); ++i) {\n            leashes[i].particles[0].position = handler_position;\n            leashes[i].particles[0].inverse_mass = 0.0f;\n            int last_idx = leashes[i].particles.size() - 1;\n            leashes[i].particles[last_idx].position = dogs[i].position;\n            leashes[i].update(dt);\n        }\n\n        detect_leash_tangles();\n    }\n\n    void detect_leash_tangles() {\n        for (size_t i = 0; i < leashes.size(); ++i) {\n            for (size_t j = i + 1; j < leashes.size(); ++j) {\n                check_leash_collision(leashes[i], leashes[j]);\n            }\n        }\n    }\n\n    float segment_segment_distance(glm::vec3 p1, glm::vec3 p2,\n                                    glm::vec3 q1, glm::vec3 q2) {\n        glm::vec3 u = p2 - p1, v = q2 - q1, w = p1 - q1;\n        float a = glm::dot(u, u), b = glm::dot(u, v), c = glm::dot(v, v);\n        float d = glm::dot(u, w), e = glm::dot(v, w);\n        float denom = a * c - b * b;\n\n        float s = (denom < 1e-6f) ? 0.0f : glm::clamp((b * e - c * d) / denom, 0.0f, 1.0f);\n        float t = (denom < 1e-6f) ? (b > c ? d / b : e / c) : glm::clamp((a * e - b * d) / denom, 0.0f, 1.0f);\n\n        return glm::length((q1 + t * v) - (p1 + s * u));\n    }\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"jacobi-solver-gpu-parallel",children:"Jacobi Solver (GPU-Parallel)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"void jacobi_solve(std::vector<Constraint>& constraints,\n                  std::vector<Particle>& particles, int iterations) {\n    std::vector<glm::vec3> position_deltas(particles.size(), glm::vec3(0.0f));\n    std::vector<int> constraint_counts(particles.size(), 0);\n\n    for (int iter = 0; iter < iterations; ++iter) {\n        std::fill(position_deltas.begin(), position_deltas.end(), glm::vec3(0.0f));\n        std::fill(constraint_counts.begin(), constraint_counts.end(), 0);\n\n        #pragma omp parallel for\n        for (size_t i = 0; i < constraints.size(); ++i) {\n            auto correction = constraints[i].compute_correction();\n            #pragma omp atomic\n            position_deltas[correction.particle1_idx] += correction.delta1;\n            #pragma omp atomic\n            constraint_counts[correction.particle1_idx]++;\n            #pragma omp atomic\n            position_deltas[correction.particle2_idx] += correction.delta2;\n            #pragma omp atomic\n            constraint_counts[correction.particle2_idx]++;\n        }\n\n        #pragma omp parallel for\n        for (size_t i = 0; i < particles.size(); ++i) {\n            if (constraint_counts[i] > 0) {\n                particles[i].position += position_deltas[i] / float(constraint_counts[i]);\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"tangleconstraint-implementation-javascript",children:"TangleConstraint Implementation (JavaScript)"}),"\n",(0,s.jsx)(e.p,{children:"Dynamic constraint created when rope crossings become physical tangles:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class TangleConstraint {\n    static nextId = 0;\n\n    constructor(particleA, particleB, ropeA, ropeB, crossingPoint, options = {}) {\n        this.id = TangleConstraint.nextId++;\n        this.particleA = particleA;\n        this.particleB = particleB;\n        this.ropeA = ropeA;\n        this.ropeB = ropeB;\n        this.crossingPoint = crossingPoint.copy();\n\n        // Physics parameters\n        this.friction = options.friction ?? 0.5;        // Capstan friction coefficient\n        this.stiffness = options.stiffness ?? 0.8;      // Constraint stiffness\n        this.maxDistance = options.maxDistance ?? 15;   // Break if exceeded\n        this.minDistance = options.minDistance ?? 2;    // Minimum (fully locked)\n\n        // Current state\n        this.restDistance = particleA.position.distanceTo(particleB.position);\n        this.restDistance = Math.max(this.minDistance, Math.min(this.restDistance, this.maxDistance));\n        this.wrapAngle = 0;                             // Accumulated wrap (radians)\n        this.tension = 0;                               // Current tension at crossing\n        this.age = 0;                                   // Frames since creation\n        this.isLocked = false;                          // Has tightened past threshold\n\n        // Thresholds\n        this.lockThreshold = this.minDistance * 2;      // Lock when rest < this\n        this.tightenRate = 0.02;                        // How fast it tightens under tension\n        this.breakTension = 200;                        // Force required to break\n    }\n\n    /**\n     * Solve the tangle constraint (call during PBD solver loop)\n     */\n    solve() {\n        const delta = this.particleB.position.subtract(this.particleA.position);\n        const dist = delta.length();\n\n        if (dist < 1e-6) return;\n\n        // Compute effective rest distance (locked tangles are tighter)\n        const effectiveRest = this.isLocked\n            ? this.restDistance * 0.5\n            : this.restDistance;\n\n        // Only pull together, don't push apart\n        if (dist <= effectiveRest) return;\n\n        const error = dist - effectiveRest;\n        const wA = this.particleA.inverseMass;\n        const wB = this.particleB.inverseMass;\n        const wSum = wA + wB;\n\n        if (wSum < 1e-6) return;\n\n        // Apply Capstan friction effect: friction amplifies with wrap angle\n        // T\u2082 = T\u2081 \xd7 e^(\u03bc\u03b8) - but we cap it for stability\n        const frictionFactor = Math.min(Math.exp(this.friction * this.wrapAngle), 3.0);\n\n        // Compute correction with stiffness and friction\n        const correctionMag = (error * this.stiffness * frictionFactor) / (dist * wSum);\n        const correction = delta.scale(correctionMag);\n\n        // Apply corrections\n        this.particleA.position = this.particleA.position.add(correction.scale(wA));\n        this.particleB.position = this.particleB.position.subtract(correction.scale(wB));\n\n        // Record tension for tightening logic\n        this.tension = error * frictionFactor;\n    }\n\n    /**\n     * Update tangle state (call each frame after physics step)\n     */\n    update(dt) {\n        this.age++;\n\n        // Update wrap angle based on local rope geometry\n        this.wrapAngle = this._computeLocalWrapAngle();\n\n        // Tighten under tension (gradual, not instant)\n        if (this.tension > 10 && !this.isLocked) {\n            const tightenAmount = this.tightenRate * this.tension * dt;\n            this.restDistance = Math.max(\n                this.minDistance,\n                this.restDistance - tightenAmount\n            );\n        }\n\n        // Lock if tightened enough\n        if (this.restDistance < this.lockThreshold) {\n            this.isLocked = true;\n        }\n\n        // Update crossing point to midpoint\n        this.crossingPoint = this.particleA.position.add(this.particleB.position).scale(0.5);\n    }\n\n    /**\n     * Check if this tangle should break\n     */\n    shouldBreak() {\n        const dist = this.particleA.position.distanceTo(this.particleB.position);\n\n        // Break if stretched too far for too long\n        if (dist > this.maxDistance) {\n            return true;\n        }\n\n        // Locked tangles require much more force to break\n        if (this.isLocked) {\n            return this.tension > this.breakTension * 3;\n        }\n\n        // Young tangles break easily\n        if (this.age < 30) {\n            return dist > this.restDistance * 1.5;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get crossing sign for braid word tracking (+1 or -1)\n     */\n    getCrossingSign() {\n        // Determine which rope is \"over\" based on perpendicular direction\n        const delta = this.particleB.position.subtract(this.particleA.position);\n        // In 2D top-down: positive cross product = ropeA over ropeB\n        return delta.x * (this.particleA.position.y - this.crossingPoint.y) > 0 ? 1 : -1;\n    }\n\n    /**\n     * Compute local wrap angle from rope geometry\n     */\n    _computeLocalWrapAngle() {\n        // Get tangent directions of both ropes at crossing\n        const tangentA = this._getRopeTangentAt(this.ropeA, this.particleA);\n        const tangentB = this._getRopeTangentAt(this.ropeB, this.particleB);\n\n        if (!tangentA || !tangentB) return this.wrapAngle;\n\n        // Wrap angle is based on how perpendicular the ropes are\n        // Parallel = 0\xb0, Perpendicular = 90\xb0\n        const dot = Math.abs(tangentA.dot(tangentB));\n        const angle = Math.acos(Math.min(1, Math.max(-1, dot)));\n\n        // Smooth update (don't jump)\n        return this.wrapAngle * 0.9 + angle * 0.1;\n    }\n\n    _getRopeTangentAt(rope, particle) {\n        const idx = rope.particles.indexOf(particle);\n        if (idx < 0) return null;\n\n        const prev = rope.particles[Math.max(0, idx - 1)];\n        const next = rope.particles[Math.min(rope.particles.length - 1, idx + 1)];\n\n        return next.position.subtract(prev.position).normalize();\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"tangle-detection-and-management",children:"Tangle Detection and Management"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class TangleManager {\n    constructor(world) {\n        this.world = world;\n        this.tangles = [];\n        this.tanglePairs = new Set(); // Track existing pairs\n    }\n\n    /**\n     * Detect and create new tangles (call after position prediction, before solving)\n     */\n    detectNewTangles() {\n        const ropes = this.world.ropes;\n        const ropeDiameter = 8; // Detection threshold\n\n        for (let i = 0; i < ropes.length; i++) {\n            for (let j = i + 1; j < ropes.length; j++) {\n                this._checkRopePair(ropes[i], ropes[j], ropeDiameter);\n            }\n        }\n    }\n\n    _checkRopePair(ropeA, ropeB, threshold) {\n        const particlesA = ropeA.particles;\n        const particlesB = ropeB.particles;\n\n        for (let ai = 0; ai < particlesA.length - 1; ai++) {\n            for (let bi = 0; bi < particlesB.length - 1; bi++) {\n                const result = this._checkSegmentPair(\n                    particlesA[ai], particlesA[ai + 1],\n                    particlesB[bi], particlesB[bi + 1],\n                    threshold\n                );\n\n                if (result.shouldFormTangle) {\n                    this._createTangle(\n                        result.closestA, result.closestB,\n                        ropeA, ropeB, result.crossingPoint\n                    );\n                }\n            }\n        }\n    }\n\n    _checkSegmentPair(a1, a2, b1, b2, threshold) {\n        // Segment-segment closest points\n        const result = segmentSegmentClosest(a1.position, a2.position, b1.position, b2.position);\n\n        if (result.distance > threshold) {\n            return { shouldFormTangle: false };\n        }\n\n        // Already have a tangle for these particles?\n        const pairKey = this._makePairKey(result.closestParticleA, result.closestParticleB);\n        if (this.tanglePairs.has(pairKey)) {\n            return { shouldFormTangle: false };\n        }\n\n        // Check tension direction - would pulling tighten this?\n        const tensionA = a2.position.subtract(a1.position).normalize();\n        const tensionB = b2.position.subtract(b1.position).normalize();\n        const separation = result.closestB.subtract(result.closestA).normalize();\n\n        const pullA = tensionA.dot(separation);\n        const pullB = tensionB.dot(separation.scale(-1));\n        const wouldTighten = pullA > 0.3 || pullB > 0.3;\n\n        // Check wrap angle\n        const wrapAngle = Math.acos(Math.min(1, Math.abs(tensionA.dot(tensionB))));\n        const sufficientWrap = wrapAngle > 0.5; // ~30 degrees\n\n        return {\n            shouldFormTangle: wouldTighten && sufficientWrap,\n            closestA: result.closestParticleA,\n            closestB: result.closestParticleB,\n            crossingPoint: result.closestA.add(result.closestB).scale(0.5)\n        };\n    }\n\n    _createTangle(particleA, particleB, ropeA, ropeB, crossingPoint) {\n        const tangle = new TangleConstraint(\n            particleA, particleB, ropeA, ropeB, crossingPoint\n        );\n\n        this.tangles.push(tangle);\n        this.tanglePairs.add(this._makePairKey(particleA, particleB));\n\n        // Emit event for braid tracking\n        if (this.world.onTangleFormed) {\n            this.world.onTangleFormed(tangle);\n        }\n    }\n\n    _makePairKey(pA, pB) {\n        const idA = pA.id ?? pA;\n        const idB = pB.id ?? pB;\n        return idA < idB ? `${idA}-${idB}` : `${idB}-${idA}`;\n    }\n\n    /**\n     * Solve all tangle constraints (call in PBD solver loop)\n     */\n    solveTangles() {\n        for (const tangle of this.tangles) {\n            tangle.solve();\n        }\n    }\n\n    /**\n     * Update tangles and remove broken ones (call after physics step)\n     */\n    updateTangles(dt) {\n        for (let i = this.tangles.length - 1; i >= 0; i--) {\n            const tangle = this.tangles[i];\n            tangle.update(dt);\n\n            if (tangle.shouldBreak()) {\n                this.tanglePairs.delete(\n                    this._makePairKey(tangle.particleA, tangle.particleB)\n                );\n                this.tangles.splice(i, 1);\n\n                if (this.world.onTangleBroken) {\n                    this.world.onTangleBroken(tangle);\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"capstan-friction-utility",children:"Capstan Friction Utility"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * Calculate friction-amplified tension using Capstan equation\n * T\u2082 = T\u2081 \xd7 e^(\u03bc\u03b8)\n *\n * @param tensionIn - Input tension\n * @param wrapAngle - Wrap angle in radians\n * @param mu - Friction coefficient (0.3-0.8 for rope-on-rope)\n * @returns Amplified tension\n */\nfunction capstanFriction(tensionIn, wrapAngle, mu = 0.5) {\n    return tensionIn * Math.exp(mu * wrapAngle);\n}\n\n/**\n * Example: 90\xb0 wrap with \u03bc=0.5 gives 2.2\xd7 amplification\n * Full 360\xb0 wrap gives 23\xd7 amplification\n */\n"})}),"\n",(0,s.jsx)(e.h2,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Operation"}),(0,s.jsx)(e.th,{children:"CPU (single)"}),(0,s.jsx)(e.th,{children:"GPU"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"PBD Rope (100 particles, 5 iter)"}),(0,s.jsx)(e.td,{children:"~0.5ms"}),(0,s.jsx)(e.td,{children:"~0.1ms"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Verlet Integration (1000 particles)"}),(0,s.jsx)(e.td,{children:"~0.01ms"}),(0,s.jsx)(e.td,{children:"-"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Gauss-Seidel (100 constraints)"}),(0,s.jsx)(e.td,{children:"~0.3ms"}),(0,s.jsx)(e.td,{children:"N/A"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Jacobi (100 constraints)"}),(0,s.jsx)(e.td,{children:"~0.5ms"}),(0,s.jsx)(e.td,{children:"~0.1ms"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Three-Dog Leash (60 particles)"}),(0,s.jsx)(e.td,{children:"~0.7ms total"}),(0,s.jsx)(e.td,{children:"-"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:'M\xfcller et al. (2006): "Position Based Dynamics"'}),"\n",(0,s.jsx)(e.li,{children:'Jakobsen (2001): "Advanced Character Physics" (GDC)'}),"\n",(0,s.jsx)(e.li,{children:'Baraff (1996): "Linear-Time Dynamics using Lagrange Multipliers"'}),"\n",(0,s.jsx)(e.li,{children:'Shoemake (1985): "Animating Rotation with Quaternion Curves"'}),"\n",(0,s.jsx)(e.li,{children:'Kavan et al. (2008): "Geometric Skinning with Dual Quaternions"'}),"\n",(0,s.jsx)(e.li,{children:'ALEM Method (2024 SIGGRAPH): "Arbitrary Lagrangian-Eulerian Modal Analysis"'}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);