"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[50668],{28453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>o});var a=t(96540);const r={},s=a.createContext(r);function i(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:i(n.components),a.createElement(s.Provider,{value:e},n.children)}},50640:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"skills/dag_execution_tracer/index","title":"\ud83d\udce6 Dag Execution Tracer","description":"Traces complete execution paths through DAG workflows. Records timing, inputs, outputs, and state transitions for all nodes. Activate on \'execution trace\', \'trace execution\', \'execution path\', \'debug execution\', \'execution log\'. NOT for performance analysis (use dag-performance-profiler) or failure investigation (use dag-failure-analyzer).","source":"@site/docs/skills/dag_execution_tracer/index.md","sourceDirName":"skills/dag_execution_tracer","slug":"/skills/dag_execution_tracer/","permalink":"/docs/skills/dag_execution_tracer/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Execution Tracer","sidebar_position":1}}');var r=t(74848),s=t(28453);const i={sidebar_label:"Dag Execution Tracer",sidebar_position:1},o="\ud83d\udce6 Dag Execution Tracer",c={},d=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Trace Recording",id:"1-trace-recording",level:3},{value:"2. Trace Visualization",id:"2-trace-visualization",level:3},{value:"3. Context Capture",id:"3-context-capture",level:3},{value:"4. Trace Analysis",id:"4-trace-analysis",level:3},{value:"Trace Architecture",id:"trace-architecture",level:2},{value:"Trace Recording",id:"trace-recording",level:2},{value:"Context Capture",id:"context-capture",level:2},{value:"Span Attributes",id:"span-attributes",level:2},{value:"Trace Visualization",id:"trace-visualization",level:2},{value:"Trace Export",id:"trace-export",level:2},{value:"Trace Report",id:"trace-report",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function l(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"-dag-execution-tracer",children:"\ud83d\udce6 Dag Execution Tracer"})}),"\n",(0,r.jsx)(e.p,{children:"Traces complete execution paths through DAG workflows. Records timing, inputs, outputs, and state transitions for all nodes. Activate on 'execution trace', 'trace execution', 'execution path', 'debug execution', 'execution log'. NOT for performance analysis (use dag-performance-profiler) or failure investigation (use dag-failure-analyzer)."}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,r.jsx)(e.h2,{id:"tags",children:"Tags"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"dag"})," ",(0,r.jsx)(e.code,{children:"observability"})," ",(0,r.jsx)(e.code,{children:"tracing"})," ",(0,r.jsx)(e.code,{children:"debugging"})," ",(0,r.jsx)(e.code,{children:"logging"})]}),"\n",(0,r.jsx)(e.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/docs/skills/dag_performance_profiler",children:"Dag Performance Profiler"})}),": Provides timing data"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/docs/skills/dag_failure_analyzer",children:"Dag Failure Analyzer"})}),": Provides failure context"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/docs/skills/dag_pattern_learner",children:"Dag Pattern Learner"})}),": Provides execution patterns"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"/docs/skills/dag_task_scheduler",children:"Dag Task Scheduler"})}),": Traces scheduled tasks"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"You are a DAG Execution Tracer, an expert at recording and analyzing complete execution paths through DAG workflows. You capture timing, inputs, outputs, state transitions, and context for all nodes to enable debugging, analysis, and learning."}),"\n",(0,r.jsx)(e.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,r.jsx)(e.h3,{id:"1-trace-recording",children:"1. Trace Recording"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Capture node execution events"}),"\n",(0,r.jsx)(e.li,{children:"Record state transitions"}),"\n",(0,r.jsx)(e.li,{children:"Log inputs and outputs"}),"\n",(0,r.jsx)(e.li,{children:"Track context propagation"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"2-trace-visualization",children:"2. Trace Visualization"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Generate execution timelines"}),"\n",(0,r.jsx)(e.li,{children:"Show dependency relationships"}),"\n",(0,r.jsx)(e.li,{children:"Visualize parallel execution"}),"\n",(0,r.jsx)(e.li,{children:"Highlight critical paths"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"3-context-capture",children:"3. Context Capture"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Record decision points"}),"\n",(0,r.jsx)(e.li,{children:"Capture environmental context"}),"\n",(0,r.jsx)(e.li,{children:"Log tool usage"}),"\n",(0,r.jsx)(e.li,{children:"Track resource consumption"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"4-trace-analysis",children:"4. Trace Analysis"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Identify bottlenecks"}),"\n",(0,r.jsx)(e.li,{children:"Detect anomalies"}),"\n",(0,r.jsx)(e.li,{children:"Support debugging"}),"\n",(0,r.jsx)(e.li,{children:"Enable replay"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"trace-architecture",children:"Trace Architecture"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"interface ExecutionTrace {\n  traceId: string;\n  dagId: string;\n  startedAt: Date;\n  completedAt?: Date;\n  status: 'running' | 'completed' | 'failed' | 'cancelled';\n  rootSpan: TraceSpan;\n  spans: Map<SpanId, TraceSpan>;\n  events: TraceEvent[];\n  context: TraceContext;\n  metadata: TraceMetadata;\n}\n\ninterface TraceSpan {\n  spanId: SpanId;\n  parentSpanId?: SpanId;\n  nodeId: NodeId;\n  operationName: string;\n  startTime: Date;\n  endTime?: Date;\n  duration?: number;\n  status: SpanStatus;\n  attributes: Record<string, unknown>;\n  events: SpanEvent[];\n  links: SpanLink[];\n}\n\ntype SpanStatus =\n  | { code: 'OK' }\n  | { code: 'ERROR'; message: string }\n  | { code: 'UNSET' };\n\ninterface TraceEvent {\n  timestamp: Date;\n  type: EventType;\n  spanId: SpanId;\n  name: string;\n  attributes: Record<string, unknown>;\n}\n\ntype EventType =\n  | 'node_started'\n  | 'node_completed'\n  | 'node_failed'\n  | 'state_transition'\n  | 'tool_called'\n  | 'context_received'\n  | 'output_produced'\n  | 'retry_initiated'\n  | 'child_spawned';\n"})}),"\n",(0,r.jsx)(e.h2,{id:"trace-recording",children:"Trace Recording"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"class ExecutionTracer {\n  private traces: Map<string, ExecutionTrace> = new Map();\n\n  startTrace(dagId: string): ExecutionTrace {\n    const trace: ExecutionTrace = {\n      traceId: generateTraceId(),\n      dagId,\n      startedAt: new Date(),\n      status: 'running',\n      rootSpan: this.createRootSpan(dagId),\n      spans: new Map(),\n      events: [],\n      context: this.captureContext(),\n      metadata: this.captureMetadata(),\n    };\n\n    this.traces.set(trace.traceId, trace);\n    return trace;\n  }\n\n  startSpan(\n    traceId: string,\n    nodeId: NodeId,\n    operationName: string,\n    parentSpanId?: SpanId\n  ): TraceSpan {\n    const trace = this.getTrace(traceId);\n    const span: TraceSpan = {\n      spanId: generateSpanId(),\n      parentSpanId,\n      nodeId,\n      operationName,\n      startTime: new Date(),\n      status: { code: 'UNSET' },\n      attributes: {},\n      events: [],\n      links: [],\n    };\n\n    trace.spans.set(span.spanId, span);\n    this.recordEvent(traceId, {\n      timestamp: new Date(),\n      type: 'node_started',\n      spanId: span.spanId,\n      name: `${operationName} started`,\n      attributes: { nodeId },\n    });\n\n    return span;\n  }\n\n  endSpan(\n    traceId: string,\n    spanId: SpanId,\n    status: SpanStatus,\n    attributes?: Record<string, unknown>\n  ): void {\n    const trace = this.getTrace(traceId);\n    const span = trace.spans.get(spanId);\n\n    if (!span) throw new Error(`Span ${spanId} not found`);\n\n    span.endTime = new Date();\n    span.duration = span.endTime.getTime() - span.startTime.getTime();\n    span.status = status;\n    if (attributes) {\n      span.attributes = { ...span.attributes, ...attributes };\n    }\n\n    this.recordEvent(traceId, {\n      timestamp: new Date(),\n      type: status.code === 'OK' ? 'node_completed' : 'node_failed',\n      spanId,\n      name: `${span.operationName} ${status.code === 'OK' ? 'completed' : 'failed'}`,\n      attributes: { duration: span.duration, ...attributes },\n    });\n  }\n\n  recordEvent(traceId: string, event: TraceEvent): void {\n    const trace = this.getTrace(traceId);\n    trace.events.push(event);\n  }\n\n  completeTrace(traceId: string, status: ExecutionTrace['status']): void {\n    const trace = this.getTrace(traceId);\n    trace.completedAt = new Date();\n    trace.status = status;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"context-capture",children:"Context Capture"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"interface TraceContext {\n  environment: EnvironmentContext;\n  user: UserContext;\n  dag: DAGContext;\n  execution: ExecutionContext;\n}\n\ninterface EnvironmentContext {\n  runtime: 'claude-code-cli' | 'sdk' | 'http-api';\n  platform: string;\n  nodeVersion?: string;\n  timestamp: Date;\n  timezone: string;\n}\n\ninterface DAGContext {\n  dagId: string;\n  dagName: string;\n  totalNodes: number;\n  totalEdges: number;\n  maxParallelism: number;\n  estimatedDuration?: number;\n}\n\ninterface ExecutionContext {\n  initiator: string;\n  priority: 'low' | 'normal' | 'high';\n  timeout?: number;\n  retryPolicy?: RetryPolicy;\n  isolationLevel: IsolationLevel;\n}\n\nfunction captureContext(): TraceContext {\n  return {\n    environment: {\n      runtime: detectRuntime(),\n      platform: process.platform,\n      nodeVersion: process.version,\n      timestamp: new Date(),\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    },\n    user: captureUserContext(),\n    dag: {} as DAGContext, // Filled when DAG is known\n    execution: {} as ExecutionContext, // Filled at execution start\n  };\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"span-attributes",children:"Span Attributes"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"function recordNodeExecution(\n  tracer: ExecutionTracer,\n  traceId: string,\n  node: DAGNode,\n  input: unknown,\n  parentSpan?: TraceSpan\n): TraceSpan {\n  const span = tracer.startSpan(\n    traceId,\n    node.id,\n    `node:${node.type}:${node.id}`,\n    parentSpan?.spanId\n  );\n\n  // Standard attributes\n  span.attributes = {\n    'dag.node.id': node.id,\n    'dag.node.type': node.type,\n    'dag.node.skill': node.skillId ?? 'none',\n    'dag.node.dependencies': node.dependencies.length,\n    'dag.input.size': JSON.stringify(input).length,\n  };\n\n  return span;\n}\n\nfunction recordToolCall(\n  tracer: ExecutionTracer,\n  traceId: string,\n  spanId: SpanId,\n  tool: string,\n  args: unknown,\n  result: unknown,\n  duration: number\n): void {\n  tracer.recordEvent(traceId, {\n    timestamp: new Date(),\n    type: 'tool_called',\n    spanId,\n    name: `tool:${tool}`,\n    attributes: {\n      tool,\n      args: summarizeArgs(args),\n      resultSize: JSON.stringify(result).length,\n      duration,\n    },\n  });\n}\n\nfunction recordStateTransition(\n  tracer: ExecutionTracer,\n  traceId: string,\n  spanId: SpanId,\n  fromState: string,\n  toState: string,\n  reason: string\n): void {\n  tracer.recordEvent(traceId, {\n    timestamp: new Date(),\n    type: 'state_transition',\n    spanId,\n    name: `${fromState} \u2192 ${toState}`,\n    attributes: { fromState, toState, reason },\n  });\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"trace-visualization",children:"Trace Visualization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"function generateTimeline(trace: ExecutionTrace): string {\n  const spans = Array.from(trace.spans.values())\n    .sort((a, b) => a.startTime.getTime() - b.startTime.getTime());\n\n  const totalDuration = trace.completedAt\n    ? trace.completedAt.getTime() - trace.startedAt.getTime()\n    : Date.now() - trace.startedAt.getTime();\n\n  const scale = 80; // Characters width\n\n  let timeline = '';\n  timeline += `Execution Timeline (${totalDuration}ms total)\\n`;\n  timeline += '\u2550'.repeat(scale + 30) + '\\n';\n\n  for (const span of spans) {\n    const offset = Math.round(\n      ((span.startTime.getTime() - trace.startedAt.getTime()) / totalDuration) * scale\n    );\n    const width = Math.max(1, Math.round(\n      ((span.duration ?? 0) / totalDuration) * scale\n    ));\n\n    const bar = ' '.repeat(offset) + '\u2588'.repeat(width);\n    const status = span.status.code === 'OK' ? '\u2713' :\n                   span.status.code === 'ERROR' ? '\u2717' : '?';\n\n    timeline += `${span.nodeId.padEnd(20)} ${status} ${bar} ${span.duration ?? 0}ms\\n`;\n  }\n\n  return timeline;\n}\n\nfunction generateDependencyGraph(trace: ExecutionTrace): string {\n  const spans = Array.from(trace.spans.values());\n  const nodes = spans.map(s => s.nodeId);\n  const edges: string[] = [];\n\n  for (const span of spans) {\n    if (span.parentSpanId) {\n      const parent = trace.spans.get(span.parentSpanId);\n      if (parent) {\n        edges.push(`${parent.nodeId} --\x3e ${span.nodeId}`);\n      }\n    }\n  }\n\n  let graph = 'graph TD\\n';\n  for (const node of nodes) {\n    const span = spans.find(s => s.nodeId === node);\n    const status = span?.status.code === 'OK' ? ':::success' :\n                   span?.status.code === 'ERROR' ? ':::error' : '';\n    graph += `  ${node}[${node}]${status}\\n`;\n  }\n  for (const edge of edges) {\n    graph += `  ${edge}\\n`;\n  }\n\n  return graph;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"trace-export",children:"Trace Export"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"interface TraceExport {\n  format: 'json' | 'otlp' | 'jaeger' | 'yaml';\n  includeEvents: boolean;\n  includeAttributes: boolean;\n  sanitize: boolean;\n}\n\nfunction exportTrace(\n  trace: ExecutionTrace,\n  options: TraceExport\n): string {\n  const sanitized = options.sanitize\n    ? sanitizeTrace(trace)\n    : trace;\n\n  switch (options.format) {\n    case 'json':\n      return JSON.stringify(sanitized, null, 2);\n    case 'otlp':\n      return convertToOTLP(sanitized);\n    case 'jaeger':\n      return convertToJaeger(sanitized);\n    case 'yaml':\n      return convertToYAML(sanitized);\n  }\n}\n\nfunction sanitizeTrace(trace: ExecutionTrace): ExecutionTrace {\n  // Remove sensitive data from attributes\n  const sanitizedSpans = new Map<SpanId, TraceSpan>();\n\n  for (const [id, span] of trace.spans) {\n    sanitizedSpans.set(id, {\n      ...span,\n      attributes: sanitizeAttributes(span.attributes),\n    });\n  }\n\n  return {\n    ...trace,\n    spans: sanitizedSpans,\n    events: trace.events.map(e => ({\n      ...e,\n      attributes: sanitizeAttributes(e.attributes),\n    })),\n  };\n}\n\nconst SENSITIVE_PATTERNS = [\n  /api[_-]?key/i,\n  /password/i,\n  /secret/i,\n  /token/i,\n  /credential/i,\n];\n\nfunction sanitizeAttributes(\n  attrs: Record<string, unknown>\n): Record<string, unknown> {\n  const sanitized: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (SENSITIVE_PATTERNS.some(p => p.test(key))) {\n      sanitized[key] = '[REDACTED]';\n    } else {\n      sanitized[key] = value;\n    }\n  }\n\n  return sanitized;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"trace-report",children:"Trace Report"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:'executionTrace:\n  traceId: "tr-8f4a2b1c-3d5e-6f7a-8b9c"\n  dagId: "code-review-dag"\n  startedAt: "2024-01-15T10:30:00.000Z"\n  completedAt: "2024-01-15T10:30:45.234Z"\n  status: completed\n  duration: 45234\n\n  timeline: |\n    Execution Timeline (45234ms total)\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    fetch-code            \u2713 \u2588\u2588\u2588\u2588                                                    3421ms\n    analyze-complexity    \u2713     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                                           8234ms\n    check-security        \u2713     \u2588\u2588\u2588\u2588\u2588\u2588\u2588                                             6892ms\n    review-performance    \u2713          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                                12456ms\n    aggregate-results     \u2713                          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588              14231ms\n\n  spans:\n    - spanId: "sp-001"\n      nodeId: fetch-code\n      operationName: "node:skill:fetch-code"\n      startTime: "2024-01-15T10:30:00.000Z"\n      duration: 3421\n      status: OK\n      attributes:\n        dag.node.type: skill\n        dag.node.skill: code-fetcher\n        dag.input.size: 245\n        dag.output.size: 15234\n      events:\n        - type: tool_called\n          name: "tool:Read"\n          attributes:\n            file: "src/main.ts"\n            duration: 234\n\n    - spanId: "sp-002"\n      nodeId: analyze-complexity\n      operationName: "node:skill:analyze-complexity"\n      startTime: "2024-01-15T10:30:03.421Z"\n      duration: 8234\n      status: OK\n      parentSpanId: "sp-001"\n\n    - spanId: "sp-003"\n      nodeId: check-security\n      operationName: "node:skill:check-security"\n      startTime: "2024-01-15T10:30:03.421Z"\n      duration: 6892\n      status: OK\n      parentSpanId: "sp-001"\n\n  context:\n    environment:\n      runtime: claude-code-cli\n      platform: darwin\n    execution:\n      initiator: user\n      priority: normal\n      isolationLevel: moderate\n\n  summary:\n    totalSpans: 5\n    successfulSpans: 5\n    failedSpans: 0\n    criticalPath: ["fetch-code", "review-performance", "aggregate-results"]\n    parallelExecution: 2  # Max concurrent spans\n'})}),"\n",(0,r.jsx)(e.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Output"}),": Traces to ",(0,r.jsx)(e.code,{children:"dag-performance-profiler"})," and ",(0,r.jsx)(e.code,{children:"dag-failure-analyzer"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Events"}),": State changes from ",(0,r.jsx)(e.code,{children:"dag-task-scheduler"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Storage"}),": Patterns to ",(0,r.jsx)(e.code,{children:"dag-pattern-learner"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Visualization"}),": Timeline to monitoring dashboards"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Trace Everything"}),": Complete traces enable full debugging"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Structured Attributes"}),": Use consistent attribute naming"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Span Hierarchy"}),": Properly link parent/child spans"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sanitize Exports"}),": Remove sensitive data before sharing"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Correlate Traces"}),": Use trace IDs across services"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:"Full visibility. Complete history. Every execution recorded."})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}}}]);