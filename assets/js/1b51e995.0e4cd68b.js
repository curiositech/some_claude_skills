"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[21568],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(96540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}},89988:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"skills/form_validation_architect/references/zod-patterns","title":"Advanced Zod Schema Patterns","description":"Production patterns for complex validation with Zod.","source":"@site/docs/skills/form_validation_architect/references/zod-patterns.md","sourceDirName":"skills/form_validation_architect/references","slug":"/skills/form_validation_architect/references/zod-patterns","permalink":"/docs/skills/form_validation_architect/references/zod-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Advanced Zod Schema Patterns","sidebar_label":"Advanced Zod Schema Patterns","sidebar_position":3}}');var r=t(74848),s=t(28453);const i={title:"Advanced Zod Schema Patterns",sidebar_label:"Advanced Zod Schema Patterns",sidebar_position:3},o="Advanced Zod Schema Patterns",d={},c=[{value:"Pattern 1: Conditional Validation (Dependent Fields)",id:"pattern-1-conditional-validation-dependent-fields",level:2},{value:"Pattern 2: Cross-Field Validation",id:"pattern-2-cross-field-validation",level:2},{value:"Pattern 3: Transform and Sanitize",id:"pattern-3-transform-and-sanitize",level:2},{value:"Pattern 4: Union Types with Discriminators",id:"pattern-4-union-types-with-discriminators",level:2},{value:"Pattern 5: Recursive Schemas",id:"pattern-5-recursive-schemas",level:2},{value:"Pattern 6: Custom Validators (refine)",id:"pattern-6-custom-validators-refine",level:2},{value:"Pattern 7: Schema Composition (Reuse)",id:"pattern-7-schema-composition-reuse",level:2},{value:"Pattern 8: Partial and Pick",id:"pattern-8-partial-and-pick",level:2},{value:"Pattern 9: Default Values and Preprocessing",id:"pattern-9-default-values-and-preprocessing",level:2},{value:"Pattern 10: Error Customization",id:"pattern-10-error-customization",level:2},{value:"Pattern 11: Branded Types",id:"pattern-11-branded-types",level:2},{value:"Pattern 12: SuperRefine (Multiple Errors)",id:"pattern-12-superrefine-multiple-errors",level:2},{value:"Production Checklist",id:"production-checklist",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"advanced-zod-schema-patterns",children:"Advanced Zod Schema Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"Production patterns for complex validation with Zod."}),"\n",(0,r.jsx)(n.h2,{id:"pattern-1-conditional-validation-dependent-fields",children:"Pattern 1: Conditional Validation (Dependent Fields)"}),"\n",(0,r.jsx)(n.p,{children:"Validate field B based on field A's value."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const schema = z.object({\n  accountType: z.enum(['personal', 'business']),\n  businessName: z.string().optional(),\n  taxId: z.string().optional()\n}).refine(\n  (data) => {\n    if (data.accountType === 'business') {\n      return !!data.businessName && !!data.taxId;\n    }\n    return true;\n  },\n  {\n    message: 'Business name and tax ID required for business accounts',\n    path: ['businessName'] // Error appears on this field\n  }\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-2-cross-field-validation",children:"Pattern 2: Cross-Field Validation"}),"\n",(0,r.jsx)(n.p,{children:"Validate relationships between multiple fields."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const dateRangeSchema = z.object({\n  startDate: z.date(),\n  endDate: z.date()\n}).refine(\n  (data) => data.endDate > data.startDate,\n  {\n    message: 'End date must be after start date',\n    path: ['endDate']\n  }\n);\n\n// Password confirmation\nconst passwordSchema = z.object({\n  password: z.string().min(8),\n  confirmPassword: z.string()\n}).refine(\n  (data) => data.password === data.confirmPassword,\n  {\n    message: 'Passwords do not match',\n    path: ['confirmPassword']\n  }\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-3-transform-and-sanitize",children:"Pattern 3: Transform and Sanitize"}),"\n",(0,r.jsx)(n.p,{children:"Clean user input before validation."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const phoneSchema = z.string()\n  .transform((val) => val.replace(/\\D/g, '')) // Remove non-digits\n  .pipe(\n    z.string()\n      .length(10, 'Phone must be 10 digits')\n      .regex(/^[2-9]/, 'Invalid area code')\n  );\n\n// Email normalization\nconst emailSchema = z.string()\n  .email()\n  .transform((val) => val.toLowerCase().trim());\n\n// Currency parsing\nconst priceSchema = z.string()\n  .transform((val) => parseFloat(val.replace(/[$,]/g, '')))\n  .pipe(\n    z.number()\n      .positive('Price must be positive')\n      .max(1000000, 'Price too high')\n  );\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-4-union-types-with-discriminators",children:"Pattern 4: Union Types with Discriminators"}),"\n",(0,r.jsx)(n.p,{children:"Type-safe unions for polymorphic data."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const paymentSchema = z.discriminatedUnion('method', [\n  z.object({\n    method: z.literal('card'),\n    cardNumber: z.string().regex(/^\\d{16}$/),\n    cvv: z.string().regex(/^\\d{3}$/)\n  }),\n  z.object({\n    method: z.literal('paypal'),\n    email: z.string().email()\n  }),\n  z.object({\n    method: z.literal('bank'),\n    accountNumber: z.string(),\n    routingNumber: z.string()\n  })\n]);\n\ntype Payment = z.infer<typeof paymentSchema>;\n// TypeScript knows which fields exist based on 'method'\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-5-recursive-schemas",children:"Pattern 5: Recursive Schemas"}),"\n",(0,r.jsx)(n.p,{children:"Self-referential data structures (comments, file trees)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Comment {\n  id: string;\n  text: string;\n  replies: Comment[];\n}\n\nconst commentSchema: z.ZodType<Comment> = z.lazy(() =>\n  z.object({\n    id: z.string(),\n    text: z.string().min(1).max(500),\n    replies: z.array(commentSchema)\n  })\n);\n\n// File system tree\nconst fileNodeSchema: z.ZodType<any> = z.lazy(() =>\n  z.object({\n    name: z.string(),\n    type: z.enum(['file', 'folder']),\n    children: z.array(fileNodeSchema).optional()\n  })\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-6-custom-validators-refine",children:"Pattern 6: Custom Validators (refine)"}),"\n",(0,r.jsx)(n.p,{children:"Complex business logic validation."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Check username availability (async)\nconst usernameSchema = z.string()\n  .min(3)\n  .max(20)\n  .regex(/^[a-z0-9_]+$/, 'Lowercase, numbers, underscores only')\n  .refine(\n    async (username) => {\n      const response = await fetch(`/api/check-username?q=${username}`);\n      return response.ok;\n    },\n    { message: 'Username already taken' }\n  );\n\n// Validate file size\nconst fileSchema = z.instanceof(File)\n  .refine(\n    (file) => file.size <= 5 * 1024 * 1024,\n    { message: 'File must be less than 5MB' }\n  )\n  .refine(\n    (file) => ['image/jpeg', 'image/png'].includes(file.type),\n    { message: 'Only JPEG and PNG allowed' }\n  );\n\n// Business hours validation\nconst appointmentSchema = z.object({\n  date: z.date()\n}).refine(\n  (data) => {\n    const day = data.date.getDay();\n    const hour = data.date.getHours();\n    return day >= 1 && day <= 5 && hour >= 9 && hour < 17;\n  },\n  { message: 'Appointments only available Mon-Fri, 9 AM - 5 PM' }\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-7-schema-composition-reuse",children:"Pattern 7: Schema Composition (Reuse)"}),"\n",(0,r.jsx)(n.p,{children:"Build complex schemas from primitives."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Base schemas\nconst emailField = z.string().email('Invalid email');\nconst passwordField = z.string()\n  .min(8, 'At least 8 characters')\n  .regex(/[A-Z]/, 'Needs uppercase')\n  .regex(/[0-9]/, 'Needs number');\n\n// Compose into registration\nconst registrationSchema = z.object({\n  email: emailField,\n  password: passwordField,\n  confirmPassword: z.string()\n}).refine(\n  (data) => data.password === data.confirmPassword,\n  { path: ['confirmPassword'], message: 'Passwords must match' }\n);\n\n// Extend for profile update\nconst profileUpdateSchema = registrationSchema\n  .omit({ password: true, confirmPassword: true })\n  .extend({\n    firstName: z.string().min(1),\n    lastName: z.string().min(1),\n    bio: z.string().max(500).optional()\n  });\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-8-partial-and-pick",children:"Pattern 8: Partial and Pick"}),"\n",(0,r.jsx)(n.p,{children:"Create variations of schemas."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const userSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n  firstName: z.string(),\n  lastName: z.string(),\n  role: z.enum(['admin', 'user'])\n});\n\n// For updates: all fields optional\nconst userUpdateSchema = userSchema.partial();\n\n// For creation: omit auto-generated fields\nconst userCreateSchema = userSchema.omit({ id: true });\n\n// For public API: only safe fields\nconst userPublicSchema = userSchema.pick({\n  id: true,\n  firstName: true,\n  lastName: true\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-9-default-values-and-preprocessing",children:"Pattern 9: Default Values and Preprocessing"}),"\n",(0,r.jsx)(n.p,{children:"Set defaults before validation."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const configSchema = z.object({\n  theme: z.enum(['light', 'dark']).default('light'),\n  notifications: z.boolean().default(true),\n  itemsPerPage: z.number().min(10).max(100).default(25),\n  tags: z.array(z.string()).default([])\n});\n\n// Preprocessing: Normalize before validate\nconst searchSchema = z.object({\n  query: z.string().trim().min(1),\n  filters: z.record(z.string()).default({})\n}).transform((data) => ({\n  ...data,\n  query: data.query.toLowerCase()\n}));\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-10-error-customization",children:"Pattern 10: Error Customization"}),"\n",(0,r.jsx)(n.p,{children:"Provide context-aware error messages."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const schema = z.object({\n  age: z.number({\n    required_error: 'Age is required',\n    invalid_type_error: 'Age must be a number'\n  })\n    .min(18, 'Must be at least 18 years old')\n    .max(120, 'Age seems invalid'),\n\n  email: z.string({\n    required_error: 'Email address is required'\n  }).email({\n    message: 'Please enter a valid email address'\n  })\n});\n\n// Custom error map for entire form\nconst customErrorMap: z.ZodErrorMap = (issue, ctx) => {\n  if (issue.code === z.ZodIssueCode.invalid_type) {\n    if (issue.expected === 'string') {\n      return { message: 'This field must be text' };\n    }\n  }\n  return { message: ctx.defaultError };\n};\n\nz.setErrorMap(customErrorMap);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-11-branded-types",children:"Pattern 11: Branded Types"}),"\n",(0,r.jsx)(n.p,{children:"Create distinct types for primitives."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Prevent mixing userId with productId\nconst UserIdSchema = z.string().uuid().brand('UserId');\ntype UserId = z.infer<typeof UserIdSchema>;\n\nconst ProductIdSchema = z.string().uuid().brand('ProductId');\ntype ProductId = z.infer<typeof ProductIdSchema>;\n\nfunction getUser(id: UserId) { /* ... */ }\nfunction getProduct(id: ProductId) { /* ... */ }\n\n// TypeScript error: userId is not assignable to ProductId\nconst userId = UserIdSchema.parse('...');\ngetProduct(userId); // \u274c Type error!\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-12-superrefine-multiple-errors",children:"Pattern 12: SuperRefine (Multiple Errors)"}),"\n",(0,r.jsx)(n.p,{children:"Return multiple validation errors at once."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const schema = z.object({\n  password: z.string(),\n  confirmPassword: z.string()\n}).superRefine((data, ctx) => {\n  if (data.password.length < 8) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_small,\n      minimum: 8,\n      type: 'string',\n      inclusive: true,\n      path: ['password'],\n      message: 'Password must be at least 8 characters'\n    });\n  }\n\n  if (!/[A-Z]/.test(data.password)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['password'],\n      message: 'Password must contain an uppercase letter'\n    });\n  }\n\n  if (data.password !== data.confirmPassword) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['confirmPassword'],\n      message: 'Passwords do not match'\n    });\n  }\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"production-checklist",children:"Production Checklist"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u25a1 All user inputs validated with Zod\n\u25a1 Error messages are user-friendly (not technical)\n\u25a1 Async validation debounced (500ms+)\n\u25a1 File uploads have size/type constraints\n\u25a1 Dates validated for business logic (hours, holidays)\n\u25a1 Dependent fields use refine() properly\n\u25a1 Schemas reused via composition (DRY)\n\u25a1 Custom error maps for i18n\n\u25a1 Branded types for IDs prevent mixing\n\u25a1 SuperRefine for complex multi-field validation\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async refine without debounce"}),": Spams API on every keystroke"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Missing path in refine"}),": Error appears on wrong field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transform before validation"}),": Use .pipe() to validate after transform"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not using discriminatedUnion"}),": Poor TypeScript inference on unions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overly strict regex"}),": Rejects valid input (international phone numbers, etc.)"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);