"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[52137],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(96540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}},63148:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"skills/physics_rendering_expert/references/core-algorithms","title":"Core Physics Algorithms","description":"Detailed implementations for PBD, Verlet, and constraint solvers.","source":"@site/docs/skills/physics_rendering_expert/references/core-algorithms.md","sourceDirName":"skills/physics_rendering_expert/references","slug":"/skills/physics_rendering_expert/references/core-algorithms","permalink":"/docs/skills/physics_rendering_expert/references/core-algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Core Physics Algorithms","sidebar_label":"Core Physics Algorithms","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Physics Rendering Expert","permalink":"/docs/skills/physics_rendering_expert/"},"next":{"title":"Physics Implementation Refe...","permalink":"/docs/skills/physics_rendering_expert/references/implementations"}}');var r=s(74848),t=s(28453);const o={title:"Core Physics Algorithms",sidebar_label:"Core Physics Algorithms",sidebar_position:1},l="Core Physics Algorithms",c={},d=[{value:"Position-Based Dynamics (PBD) Loop",id:"position-based-dynamics-pbd-loop",level:2},{value:"Distance Constraint",id:"distance-constraint",level:2},{value:"Verlet Integration",id:"verlet-integration",level:2},{value:"Solver Comparison",id:"solver-comparison",level:2},{value:"Quaternion Operations",id:"quaternion-operations",level:2},{value:"Force-Based vs PBD",id:"force-based-vs-pbd",level:2},{value:"XPBD Compliance",id:"xpbd-compliance",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"core-physics-algorithms",children:"Core Physics Algorithms"})}),"\n",(0,r.jsx)(n.p,{children:"Detailed implementations for PBD, Verlet, and constraint solvers."}),"\n",(0,r.jsx)(n.h2,{id:"position-based-dynamics-pbd-loop",children:"Position-Based Dynamics (PBD) Loop"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void pbd_update(float dt) {\n    // Step 1: Predict\n    for (auto& p : particles) {\n        if (p.inverse_mass == 0.0f) continue;\n        p.velocity += gravity * dt;\n        p.predicted = p.position + p.velocity * dt;\n    }\n\n    // Step 2: Solve constraints (5-10 iterations)\n    for (int i = 0; i < solver_iterations; ++i) {\n        solve_distance_constraints();\n        solve_bending_constraints();\n        solve_collisions();\n    }\n\n    // Step 3: Update\n    for (auto& p : particles) {\n        p.velocity = (p.predicted - p.position) / dt;\n        p.position = p.predicted;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"distance-constraint",children:"Distance Constraint"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void solve_distance(Particle& p1, Particle& p2, float rest_length) {\n    vec3 delta = p2.predicted - p1.predicted;\n    float dist = length(delta);\n    if (dist < 1e-6f) return;\n\n    float error = dist - rest_length;\n    float w_sum = p1.inverse_mass + p2.inverse_mass;\n    if (w_sum < 1e-6f) return;\n\n    vec3 correction = (error / (dist * w_sum)) * delta;\n    p1.predicted += p1.inverse_mass * correction;\n    p2.predicted -= p2.inverse_mass * correction;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"verlet-integration",children:"Verlet Integration"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why Verlet > Euler:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Symplectic (conserves energy)"}),"\n",(0,r.jsx)(n.li,{children:"Second-order accurate"}),"\n",(0,r.jsx)(n.li,{children:"No explicit velocity storage needed"}),"\n",(0,r.jsx)(n.li,{children:"Time-reversible"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void verlet_step(Particle& p, vec3 accel, float dt) {\n    vec3 new_pos = 2.0f * p.position - p.prev_position + accel * dt * dt;\n    p.prev_position = p.position;\n    p.position = new_pos;\n    // Velocity if needed: (position - prev_position) / dt\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"solver-comparison",children:"Solver Comparison"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Solver"}),(0,r.jsx)(n.th,{children:"Parallelizable"}),(0,r.jsx)(n.th,{children:"Convergence"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Gauss-Seidel"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Fast"}),(0,r.jsx)(n.td,{children:"Chains, ropes (sequential structure)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Jacobi"})}),(0,r.jsx)(n.td,{children:"Yes (GPU)"}),(0,r.jsx)(n.td,{children:"Slower"}),(0,r.jsx)(n.td,{children:"Large meshes, cloth, GPU physics"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gauss-Seidel"}),": Updates positions immediately; next constraint sees updated values."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Jacobi"}),": Accumulates corrections; applies averaged result. Requires more iterations but GPU-parallelizable."]}),"\n",(0,r.jsx)(n.h2,{id:"quaternion-operations",children:"Quaternion Operations"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why quaternions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No gimbal lock"}),"\n",(0,r.jsx)(n.li,{children:"Compact (4 floats vs 9 for matrix)"}),"\n",(0,r.jsx)(n.li,{children:"Smooth SLERP interpolation"}),"\n",(0,r.jsx)(n.li,{children:"Stable composition"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key operations:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"q * q'"})," = compose rotations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"q * v * q*"})," = rotate vector"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"normalize(q)"})," = after every operation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"slerp(q1, q2, t)"})," = smooth interpolation"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"force-based-vs-pbd",children:"Force-Based vs PBD"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// BAD: Force-based (requires tiny timesteps)\nvec3 force = normalize(delta) * k * (distance - rest_length);\n\n// GOOD: PBD constraint (stable at any timestep)\nfloat error = distance - rest_length;\nvec3 correction = (error / (distance * (w1 + w2))) * delta;\np1.position += w1 * correction;\np2.position -= w2 * correction;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"xpbd-compliance",children:"XPBD Compliance"}),"\n",(0,r.jsx)(n.p,{children:"Extended PBD adds compliance for soft constraints:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// XPBD with compliance\nfloat alpha = compliance / (dt * dt);\nfloat lambda = error / (w_sum + alpha);\n"})}),"\n",(0,r.jsx)(n.p,{children:"This allows controlling stiffness without changing iteration count."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);