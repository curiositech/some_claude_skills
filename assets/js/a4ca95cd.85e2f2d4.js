"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[89607],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>i});var s=t(96540);const a={},r=s.createContext(a);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},50356:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>f});const s=JSON.parse('{"id":"skills/drone_cv_expert/references/sensor-fusion-ekf","title":"Sensor Fusion & State Estimation Reference","description":"Extended Kalman Filter for Drone State","source":"@site/docs/skills/drone_cv_expert/references/sensor-fusion-ekf.md","sourceDirName":"skills/drone_cv_expert/references","slug":"/skills/drone_cv_expert/references/sensor-fusion-ekf","permalink":"/docs/skills/drone_cv_expert/references/sensor-fusion-ekf","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Sensor Fusion & State Estimation Reference","sidebar_label":"Sensor Fusion & State Estim...","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Object Detection & Tracking...","permalink":"/docs/skills/drone_cv_expert/references/object-detection-tracking"},"next":{"title":"Drone Inspection Specialist","permalink":"/docs/skills/drone_inspection_specialist/"}}');var a=t(74848),r=t(28453);const l={title:"Sensor Fusion & State Estimation Reference",sidebar_label:"Sensor Fusion & State Estim...",sidebar_position:3},i="Sensor Fusion & State Estimation Reference",o={},f=[{value:"Extended Kalman Filter for Drone State",id:"extended-kalman-filter-for-drone-state",level:2},{value:"Multi-Sensor Fusion Architecture",id:"multi-sensor-fusion-architecture",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"sensor-fusion--state-estimation-reference",children:"Sensor Fusion & State Estimation Reference"})}),"\n",(0,a.jsx)(n.h2,{id:"extended-kalman-filter-for-drone-state",children:"Extended Kalman Filter for Drone State"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom typing import Tuple, Optional\n\nclass DroneEKF:\n    """\n    Extended Kalman Filter for drone state estimation.\n    State vector: [x, y, z, vx, vy, vz, roll, pitch, yaw]\n    """\n    def __init__(self):\n        # State: position (3), velocity (3), attitude (3)\n        self.state = np.zeros(9)\n        self.P = np.eye(9) * 1.0  # State covariance\n\n        # Process noise\n        self.Q = np.diag([\n            0.01, 0.01, 0.01,    # Position noise\n            0.05, 0.05, 0.05,    # Velocity noise\n            0.001, 0.001, 0.001  # Attitude noise\n        ])\n\n        # Measurement noise matrices\n        self.R_gps = np.eye(3) * 2.5       # GPS position (meters)\n        self.R_baro = np.array([[0.5]])     # Barometer altitude (meters)\n        self.R_imu_accel = np.eye(3) * 0.1  # Accelerometer\n        self.R_imu_gyro = np.eye(3) * 0.01  # Gyroscope\n\n        self.gravity = np.array([0, 0, 9.81])\n\n    def predict(self, dt: float):\n        """Predict step using motion model"""\n        # State transition matrix (linearized)\n        F = self._get_state_transition_matrix(dt)\n\n        # Predict state\n        self.state = self._motion_model(self.state, dt)\n\n        # Predict covariance\n        self.P = F @ self.P @ F.T + self.Q\n\n    def _motion_model(self, state: np.ndarray, dt: float) -> np.ndarray:\n        """Non-linear motion model"""\n        new_state = state.copy()\n\n        # Position update: x += v * dt\n        new_state[0:3] += state[3:6] * dt\n\n        return new_state\n\n    def _get_state_transition_matrix(self, dt: float) -> np.ndarray:\n        """Jacobian of motion model"""\n        F = np.eye(9)\n        F[0, 3] = dt  # dx/dvx\n        F[1, 4] = dt  # dy/dvy\n        F[2, 5] = dt  # dz/dvz\n        return F\n\n    def update_gps(self, gps_measurement: np.ndarray):\n        """Update with GPS position measurement [lat, lon, alt] in local frame"""\n        # Observation matrix: GPS measures position\n        H = np.zeros((3, 9))\n        H[0:3, 0:3] = np.eye(3)\n\n        # Innovation\n        y = gps_measurement - (H @ self.state)\n\n        # Kalman gain\n        S = H @ self.P @ H.T + self.R_gps\n        K = self.P @ H.T @ np.linalg.inv(S)\n\n        # Update\n        self.state = self.state + K @ y\n        self.P = (np.eye(9) - K @ H) @ self.P\n\n    def update_barometer(self, altitude: float):\n        """Update with barometer altitude measurement"""\n        H = np.zeros((1, 9))\n        H[0, 2] = 1  # Measures z position\n\n        y = altitude - self.state[2]\n        S = H @ self.P @ H.T + self.R_baro\n        K = self.P @ H.T / S\n\n        self.state = self.state + (K * y).flatten()\n        self.P = (np.eye(9) - K @ H) @ self.P\n\n    def update_imu(self, accel: np.ndarray, gyro: np.ndarray, dt: float):\n        """Update with IMU measurements"""\n        # Accelerometer updates velocity (after gravity compensation)\n        roll, pitch, yaw = self.state[6:9]\n        R_body_to_world = self._rotation_matrix(roll, pitch, yaw)\n\n        # Compensate for gravity and transform to world frame\n        accel_world = R_body_to_world @ accel - self.gravity\n\n        # Simple integration for velocity update\n        H_accel = np.zeros((3, 9))\n        H_accel[0:3, 3:6] = np.eye(3) / dt\n\n        innovation = accel_world - (self.state[3:6] - self._prev_velocity) / dt if hasattr(self, \'_prev_velocity\') else accel_world\n        self._prev_velocity = self.state[3:6].copy()\n\n        # Gyroscope updates attitude rates\n        self.state[6:9] += gyro * dt\n\n        # Normalize angles\n        self.state[6:9] = np.mod(self.state[6:9] + np.pi, 2 * np.pi) - np.pi\n\n    def _rotation_matrix(self, roll: float, pitch: float, yaw: float) -> np.ndarray:\n        """Create rotation matrix from Euler angles"""\n        cr, sr = np.cos(roll), np.sin(roll)\n        cp, sp = np.cos(pitch), np.sin(pitch)\n        cy, sy = np.cos(yaw), np.sin(yaw)\n\n        return np.array([\n            [cy*cp, cy*sp*sr - sy*cr, cy*sp*cr + sy*sr],\n            [sy*cp, sy*sp*sr + cy*cr, sy*sp*cr - cy*sr],\n            [-sp, cp*sr, cp*cr]\n        ])\n\n    def get_position(self) -> np.ndarray:\n        return self.state[0:3]\n\n    def get_velocity(self) -> np.ndarray:\n        return self.state[3:6]\n\n    def get_attitude(self) -> np.ndarray:\n        return self.state[6:9]\n\n    def get_covariance(self) -> np.ndarray:\n        return self.P\n\n\nclass UnscentedKalmanFilter:\n    """\n    Unscented Kalman Filter - better for highly nonlinear systems.\n    Use when EKF linearization introduces significant errors.\n    """\n    def __init__(self, n: int = 9):\n        self.n = n\n        self.state = np.zeros(n)\n        self.P = np.eye(n) * 1.0\n\n        # UKF parameters\n        self.alpha = 0.001\n        self.beta = 2.0\n        self.kappa = 0.0\n        self.lambda_ = self.alpha**2 * (n + self.kappa) - n\n\n        # Weights for mean and covariance\n        self.Wm = np.zeros(2 * n + 1)\n        self.Wc = np.zeros(2 * n + 1)\n        self.Wm[0] = self.lambda_ / (n + self.lambda_)\n        self.Wc[0] = self.Wm[0] + (1 - self.alpha**2 + self.beta)\n        for i in range(1, 2 * n + 1):\n            self.Wm[i] = 1 / (2 * (n + self.lambda_))\n            self.Wc[i] = self.Wm[i]\n\n    def _sigma_points(self) -> np.ndarray:\n        """Generate sigma points"""\n        sigma_pts = np.zeros((2 * self.n + 1, self.n))\n        sigma_pts[0] = self.state\n\n        sqrt_P = np.linalg.cholesky((self.n + self.lambda_) * self.P)\n\n        for i in range(self.n):\n            sigma_pts[i + 1] = self.state + sqrt_P[i]\n            sigma_pts[self.n + i + 1] = self.state - sqrt_P[i]\n\n        return sigma_pts\n\n    def predict(self, motion_model: callable, Q: np.ndarray, dt: float):\n        """Predict using unscented transform"""\n        # Generate sigma points\n        sigma_pts = self._sigma_points()\n\n        # Transform through motion model\n        transformed = np.array([motion_model(sp, dt) for sp in sigma_pts])\n\n        # Compute predicted mean\n        self.state = np.sum(self.Wm[:, np.newaxis] * transformed, axis=0)\n\n        # Compute predicted covariance\n        self.P = Q.copy()\n        for i in range(2 * self.n + 1):\n            diff = transformed[i] - self.state\n            self.P += self.Wc[i] * np.outer(diff, diff)\n\n    def update(self, measurement: np.ndarray, measurement_model: callable, R: np.ndarray):\n        """Update with measurement"""\n        # Generate sigma points\n        sigma_pts = self._sigma_points()\n\n        # Transform through measurement model\n        transformed = np.array([measurement_model(sp) for sp in sigma_pts])\n\n        # Predicted measurement\n        z_pred = np.sum(self.Wm[:, np.newaxis] * transformed, axis=0)\n\n        # Innovation covariance\n        Pzz = R.copy()\n        for i in range(2 * self.n + 1):\n            diff = transformed[i] - z_pred\n            Pzz += self.Wc[i] * np.outer(diff, diff)\n\n        # Cross covariance\n        Pxz = np.zeros((self.n, len(measurement)))\n        for i in range(2 * self.n + 1):\n            diff_x = sigma_pts[i] - self.state\n            diff_z = transformed[i] - z_pred\n            Pxz += self.Wc[i] * np.outer(diff_x, diff_z)\n\n        # Kalman gain\n        K = Pxz @ np.linalg.inv(Pzz)\n\n        # Update\n        self.state = self.state + K @ (measurement - z_pred)\n        self.P = self.P - K @ Pzz @ K.T\n\n\nclass ComplementaryFilter:\n    """\n    Simple complementary filter for attitude estimation.\n    Faster than Kalman for basic stabilization.\n    """\n    def __init__(self, alpha: float = 0.98):\n        self.alpha = alpha  # Trust gyroscope vs accelerometer\n        self.roll = 0.0\n        self.pitch = 0.0\n        self.yaw = 0.0\n\n    def update(self, accel: np.ndarray, gyro: np.ndarray, dt: float,\n               mag: Optional[np.ndarray] = None) -> Tuple[float, float, float]:\n        """Update attitude estimate"""\n        # Accelerometer-based attitude (gravity direction)\n        accel_roll = np.arctan2(accel[1], accel[2])\n        accel_pitch = np.arctan2(-accel[0], np.sqrt(accel[1]**2 + accel[2]**2))\n\n        # Gyroscope integration\n        self.roll += gyro[0] * dt\n        self.pitch += gyro[1] * dt\n        self.yaw += gyro[2] * dt\n\n        # Complementary fusion\n        self.roll = self.alpha * self.roll + (1 - self.alpha) * accel_roll\n        self.pitch = self.alpha * self.pitch + (1 - self.alpha) * accel_pitch\n\n        # Magnetometer for yaw (if available)\n        if mag is not None:\n            # Compensate for tilt\n            mx = mag[0] * np.cos(self.pitch) + mag[2] * np.sin(self.pitch)\n            my = (mag[0] * np.sin(self.roll) * np.sin(self.pitch) +\n                  mag[1] * np.cos(self.roll) -\n                  mag[2] * np.sin(self.roll) * np.cos(self.pitch))\n            mag_yaw = np.arctan2(-my, mx)\n            self.yaw = self.alpha * self.yaw + (1 - self.alpha) * mag_yaw\n\n        return self.roll, self.pitch, self.yaw\n'})}),"\n",(0,a.jsx)(n.h2,{id:"multi-sensor-fusion-architecture",children:"Multi-Sensor Fusion Architecture"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from dataclasses import dataclass\nfrom typing import Dict, List, Callable\nimport time\n\n@dataclass\nclass SensorReading:\n    sensor_type: str\n    timestamp: float\n    data: np.ndarray\n    covariance: np.ndarray\n\nclass MultiSensorFusion:\n    """\n    Asynchronous multi-sensor fusion framework.\n    Handles GPS, IMU, Barometer, Optical Flow, LiDAR, etc.\n    """\n    def __init__(self):\n        self.ekf = DroneEKF()\n        self.sensor_queue: List[SensorReading] = []\n        self.last_update_time = time.time()\n\n        # Sensor update callbacks\n        self.update_functions: Dict[str, Callable] = {\n            \'gps\': self._update_gps,\n            \'imu\': self._update_imu,\n            \'barometer\': self._update_baro,\n            \'optical_flow\': self._update_optical_flow,\n            \'lidar\': self._update_lidar\n        }\n\n    def add_reading(self, reading: SensorReading):\n        """Add sensor reading to fusion queue"""\n        self.sensor_queue.append(reading)\n        self.sensor_queue.sort(key=lambda x: x.timestamp)\n\n    def process(self) -> np.ndarray:\n        """Process all pending sensor readings"""\n        while self.sensor_queue:\n            reading = self.sensor_queue.pop(0)\n\n            # Predict to reading time\n            dt = reading.timestamp - self.last_update_time\n            if dt > 0:\n                self.ekf.predict(dt)\n                self.last_update_time = reading.timestamp\n\n            # Update with sensor reading\n            if reading.sensor_type in self.update_functions:\n                self.update_functions[reading.sensor_type](reading)\n\n        return self.ekf.state\n\n    def _update_gps(self, reading: SensorReading):\n        self.ekf.R_gps = reading.covariance\n        self.ekf.update_gps(reading.data)\n\n    def _update_imu(self, reading: SensorReading):\n        accel = reading.data[:3]\n        gyro = reading.data[3:6]\n        self.ekf.update_imu(accel, gyro, 0.01)\n\n    def _update_baro(self, reading: SensorReading):\n        self.ekf.update_barometer(reading.data[0])\n\n    def _update_optical_flow(self, reading: SensorReading):\n        """Update with optical flow velocity measurement"""\n        # Optical flow gives ground-relative velocity\n        H = np.zeros((2, 9))\n        H[0, 3] = 1  # vx\n        H[1, 4] = 1  # vy\n\n        R = reading.covariance[:2, :2]\n        y = reading.data[:2] - self.ekf.state[3:5]\n        S = H @ self.ekf.P @ H.T + R\n        K = self.ekf.P @ H.T @ np.linalg.inv(S)\n        self.ekf.state = self.ekf.state + K @ y\n        self.ekf.P = (np.eye(9) - K @ H) @ self.ekf.P\n\n    def _update_lidar(self, reading: SensorReading):\n        """Update with LiDAR altitude"""\n        self.ekf.update_barometer(reading.data[0])\n'})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);