"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[75496],{28453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(r.Provider,{value:e},n.children)}},88516:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"skills/physics_rendering_expert/references/knot-garden-physics","title":"Knot Garden Physics","description":"Physics and rendering systems for mathematical knot visualization, Reidemeister move animation, and interactive manipulation via Pin+Pull mechanics.","source":"@site/docs/skills/physics_rendering_expert/references/knot-garden-physics.md","sourceDirName":"skills/physics_rendering_expert/references","slug":"/skills/physics_rendering_expert/references/knot-garden-physics","permalink":"/docs/skills/physics_rendering_expert/references/knot-garden-physics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Knot Garden Physics","sidebar_label":"Knot Garden Physics","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Physics Implementation Refe...","permalink":"/docs/skills/physics_rendering_expert/references/implementations"},"next":{"title":"Tangle Physics","permalink":"/docs/skills/physics_rendering_expert/references/tangle-physics"}}');var s=t(74848),r=t(28453);const o={title:"Knot Garden Physics",sidebar_label:"Knot Garden Physics",sidebar_position:3},a="Knot Garden Physics",c={},l=[{value:"Core Challenge: One-Mouse Knot Manipulation",id:"core-challenge-one-mouse-knot-manipulation",level:2},{value:"Pin Constraint System",id:"pin-constraint-system",level:2},{value:"The Problem",id:"the-problem",level:3},{value:"The Solution: Virtual Anchors (Pins)",id:"the-solution-virtual-anchors-pins",level:3},{value:"Pin Placement Rules",id:"pin-placement-rules",level:3},{value:"Pin Interaction States",id:"pin-interaction-states",level:3},{value:"Pull Mechanics",id:"pull-mechanics",level:2},{value:"The Grab+Drag Cycle",id:"the-grabdrag-cycle",level:3},{value:"Pull Behavior Near Pins",id:"pull-behavior-near-pins",level:3},{value:"Reidemeister Move Visualization",id:"reidemeister-move-visualization",level:2},{value:"Move Detection",id:"move-detection",level:3},{value:"Move Animation System",id:"move-animation-system",level:3},{value:"Visual Feedback During Moves",id:"visual-feedback-during-moves",level:3},{value:"Algorithmic Simplification",id:"algorithmic-simplification",level:2},{value:"Greedy Simplification",id:"greedy-simplification",level:3},{value:"A* Search for Optimal Simplification",id:"a-search-for-optimal-simplification",level:3},{value:"3D Knot Representation",id:"3d-knot-representation",level:2},{value:"Particle Extension for 3D",id:"particle-extension-for-3d",level:3},{value:"Distance Constraint in 3D",id:"distance-constraint-in-3d",level:3},{value:"Crossing Detection in 3D",id:"crossing-detection-in-3d",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Spatial Hashing for Collision Detection",id:"spatial-hashing-for-collision-detection",level:3},{value:"Performance Budgets",id:"performance-budgets",level:3},{value:"Integration with Existing Codebase",id:"integration-with-existing-codebase",level:2},{value:"Knot vs Rope: Key Difference",id:"knot-vs-rope-key-difference",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"knot-garden-physics",children:"Knot Garden Physics"})}),"\n",(0,s.jsx)(e.p,{children:"Physics and rendering systems for mathematical knot visualization, Reidemeister move animation, and interactive manipulation via Pin+Pull mechanics."}),"\n",(0,s.jsx)(e.h2,{id:"core-challenge-one-mouse-knot-manipulation",children:"Core Challenge: One-Mouse Knot Manipulation"}),"\n",(0,s.jsxs)(e.p,{children:["Unlike real-world knot manipulation (requiring two hands), mouse/touch interaction provides only ",(0,s.jsx)(e.strong,{children:"one point of contact"}),". This document defines the physics systems that make single-pointer knot manipulation feel natural."]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"pin-constraint-system",children:"Pin Constraint System"}),"\n",(0,s.jsx)(e.h3,{id:"the-problem",children:"The Problem"}),"\n",(0,s.jsx)(e.p,{children:"To untie or manipulate a knot, you need to:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Hold one part steady"}),"\n",(0,s.jsx)(e.li,{children:"Pull another part through/around"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"With one cursor, you can only do one thing at a time."}),"\n",(0,s.jsx)(e.h3,{id:"the-solution-virtual-anchors-pins",children:"The Solution: Virtual Anchors (Pins)"}),"\n",(0,s.jsx)(e.p,{children:'Pins create temporary infinite-mass particles that serve as "your other hand."'}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'/**\n * PinConstraint - A user-placed anchor point on the rope\n *\n * Unlike physical pins (which pierce rope), these are "grip" pins -\n * they hold a section of rope at a fixed world position.\n */\nclass PinConstraint {\n    constructor(particle, worldPosition) {\n        this.particle = particle;\n        this.anchorPosition = worldPosition.clone();\n        this.originalInverseMass = particle.inverseMass;\n\n        // Visual state\n        this.isHovered = false;\n        this.pulsePhase = 0;\n\n        // Pin immediately makes particle immovable\n        particle.inverseMass = 0;\n        particle.predicted.copy(worldPosition);\n        particle.position.copy(worldPosition);\n    }\n\n    /**\n     * Solve: Keep particle at anchor position\n     * Called during constraint solving loop\n     */\n    solve() {\n        this.particle.predicted.copy(this.anchorPosition);\n    }\n\n    /**\n     * Release: Restore original mass, allow movement\n     */\n    release() {\n        this.particle.inverseMass = this.originalInverseMass;\n        // Optionally give a small velocity push away from pin point\n        // to prevent instant re-pinning\n    }\n\n    /**\n     * Move: Drag the pin (and attached rope section)\n     */\n    move(newPosition) {\n        this.anchorPosition.copy(newPosition);\n        this.particle.predicted.copy(newPosition);\n        this.particle.position.copy(newPosition);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"pin-placement-rules",children:"Pin Placement Rules"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Rule"}),(0,s.jsx)(e.th,{children:"Implementation"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Max pins"}),(0,s.jsx)(e.td,{children:'3-5 simultaneous (prevents "stapling" the knot flat)'})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Min distance"}),(0,s.jsx)(e.td,{children:"Pins must be 15+ pixels apart (prevents clustered pins)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Auto-release"}),(0,s.jsx)(e.td,{children:"Pins older than 30 seconds auto-release (prevents forgotten pins)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Visual feedback"}),(0,s.jsx)(e.td,{children:"Pins glow/pulse to remind user they exist"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"pin-interaction-states",children:"Pin Interaction States"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"IDLE \u2192 HOVER \u2192 GRABBED \u2192 DRAGGING \u2192 RELEASED\n  \u2502      \u2502        \u2502          \u2502           \u2502\n  \u2502      \u2502        \u2502          \u2502           \u2514\u2500 Pin stays, particle unfrozen\n  \u2502      \u2502        \u2502          \u2514\u2500 Pin moves with cursor, particle follows\n  \u2502      \u2502        \u2514\u2500 Mouse down on pin, waiting for movement\n  \u2502      \u2514\u2500 Cursor near existing pin\n  \u2514\u2500 Normal rope state\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"pull-mechanics",children:"Pull Mechanics"}),"\n",(0,s.jsx)(e.h3,{id:"the-grabdrag-cycle",children:"The Grab+Drag Cycle"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'/**\n * GrabState - Tracks active user manipulation of rope\n */\nclass GrabState {\n    constructor(particle, grabPoint) {\n        this.particle = particle;\n        this.grabOffset = grabPoint.sub(particle.position); // Where on particle user grabbed\n        this.grabTime = performance.now();\n        this.dragHistory = []; // For velocity calculation on release\n        this.maxDragForce = 500; // Clamp to prevent explosion\n    }\n\n    /**\n     * Update during drag - applies force toward cursor\n     */\n    update(cursorPosition, dt) {\n        const targetPosition = cursorPosition.sub(this.grabOffset);\n        const toTarget = targetPosition.sub(this.particle.position);\n        const distance = toTarget.length;\n\n        // Force scales with distance but is clamped\n        // This gives a "rubbery" feel - close = responsive, far = max pull\n        const forceMagnitude = Math.min(distance * 50, this.maxDragForce);\n        const force = toTarget.normalize().mul(forceMagnitude);\n\n        // Apply as acceleration (will be integrated in physics step)\n        this.particle.applyForce(force);\n\n        // Track for release velocity\n        this.dragHistory.push({ pos: cursorPosition.clone(), time: performance.now() });\n        if (this.dragHistory.length > 10) this.dragHistory.shift();\n    }\n\n    /**\n     * Release - optionally impart velocity from drag motion\n     */\n    release() {\n        if (this.dragHistory.length < 2) return;\n\n        const recent = this.dragHistory.slice(-3);\n        const dt = (recent[recent.length - 1].time - recent[0].time) / 1000;\n        if (dt < 0.001) return;\n\n        const displacement = recent[recent.length - 1].pos.sub(recent[0].pos);\n        const releaseVelocity = displacement.div(dt).mul(0.3); // Damped\n\n        this.particle.velocity.addMut(releaseVelocity);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"pull-behavior-near-pins",children:"Pull Behavior Near Pins"}),"\n",(0,s.jsx)(e.p,{children:"When pulling rope that has pins placed:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    [PIN]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[GRAB]\n         \u2196         \u2197\n           ROPE FLOWS AROUND PIN\n\nPhysics: Rope particles between PIN and GRAB\nslide along their constraints while PIN stays fixed.\nThe PIN acts as a pulley/anchor point.\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * When pulling rope with pins, the pin creates a fulcrum effect\n * Rope slides THROUGH the pin position (pin doesn't move with rope)\n */\nfunction updateRopeWithPins(rope, pins, grabState, dt) {\n    // Standard physics step\n    rope.applyGravity(gravity);\n    for (const particle of rope.particles) {\n        particle.integrate(dt);\n    }\n\n    // Constraint solving\n    for (let iter = 0; iter < SOLVER_ITERATIONS; iter++) {\n        // Distance constraints (rope stays connected)\n        for (const constraint of rope.distanceConstraints) {\n            constraint.solve();\n        }\n\n        // Pin constraints (anchors stay fixed)\n        for (const pin of pins) {\n            pin.solve();\n        }\n\n        // Grab constraint (pulled particle follows cursor)\n        if (grabState) {\n            grabState.particle.predicted.copy(grabState.targetPosition);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"reidemeister-move-visualization",children:"Reidemeister Move Visualization"}),"\n",(0,s.jsx)(e.p,{children:"The three Reidemeister moves are the ONLY operations needed to transform any knot into any equivalent knot. Visualizing them clearly is the educational core of Knot Garden."}),"\n",(0,s.jsx)(e.h3,{id:"move-detection",children:"Move Detection"}),"\n",(0,s.jsx)(e.p,{children:"Before animating a move, we need to detect when the user (or algorithm) is attempting one:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * Reidemeister Move Detector\n * Analyzes rope configuration to identify potential moves\n */\nclass ReidemeisterDetector {\n    /**\n     * Type I: Twist/Untwist\n     * Detects a loop where one strand crosses over itself\n     *\n     *     \u256d\u2500\u256e\n     *     \u2502 \u2502   \u2190 Self-crossing loop\n     *     \u2570\u2500\u253c\u2500\n     *       \u2502\n     */\n    detectTypeI(rope) {\n        const candidates = [];\n\n        // Look for self-crossings within a small window\n        for (let i = 0; i < rope.particles.length - 4; i++) {\n            for (let j = i + 3; j < Math.min(i + 10, rope.particles.length - 1); j++) {\n                const seg1 = { start: rope.particles[i].position, end: rope.particles[i+1].position };\n                const seg2 = { start: rope.particles[j].position, end: rope.particles[j+1].position };\n\n                const intersection = Segment.segmentIntersection(seg1.start, seg1.end, seg2.start, seg2.end);\n\n                if (intersection.intersects) {\n                    // Calculate loop area - small area = tight twist\n                    const loopArea = this.calculateLoopArea(rope.particles.slice(i, j + 2));\n\n                    if (loopArea < TWIST_AREA_THRESHOLD) {\n                        candidates.push({\n                            type: 'I',\n                            startIndex: i,\n                            endIndex: j + 1,\n                            crossingPoint: intersection.point,\n                            loopArea: loopArea,\n                            // Sign: +1 for right-handed twist, -1 for left-handed\n                            sign: this.calculateTwistSign(rope.particles.slice(i, j + 2))\n                        });\n                    }\n                }\n            }\n        }\n\n        return candidates;\n    }\n\n    /**\n     * Type II: Poke/Unpoke\n     * Detects two parallel strands crossing each other twice\n     *\n     *    \u2572    \u2571\n     *     \u2572  \u2571    \u2190 Two crossings that can cancel\n     *      \u2572\u2571\n     *      \u2571\u2572\n     *     \u2571  \u2572\n     *    \u2571    \u2572\n     */\n    detectTypeII(rope1, rope2) {\n        const candidates = [];\n\n        // Find all crossings between the two ropes (or two sections of same rope)\n        const crossings = this.findAllCrossings(rope1, rope2);\n\n        // Look for crossing pairs that could cancel\n        for (let i = 0; i < crossings.length; i++) {\n            for (let j = i + 1; j < crossings.length; j++) {\n                const c1 = crossings[i];\n                const c2 = crossings[j];\n\n                // Crossings must have opposite signs to cancel\n                if (c1.sign === c2.sign) continue;\n\n                // Crossings must be \"adjacent\" (no other crossings between them on either strand)\n                if (!this.areAdjacentCrossings(c1, c2, crossings)) continue;\n\n                // Distance between crossings - closer = easier to unpoke\n                const distance = c1.point.distanceTo(c2.point);\n\n                candidates.push({\n                    type: 'II',\n                    crossing1: c1,\n                    crossing2: c2,\n                    distance: distance,\n                    midpoint: c1.point.add(c2.point).div(2)\n                });\n            }\n        }\n\n        return candidates;\n    }\n\n    /**\n     * Type III: Slide\n     * Detects a strand that can slide over/under a crossing\n     *\n     *      \u2502\n     *    \u2572 \u2502 \u2571\n     *     \u2572\u2502\u2571     \u2190 Third strand can slide across\n     *     \u2571\u2502\u2572\n     *    \u2571 \u2502 \u2572\n     *      \u2502\n     */\n    detectTypeIII(rope1, rope2, rope3) {\n        const candidates = [];\n\n        // Find the crossing between rope1 and rope2\n        const baseCrossing = this.findCrossing(rope1, rope2);\n        if (!baseCrossing) return candidates;\n\n        // Check if rope3 passes near this crossing\n        for (let i = 0; i < rope3.particles.length - 1; i++) {\n            const seg = {\n                start: rope3.particles[i].position,\n                end: rope3.particles[i+1].position\n            };\n\n            const distance = this.pointToSegmentDistance(baseCrossing.point, seg.start, seg.end);\n\n            if (distance < SLIDE_THRESHOLD) {\n                candidates.push({\n                    type: 'III',\n                    baseCrossing: baseCrossing,\n                    slidingSegment: { index: i, rope: rope3 },\n                    distance: distance\n                });\n            }\n        }\n\n        return candidates;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"move-animation-system",children:"Move Animation System"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * Reidemeister Move Animator\n * Smoothly transforms rope configuration to complete a move\n */\nclass ReidemeisterAnimator {\n    constructor(rope, move) {\n        this.rope = rope;\n        this.move = move;\n        this.progress = 0;\n        this.duration = 1.0; // seconds\n        this.startPositions = [];\n        this.targetPositions = [];\n\n        // Capture start state\n        for (const p of rope.particles) {\n            this.startPositions.push(p.position.clone());\n        }\n\n        // Calculate target state based on move type\n        this.calculateTargetPositions();\n    }\n\n    calculateTargetPositions() {\n        switch (this.move.type) {\n            case 'I':\n                this.calculateTypeITarget();\n                break;\n            case 'II':\n                this.calculateTypeIITarget();\n                break;\n            case 'III':\n                this.calculateTypeIIITarget();\n                break;\n        }\n    }\n\n    /**\n     * Type I: Untwist\n     * Pull the loop straight, eliminating the crossing\n     */\n    calculateTypeITarget() {\n        const { startIndex, endIndex } = this.move;\n\n        // Start and end points of the twisted section\n        const startPos = this.startPositions[startIndex];\n        const endPos = this.startPositions[endIndex];\n\n        // Target: straight line between start and end\n        for (let i = 0; i < this.startPositions.length; i++) {\n            if (i < startIndex || i > endIndex) {\n                // Particles outside the twist stay put\n                this.targetPositions[i] = this.startPositions[i].clone();\n            } else {\n                // Particles inside the twist interpolate to straight line\n                const t = (i - startIndex) / (endIndex - startIndex);\n                this.targetPositions[i] = startPos.lerp(endPos, t);\n            }\n        }\n    }\n\n    /**\n     * Type II: Unpoke\n     * Pull the two strands apart, eliminating both crossings\n     */\n    calculateTypeIITarget() {\n        const { crossing1, crossing2 } = this.move;\n\n        // Calculate separation direction (perpendicular to strand direction)\n        const strandDir = crossing2.point.sub(crossing1.point).normalize();\n        const separationDir = new Vec2(-strandDir.y, strandDir.x);\n\n        // Move affected particles away from each other\n        // ... (complex implementation involving both ropes)\n    }\n\n    /**\n     * Update animation\n     * Returns true when complete\n     */\n    update(dt) {\n        this.progress += dt / this.duration;\n\n        if (this.progress >= 1.0) {\n            // Snap to final positions\n            for (let i = 0; i < this.rope.particles.length; i++) {\n                this.rope.particles[i].position.copy(this.targetPositions[i]);\n                this.rope.particles[i].predicted.copy(this.targetPositions[i]);\n                this.rope.particles[i].prevPosition.copy(this.targetPositions[i]);\n            }\n            return true; // Complete\n        }\n\n        // Smooth interpolation with easing\n        const easedProgress = this.easeInOutCubic(this.progress);\n\n        for (let i = 0; i < this.rope.particles.length; i++) {\n            const pos = this.startPositions[i].lerp(this.targetPositions[i], easedProgress);\n            this.rope.particles[i].position.copy(pos);\n            this.rope.particles[i].predicted.copy(pos);\n        }\n\n        return false; // Still animating\n    }\n\n    easeInOutCubic(t) {\n        return t < 0.5\n            ? 4 * t * t * t\n            : 1 - Math.pow(-2 * t + 2, 3) / 2;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"visual-feedback-during-moves",children:"Visual Feedback During Moves"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * Reidemeister Move Visualizer\n * Renders move in progress with educational annotations\n */\nclass ReidemeisterVisualizer {\n    /**\n     * Draw move-in-progress with highlights and labels\n     */\n    render(ctx, animator) {\n        const move = animator.move;\n        const progress = animator.progress;\n\n        // Highlight the affected region\n        this.drawAffectedRegion(ctx, move, progress);\n\n        // Draw crossing indicators\n        if (move.type === 'I') {\n            this.drawTwistIndicator(ctx, move, progress);\n        } else if (move.type === 'II') {\n            this.drawPokeIndicator(ctx, move.crossing1, move.crossing2, progress);\n        } else if (move.type === 'III') {\n            this.drawSlideIndicator(ctx, move, progress);\n        }\n\n        // Label the move type\n        const labelPos = this.getMoveCenter(move);\n        this.drawLabel(ctx, labelPos, `Reidemeister ${move.type}`, progress);\n\n        // Draw crossing count change\n        const crossingDelta = this.getCrossingDelta(move);\n        if (crossingDelta !== 0) {\n            this.drawCrossingChange(ctx, labelPos, crossingDelta, progress);\n        }\n    }\n\n    drawAffectedRegion(ctx, move, progress) {\n        ctx.save();\n\n        // Pulsing highlight\n        const alpha = 0.2 + 0.1 * Math.sin(progress * Math.PI * 4);\n        ctx.fillStyle = `rgba(255, 200, 50, ${alpha})`;\n\n        // Draw circular region around move\n        const center = this.getMoveCenter(move);\n        const radius = this.getMoveRadius(move) * (1.5 - 0.5 * progress);\n\n        ctx.beginPath();\n        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    getCrossingDelta(move) {\n        switch (move.type) {\n            case 'I': return -1;  // Removes 1 crossing\n            case 'II': return -2; // Removes 2 crossings\n            case 'III': return 0; // Crossing count unchanged\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"algorithmic-simplification",children:"Algorithmic Simplification"}),"\n",(0,s.jsx)(e.p,{children:'The "Simplify" button runs an algorithm to reduce the knot to minimal crossing number.'}),"\n",(0,s.jsx)(e.h3,{id:"greedy-simplification",children:"Greedy Simplification"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * Greedy Knot Simplifier\n * Repeatedly applies Reidemeister moves that reduce crossing count\n */\nclass GreedySimplifier {\n    constructor(rope) {\n        this.rope = rope;\n        this.detector = new ReidemeisterDetector();\n        this.animator = null;\n        this.moveQueue = [];\n        this.crossingCount = this.countCrossings();\n    }\n\n    /**\n     * Find all simplifying moves and execute them\n     */\n    async simplify() {\n        let improved = true;\n\n        while (improved) {\n            improved = false;\n\n            // Find Type I moves (always reduce by 1)\n            const typeI = this.detector.detectTypeI(this.rope);\n            for (const move of typeI) {\n                await this.executeMove(move);\n                improved = true;\n            }\n\n            // Find Type II moves (always reduce by 2)\n            const typeII = this.detector.detectTypeII(this.rope, this.rope);\n            for (const move of typeII) {\n                await this.executeMove(move);\n                improved = true;\n            }\n\n            // Type III moves don't change crossing count directly\n            // but may enable Type I or II moves\n            if (!improved) {\n                const typeIII = this.detector.detectTypeIII(this.rope, this.rope, this.rope);\n                if (typeIII.length > 0) {\n                    await this.executeMove(typeIII[0]);\n                    improved = true; // Try again after slide\n                }\n            }\n        }\n\n        return this.crossingCount;\n    }\n\n    async executeMove(move) {\n        return new Promise(resolve => {\n            this.animator = new ReidemeisterAnimator(this.rope, move);\n\n            const animate = () => {\n                const complete = this.animator.update(1/60);\n                if (complete) {\n                    this.crossingCount = this.countCrossings();\n                    this.animator = null;\n                    resolve();\n                } else {\n                    requestAnimationFrame(animate);\n                }\n            };\n\n            requestAnimationFrame(animate);\n        });\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"a-search-for-optimal-simplification",children:"A* Search for Optimal Simplification"}),"\n",(0,s.jsxs)(e.p,{children:["For finding the ",(0,s.jsx)(e.em,{children:"shortest"})," sequence of moves:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * A* Knot Simplifier\n * Finds optimal (shortest) sequence of Reidemeister moves\n *\n * State space: Knot configurations (up to ambient isotopy)\n * Operators: Reidemeister moves (I, II, III)\n * Goal: Minimize crossing number\n * Heuristic: Current crossing count (admissible since each move removes \u22642)\n */\nclass AStarSimplifier {\n    constructor(rope) {\n        this.rope = rope;\n        this.detector = new ReidemeisterDetector();\n    }\n\n    /**\n     * A* search for optimal simplification\n     */\n    findOptimalSequence() {\n        const startState = this.getKnotState();\n        const startCrossings = this.countCrossings(startState);\n\n        // Priority queue: [state, path, g-cost]\n        const frontier = new PriorityQueue((a, b) =>\n            (a.g + a.h) - (b.g + b.h)\n        );\n\n        frontier.push({\n            state: startState,\n            path: [],\n            g: 0,\n            h: startCrossings // Heuristic: crossing count\n        });\n\n        const visited = new Set();\n\n        while (!frontier.isEmpty()) {\n            const current = frontier.pop();\n\n            // Check if goal (unknot = 0 crossings, or local minimum)\n            const crossings = this.countCrossings(current.state);\n            if (crossings === 0) {\n                return current.path; // Found unknot!\n            }\n\n            // Generate canonical representation for visited check\n            const canonical = this.canonicalize(current.state);\n            if (visited.has(canonical)) continue;\n            visited.add(canonical);\n\n            // Expand: try all possible Reidemeister moves\n            const moves = this.getAllMoves(current.state);\n\n            for (const move of moves) {\n                const newState = this.applyMove(current.state, move);\n                const newCrossings = this.countCrossings(newState);\n\n                frontier.push({\n                    state: newState,\n                    path: [...current.path, move],\n                    g: current.g + 1,\n                    h: newCrossings\n                });\n            }\n        }\n\n        // No path to unknot found - knot is non-trivial\n        return null;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"3d-knot-representation",children:"3D Knot Representation"}),"\n",(0,s.jsx)(e.p,{children:"Mathematical knots live in 3D space. Even when rendered on a 2D screen, we need proper 3D handling."}),"\n",(0,s.jsx)(e.h3,{id:"particle-extension-for-3d",children:"Particle Extension for 3D"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * Particle3D - Full 3D position with height/depth\n */\nclass Particle3D extends Particle {\n    constructor(x, y, z, mass = 1.0) {\n        super(x, y, mass);\n        this.z = z;\n        this.prevZ = z;\n        this.predictedZ = z;\n        this.velocityZ = 0;\n    }\n\n    integrate(dt) {\n        super.integrate(dt);\n\n        if (this.inverseMass === 0) {\n            this.predictedZ = this.z;\n            return;\n        }\n\n        // Z-axis velocity from position difference\n        this.velocityZ = (this.z - this.prevZ) / dt;\n        this.velocityZ *= (1.0 - this.damping);\n\n        // Predict new Z\n        this.predictedZ = this.z + this.velocityZ * dt + this.accelerationZ * dt * dt;\n        this.accelerationZ = 0;\n    }\n\n    updatePosition(dt) {\n        super.updatePosition(dt);\n        this.prevZ = this.z;\n        this.z = this.predictedZ;\n        this.velocityZ = (this.z - this.prevZ) / dt;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"distance-constraint-in-3d",children:"Distance Constraint in 3D"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * DistanceConstraint3D - Maintains rest length in full 3D\n */\nclass DistanceConstraint3D {\n    solve() {\n        const dx = this.particleB.predictedX - this.particleA.predictedX;\n        const dy = this.particleB.predictedY - this.particleA.predictedY;\n        const dz = this.particleB.predictedZ - this.particleA.predictedZ;\n\n        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);\n        if (distance < 1e-6) return;\n\n        const error = distance - this.restLength;\n        const wSum = this.particleA.inverseMass + this.particleB.inverseMass;\n        if (wSum < 1e-6) return;\n\n        const factor = (error * this.stiffness) / (distance * wSum);\n\n        const cx = dx * factor;\n        const cy = dy * factor;\n        const cz = dz * factor;\n\n        this.particleA.predictedX += this.particleA.inverseMass * cx;\n        this.particleA.predictedY += this.particleA.inverseMass * cy;\n        this.particleA.predictedZ += this.particleA.inverseMass * cz;\n\n        this.particleB.predictedX -= this.particleB.inverseMass * cx;\n        this.particleB.predictedY -= this.particleB.inverseMass * cy;\n        this.particleB.predictedZ -= this.particleB.inverseMass * cz;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"crossing-detection-in-3d",children:"Crossing Detection in 3D"}),"\n",(0,s.jsx)(e.p,{children:"Determining over/under at crossings is crucial for knot identity."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'/**\n * Crossing3D - Represents a crossing with over/under information\n */\nclass Crossing3D {\n    /**\n     * Detect crossing between two 3D segments\n     * Returns crossing info including which strand is "over"\n     */\n    static detect(seg1Start, seg1End, seg2Start, seg2End) {\n        // Project to XY plane and find 2D intersection\n        const intersection2D = Segment.segmentIntersection(\n            new Vec2(seg1Start.x, seg1Start.y),\n            new Vec2(seg1End.x, seg1End.y),\n            new Vec2(seg2Start.x, seg2Start.y),\n            new Vec2(seg2End.x, seg2End.y)\n        );\n\n        if (!intersection2D.intersects) return null;\n\n        // Interpolate Z at intersection point for both segments\n        const t1 = intersection2D.t1; // Parameter along segment 1\n        const t2 = intersection2D.t2; // Parameter along segment 2\n\n        const z1 = seg1Start.z + t1 * (seg1End.z - seg1Start.z);\n        const z2 = seg2Start.z + t2 * (seg2End.z - seg2Start.z);\n\n        // Positive sign = segment 1 is over segment 2\n        const sign = z1 > z2 ? 1 : -1;\n\n        return {\n            point: intersection2D.point,\n            t1, t2,\n            z1, z2,\n            sign,\n            overSegment: sign > 0 ? 1 : 2\n        };\n    }\n}\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(e.h3,{id:"spatial-hashing-for-collision-detection",children:"Spatial Hashing for Collision Detection"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * SpatialHash - O(1) average case for nearby particle queries\n */\nclass SpatialHash {\n    constructor(cellSize = 20) {\n        this.cellSize = cellSize;\n        this.cells = new Map();\n    }\n\n    hash(x, y) {\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n        return `${cx},${cy}`;\n    }\n\n    insert(particle) {\n        const key = this.hash(particle.position.x, particle.position.y);\n        if (!this.cells.has(key)) this.cells.set(key, []);\n        this.cells.get(key).push(particle);\n    }\n\n    query(x, y, radius) {\n        const results = [];\n        const cellRadius = Math.ceil(radius / this.cellSize);\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n\n        for (let dx = -cellRadius; dx <= cellRadius; dx++) {\n            for (let dy = -cellRadius; dy <= cellRadius; dy++) {\n                const key = `${cx + dx},${cy + dy}`;\n                const cell = this.cells.get(key);\n                if (cell) {\n                    for (const p of cell) {\n                        const dist = Math.sqrt((p.position.x - x)**2 + (p.position.y - y)**2);\n                        if (dist <= radius) results.push(p);\n                    }\n                }\n            }\n        }\n\n        return results;\n    }\n\n    clear() {\n        this.cells.clear();\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"performance-budgets",children:"Performance Budgets"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Component"}),(0,s.jsx)(e.th,{children:"Budget (60fps)"}),(0,s.jsx)(e.th,{children:"Notes"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Physics step"}),(0,s.jsx)(e.td,{children:"4ms"}),(0,s.jsx)(e.td,{children:"8 iterations, ~100 particles"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Reidemeister detection"}),(0,s.jsx)(e.td,{children:"1ms"}),(0,s.jsx)(e.td,{children:"Cached, only recompute on change"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Crossing detection"}),(0,s.jsx)(e.td,{children:"0.5ms"}),(0,s.jsx)(e.td,{children:"Spatial hash"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Render"}),(0,s.jsx)(e.td,{children:"5ms"}),(0,s.jsx)(e.td,{children:"Three.js with LOD"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Total"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"10.5ms"})}),(0,s.jsx)(e.td,{children:"Leaves headroom for GC"})]})]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"integration-with-existing-codebase",children:"Integration with Existing Codebase"}),"\n",(0,s.jsxs)(e.p,{children:["The existing ",(0,s.jsx)(e.code,{children:"physics.js"})," provides solid PBD foundations. Extensions needed:"]}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Existing"}),(0,s.jsx)(e.th,{children:"Extension for Knot Garden"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"Particle"})}),(0,s.jsxs)(e.td,{children:["Add ",(0,s.jsx)(e.code,{children:"z"})," coordinate for 3D"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"DistanceConstraint"})}),(0,s.jsx)(e.td,{children:"3D variant for full knot physics"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"TangleConstraint"})}),(0,s.jsx)(e.td,{children:"Repurpose for mathematical knot crossings"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"Rope"})}),(0,s.jsxs)(e.td,{children:[(0,s.jsx)(e.code,{children:"Knot"})," class with closed-loop support"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"PhysicsWorld"})}),(0,s.jsxs)(e.td,{children:[(0,s.jsx)(e.code,{children:"KnotWorld"})," with Reidemeister detection"]})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"knot-vs-rope-key-difference",children:"Knot vs Rope: Key Difference"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * A Knot is a closed Rope - the ends connect\n */\nclass Knot extends Rope {\n    constructor(knotData, numParticles, options = {}) {\n        // Initialize as open rope first\n        super(knotData.startPos, knotData.endPos, numParticles, options);\n\n        // Add closing constraint (connect last to first)\n        this.closingConstraint = new DistanceConstraint(\n            this.particles[this.particles.length - 1],\n            this.particles[0],\n            this.distanceConstraints[0].restLength, // Same as other segments\n            1.0\n        );\n    }\n\n    // Override to include closing constraint\n    get distanceConstraints() {\n        return [...super.distanceConstraints, this.closingConstraint];\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"System"}),(0,s.jsx)(e.th,{children:"Purpose"}),(0,s.jsx)(e.th,{children:"Key Classes"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Pin Constraints"})}),(0,s.jsx)(e.td,{children:"Virtual anchors for one-hand manipulation"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"PinConstraint"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Pull Mechanics"})}),(0,s.jsx)(e.td,{children:"Responsive grab-and-drag"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"GrabState"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Reidemeister Detection"})}),(0,s.jsx)(e.td,{children:"Find simplifying moves"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"ReidemeisterDetector"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Move Animation"})}),(0,s.jsx)(e.td,{children:"Smooth visualization of moves"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"ReidemeisterAnimator"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Simplification"})}),(0,s.jsx)(e.td,{children:"Reduce to minimal crossings"}),(0,s.jsxs)(e.td,{children:[(0,s.jsx)(e.code,{children:"GreedySimplifier"}),", ",(0,s.jsx)(e.code,{children:"AStarSimplifier"})]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"3D Representation"})}),(0,s.jsx)(e.td,{children:"True spatial knot physics"}),(0,s.jsxs)(e.td,{children:[(0,s.jsx)(e.code,{children:"Particle3D"}),", ",(0,s.jsx)(e.code,{children:"Crossing3D"})]})]})]})]}),"\n",(0,s.jsx)(e.p,{children:"The physics of Knot Garden transforms abstract topology into tangible, playful interaction."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);