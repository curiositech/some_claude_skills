"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[13503],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(96540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}},31103:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"skills/cloudflare_worker_dev/index","title":"\u2699\ufe0f Cloudflare Worker Dev","description":"Cloudflare Workers, KV, Durable Objects, and edge computing development. Use for serverless APIs, caching, rate limiting, real-time features. Activate on \\"Workers\\", \\"KV\\", \\"Durable Objects\\", \\"wrangler\\", \\"edge function\\", \\"Cloudflare\\". NOT for Cloudflare Pages configuration (use deployment docs), DNS management, or general CDN settings.","source":"@site/docs/skills/cloudflare_worker_dev/index.md","sourceDirName":"skills/cloudflare_worker_dev","slug":"/skills/cloudflare_worker_dev/","permalink":"/docs/skills/cloudflare_worker_dev/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Cloudflare Worker Dev","sidebar_position":1}}');var s=t(74848),a=t(28453);const i={sidebar_label:"Cloudflare Worker Dev",sidebar_position:1},o="\u2699\ufe0f Cloudflare Worker Dev",l={},c=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"Core Architecture",id:"core-architecture",level:2},{value:"When to Use What",id:"when-to-use-what",level:3},{value:"Worker Fundamentals",id:"worker-fundamentals",level:2},{value:"Basic Worker Structure",id:"basic-worker-structure",level:3},{value:"CORS Headers (Essential)",id:"cors-headers-essential",level:3},{value:"wrangler.toml Configuration",id:"wranglertoml-configuration",level:3},{value:"KV Storage Patterns",id:"kv-storage-patterns",level:2},{value:"Basic KV Operations",id:"basic-kv-operations",level:3},{value:"Geohash-Based Caching",id:"geohash-based-caching",level:3},{value:"Response Headers for Cache Debugging",id:"response-headers-for-cache-debugging",level:3},{value:"Rate Limiting",id:"rate-limiting",level:2},{value:"IP-Based Rate Limiting",id:"ip-based-rate-limiting",level:3},{value:"Durable Objects (Real-Time)",id:"durable-objects-real-time",level:2},{value:"Chat Room Example",id:"chat-room-example",level:3},{value:"Deployment &amp; Debugging",id:"deployment--debugging",level:2},{value:"Commands",id:"commands",level:3},{value:"Error Codes",id:"error-codes",level:3},{value:"Quick Reference",id:"quick-reference",level:2},{value:"Anti-Patterns",id:"anti-patterns",level:2},{value:"\u274c Awaiting KV writes in hot path",id:"-awaiting-kv-writes-in-hot-path",level:3},{value:"\u274c Missing CORS handling",id:"-missing-cors-handling",level:3},{value:"\u274c Secrets in wrangler.toml",id:"-secrets-in-wranglertoml",level:3},{value:"\u274c Ignoring KV eventual consistency",id:"-ignoring-kv-eventual-consistency",level:3},{value:"\u274c Blocking on external APIs without timeout",id:"-blocking-on-external-apis-without-timeout",level:3},{value:"References",id:"references",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"\ufe0f-cloudflare-worker-dev",children:"\u2699\ufe0f Cloudflare Worker Dev"})}),"\n",(0,s.jsx)(n.p,{children:'Cloudflare Workers, KV, Durable Objects, and edge computing development. Use for serverless APIs, caching, rate limiting, real-time features. Activate on "Workers", "KV", "Durable Objects", "wrangler", "edge function", "Cloudflare". NOT for Cloudflare Pages configuration (use deployment docs), DNS management, or general CDN settings.'}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Read, Write, Edit, Bash, Grep, Glob\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"cloudflare"})," ",(0,s.jsx)(n.code,{children:"workers"})," ",(0,s.jsx)(n.code,{children:"edge-computing"})," ",(0,s.jsx)(n.code,{children:"serverless"})," ",(0,s.jsx)(n.code,{children:"kv"})," ",(0,s.jsx)(n.code,{children:"caching"})," ",(0,s.jsx)(n.code,{children:"rate-limiting"})]}),"\n",(0,s.jsx)(n.h1,{id:"cloudflare-workers-development",children:"Cloudflare Workers Development"}),"\n",(0,s.jsx)(n.p,{children:"Build high-performance edge APIs with Workers, KV for caching, and Durable Objects for real-time coordination."}),"\n",(0,s.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-what",children:"When to Use What"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Service"}),(0,s.jsx)(n.th,{children:"Use Case"}),(0,s.jsx)(n.th,{children:"Characteristics"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Workers"})}),(0,s.jsx)(n.td,{children:"Request handling, API logic"}),(0,s.jsx)(n.td,{children:"Stateless, 50ms CPU (free), 30s (paid)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"KV"})}),(0,s.jsx)(n.td,{children:"Caching, config, sessions"}),(0,s.jsx)(n.td,{children:"Eventually consistent, fast reads"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Durable Objects"})}),(0,s.jsx)(n.td,{children:"Real-time, coordination"}),(0,s.jsx)(n.td,{children:"Strongly consistent, single-threaded"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"R2"})}),(0,s.jsx)(n.td,{children:"File storage"}),(0,s.jsx)(n.td,{children:"S3-compatible, no egress fees"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"D1"})}),(0,s.jsx)(n.td,{children:"SQLite at edge"}),(0,s.jsx)(n.td,{children:"Serverless SQL, good for reads"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"worker-fundamentals",children:"Worker Fundamentals"}),"\n",(0,s.jsx)(n.h3,{id:"basic-worker-structure",children:"Basic Worker Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/index.ts\nexport interface Env {\n  MEETING_CACHE: KVNamespace;\n  RATE_LIMIT: KVNamespace;\n  API_KEY: string;\n}\n\nexport default {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    const url = new URL(request.url);\n\n    // CORS handling\n    if (request.method === 'OPTIONS') {\n      return handleCORS();\n    }\n\n    try {\n      // Route handling\n      if (url.pathname === '/health') {\n        return json({ status: 'ok' });\n      }\n\n      if (url.pathname.startsWith('/api/')) {\n        return handleAPI(request, env, ctx);\n      }\n\n      return new Response('Not Found', { status: 404 });\n    } catch (error) {\n      console.error('Worker error:', error);\n      return json({ error: 'Internal error' }, 500);\n    }\n  },\n\n  // Cron trigger\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    ctx.waitUntil(runScheduledTask(env));\n  }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cors-headers-essential",children:"CORS Headers (Essential)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const CORS_HEADERS = {\n  'Access-Control-Allow-Origin': '*', // Or specific origin\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n  'Access-Control-Max-Age': '86400',\n};\n\nfunction handleCORS(): Response {\n  return new Response(null, { status: 204, headers: CORS_HEADERS });\n}\n\nfunction json(data: unknown, status = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      ...CORS_HEADERS,\n      'Content-Type': 'application/json',\n    },\n  });\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"wranglertoml-configuration",children:"wrangler.toml Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'name = "my-worker"\nmain = "src/index.ts"\ncompatibility_date = "2024-01-01"\n\n# KV Namespaces\n[[kv_namespaces]]\nbinding = "MEETING_CACHE"\nid = "abc123..."  # Production\npreview_id = "def456..."  # Dev\n\n[[kv_namespaces]]\nbinding = "RATE_LIMIT"\nid = "ghi789..."\n\n# Environment variables\n[vars]\nCACHE_TTL = "86400"\nRATE_LIMIT_REQUESTS = "100"\nRATE_LIMIT_WINDOW = "3600"\n\n# Secrets (set via `wrangler secret put`)\n# API_KEY, DATABASE_URL, etc.\n\n# Cron triggers\n[triggers]\ncrons = ["0 */6 * * *"]  # Every 6 hours\n\n# Custom routes\n# routes = [{ pattern = "api.example.com/*", zone_name = "example.com" }]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"kv-storage-patterns",children:"KV Storage Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"basic-kv-operations",children:"Basic KV Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Write with TTL\nawait env.CACHE.put('key', JSON.stringify(data), {\n  expirationTtl: 86400, // 24 hours in seconds\n});\n\n// Write with metadata\nawait env.CACHE.put('key', value, {\n  expirationTtl: 3600,\n  metadata: { createdAt: Date.now(), source: 'api' },\n});\n\n// Read\nconst value = await env.CACHE.get('key');\nconst parsed = await env.CACHE.get('key', 'json');\n\n// Read with metadata\nconst { value, metadata } = await env.CACHE.getWithMetadata('key', 'json');\n\n// Delete\nawait env.CACHE.delete('key');\n\n// List keys\nconst { keys, cursor } = await env.CACHE.list({ prefix: 'meetings:' });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"geohash-based-caching",children:"Geohash-Based Caching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import Geohash from 'latlon-geohash';\n\nfunction getCacheKey(lat: number, lng: number, radius: number): string {\n  // 3-char geohash = ~150km cells, good for metro areas\n  const geohash = Geohash.encode(lat, lng, 3);\n  return `meetings:${geohash}:${radius}`;\n}\n\nasync function getMeetingsWithCache(\n  lat: number,\n  lng: number,\n  radius: number,\n  env: Env\n): Promise<{ data: Meeting[]; cached: boolean; geohash: string }> {\n  const geohash = Geohash.encode(lat, lng, 3);\n  const cacheKey = `meetings:${geohash}:${radius}`;\n\n  // Try cache first\n  const cached = await env.MEETING_CACHE.get(cacheKey, 'json');\n  if (cached) {\n    return { data: cached, cached: true, geohash };\n  }\n\n  // Fetch fresh data\n  const data = await fetchMeetings(lat, lng, radius);\n\n  // Cache in background (don't await)\n  env.ctx.waitUntil(\n    env.MEETING_CACHE.put(cacheKey, JSON.stringify(data), {\n      expirationTtl: 86400,\n      metadata: { cachedAt: Date.now(), geohash },\n    })\n  );\n\n  return { data, cached: false, geohash };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"response-headers-for-cache-debugging",children:"Response Headers for Cache Debugging"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function meetingsResponse(data: Meeting[], cached: boolean, geohash: string): Response {\n  return new Response(JSON.stringify(data), {\n    headers: {\n      ...CORS_HEADERS,\n      'Content-Type': 'application/json',\n      'X-Cache': cached ? 'HIT' : 'MISS',\n      'X-Geohash': geohash,\n      'Cache-Control': 'public, max-age=3600',\n    },\n  });\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,s.jsx)(n.h3,{id:"ip-based-rate-limiting",children:"IP-Based Rate Limiting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface RateLimitConfig {\n  maxRequests: number;\n  windowSeconds: number;\n}\n\nasync function checkRateLimit(\n  ip: string,\n  env: Env,\n  config: RateLimitConfig\n): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {\n  const key = `rate:${ip}`;\n  const now = Math.floor(Date.now() / 1000);\n  const windowStart = now - config.windowSeconds;\n\n  // Get current state\n  const stored = await env.RATE_LIMIT.get(key, 'json') as {\n    count: number;\n    windowStart: number;\n  } | null;\n\n  // New window or expired\n  if (!stored || stored.windowStart < windowStart) {\n    await env.RATE_LIMIT.put(key, JSON.stringify({\n      count: 1,\n      windowStart: now,\n    }), { expirationTtl: config.windowSeconds });\n\n    return {\n      allowed: true,\n      remaining: config.maxRequests - 1,\n      resetAt: now + config.windowSeconds,\n    };\n  }\n\n  // Within window\n  if (stored.count >= config.maxRequests) {\n    return {\n      allowed: false,\n      remaining: 0,\n      resetAt: stored.windowStart + config.windowSeconds,\n    };\n  }\n\n  // Increment\n  await env.RATE_LIMIT.put(key, JSON.stringify({\n    count: stored.count + 1,\n    windowStart: stored.windowStart,\n  }), { expirationTtl: config.windowSeconds });\n\n  return {\n    allowed: true,\n    remaining: config.maxRequests - stored.count - 1,\n    resetAt: stored.windowStart + config.windowSeconds,\n  };\n}\n\n// Usage in handler\nasync function handleAPI(request: Request, env: Env): Promise<Response> {\n  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';\n  const rateLimit = await checkRateLimit(ip, env, {\n    maxRequests: parseInt(env.RATE_LIMIT_REQUESTS || '100'),\n    windowSeconds: parseInt(env.RATE_LIMIT_WINDOW || '3600'),\n  });\n\n  if (!rateLimit.allowed) {\n    return json({ error: 'Rate limit exceeded' }, 429, {\n      'X-RateLimit-Remaining': '0',\n      'X-RateLimit-Reset': rateLimit.resetAt.toString(),\n    });\n  }\n\n  // ... handle request\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"durable-objects-real-time",children:"Durable Objects (Real-Time)"}),"\n",(0,s.jsx)(n.h3,{id:"chat-room-example",children:"Chat Room Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// wrangler.toml\n// [[durable_objects.bindings]]\n// name = \"CHAT_ROOMS\"\n// class_name = \"ChatRoom\"\n// [[migrations]]\n// tag = \"v1\"\n// new_classes = [\"ChatRoom\"]\n\nexport class ChatRoom {\n  state: DurableObjectState;\n  sessions: WebSocket[] = [];\n\n  constructor(state: DurableObjectState) {\n    this.state = state;\n  }\n\n  async fetch(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n\n    if (url.pathname === '/websocket') {\n      if (request.headers.get('Upgrade') !== 'websocket') {\n        return new Response('Expected WebSocket', { status: 400 });\n      }\n\n      const [client, server] = Object.values(new WebSocketPair());\n\n      server.accept();\n      this.sessions.push(server);\n\n      server.addEventListener('message', (event) => {\n        this.broadcast(event.data as string, server);\n      });\n\n      server.addEventListener('close', () => {\n        this.sessions = this.sessions.filter(s => s !== server);\n      });\n\n      return new Response(null, { status: 101, webSocket: client });\n    }\n\n    return new Response('Not found', { status: 404 });\n  }\n\n  broadcast(message: string, exclude?: WebSocket) {\n    this.sessions.forEach(session => {\n      if (session !== exclude && session.readyState === WebSocket.OPEN) {\n        session.send(message);\n      }\n    });\n  }\n}\n\n// In main worker\nexport default {\n  async fetch(request: Request, env: Env) {\n    const url = new URL(request.url);\n\n    if (url.pathname.startsWith('/room/')) {\n      const roomId = url.pathname.split('/')[2];\n      const id = env.CHAT_ROOMS.idFromName(roomId);\n      const room = env.CHAT_ROOMS.get(id);\n      return room.fetch(request);\n    }\n  }\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"deployment--debugging",children:"Deployment & Debugging"}),"\n",(0,s.jsx)(n.h3,{id:"commands",children:"Commands"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Development\nnpx wrangler dev                    # Local dev server\nnpx wrangler dev --remote           # Dev against real KV/DO\n\n# Deployment\nnpx wrangler deploy                 # Deploy to production\nnpx wrangler deploy --env staging   # Deploy to staging\n\n# Secrets\nnpx wrangler secret put API_KEY     # Set secret\nnpx wrangler secret list            # List secrets\n\n# KV Management\nnpx wrangler kv:key list --namespace-id=xxx\nnpx wrangler kv:key get --namespace-id=xxx "key"\nnpx wrangler kv:key delete --namespace-id=xxx "key"\n\n# Logs\nnpx wrangler tail                   # Real-time logs\nnpx wrangler tail --format=pretty   # Formatted output\n'})}),"\n",(0,s.jsx)(n.h3,{id:"error-codes",children:"Error Codes"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Code"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1101"}),(0,s.jsx)(n.td,{children:"Worker threw exception"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1102"}),(0,s.jsx)(n.td,{children:"CPU time limit exceeded"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1015"}),(0,s.jsx)(n.td,{children:"Rate limited by Cloudflare"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"524"}),(0,s.jsx)(n.td,{children:"Origin timeout (>100s)"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get client IP\nconst ip = request.headers.get('CF-Connecting-IP');\n\n// Get country\nconst country = request.cf?.country;\n\n// Background task (won't block response)\nctx.waitUntil(doBackgroundWork());\n\n// Streaming response\nreturn new Response(readableStream, {\n  headers: { 'Content-Type': 'text/event-stream' }\n});\n\n// Proxy request\nconst response = await fetch(upstreamUrl, request);\nreturn new Response(response.body, response);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"anti-patterns",children:"Anti-Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"-awaiting-kv-writes-in-hot-path",children:"\u274c Awaiting KV writes in hot path"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c ANTI-PATTERN: Blocks response on cache write\nasync function handler(request: Request, env: Env) {\n  const data = await fetchData();\n  await env.CACHE.put('key', data);  // Unnecessary wait!\n  return json(data);\n}\n\n// \u2705 CORRECT: Background write with waitUntil\nasync function handler(request: Request, env: Env, ctx: ExecutionContext) {\n  const data = await fetchData();\n  ctx.waitUntil(env.CACHE.put('key', data));  // Non-blocking\n  return json(data);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"-missing-cors-handling",children:"\u274c Missing CORS handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c ANTI-PATTERN: No preflight handling = broken browser requests\nexport default {\n  async fetch(request: Request) {\n    return json({ data: 'hello' });  // OPTIONS requests fail!\n  }\n}\n\n// \u2705 CORRECT: Handle OPTIONS preflight\nexport default {\n  async fetch(request: Request) {\n    if (request.method === 'OPTIONS') {\n      return new Response(null, { status: 204, headers: CORS_HEADERS });\n    }\n    return json({ data: 'hello' });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"-secrets-in-wranglertoml",children:"\u274c Secrets in wrangler.toml"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'# \u274c ANTI-PATTERN: Secrets in config (committed to git!)\n[vars]\nAPI_KEY = "sk-live-xxxxx"\n\n# \u2705 CORRECT: Use wrangler secret\n# Run: npx wrangler secret put API_KEY\n# Access: env.API_KEY\n'})}),"\n",(0,s.jsx)(n.h3,{id:"-ignoring-kv-eventual-consistency",children:"\u274c Ignoring KV eventual consistency"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c ANTI-PATTERN: Read immediately after write\nawait env.KV.put('count', String(newCount));\nconst verify = await env.KV.get('count');  // May return old value!\n\n// \u2705 CORRECT: Trust write succeeded, or use Durable Objects for consistency\nawait env.KV.put('count', String(newCount));\nreturn json({ count: newCount });  // Return what you wrote\n"})}),"\n",(0,s.jsx)(n.h3,{id:"-blocking-on-external-apis-without-timeout",children:"\u274c Blocking on external APIs without timeout"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u274c ANTI-PATTERN: External API can hang your worker\nconst data = await fetch('https://slow-api.com/data');\n\n// \u2705 CORRECT: Add timeout with AbortController\nconst controller = new AbortController();\nconst timeout = setTimeout(() => controller.abort(), 5000);\ntry {\n  const data = await fetch('https://slow-api.com/data', {\n    signal: controller.signal\n  });\n} finally {\n  clearTimeout(timeout);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"/references/"})," for detailed guides:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kv-patterns.md"})," - Advanced KV usage patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"durable-objects.md"})," - Real-time features with DO"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"debugging.md"})," - Troubleshooting common issues"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);