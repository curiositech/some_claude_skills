"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[27780],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>s});var t=i(96540);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}},37842:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"skills/dag_failure_analyzer/index","title":"\ud83d\udce6 Dag Failure Analyzer","description":"Performs root cause analysis on DAG execution failures. Traces failure propagation, identifies systemic issues, and generates actionable remediation guidance. Activate on \'failure analysis\', \'root cause\', \'why did it fail\', \'debug failure\', \'error investigation\'. NOT for execution tracing (use dag-execution-tracer) or performance issues (use dag-performance-profiler).","source":"@site/docs/skills/dag_failure_analyzer/index.md","sourceDirName":"skills/dag_failure_analyzer","slug":"/skills/dag_failure_analyzer/","permalink":"/docs/skills/dag_failure_analyzer/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Failure Analyzer","sidebar_position":1}}');var r=i(74848),a=i(28453);const o={sidebar_label:"Dag Failure Analyzer",sidebar_position:1},s="\ud83d\udce6 Dag Failure Analyzer",c={},d=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Failure Classification",id:"1-failure-classification",level:3},{value:"2. Propagation Analysis",id:"2-propagation-analysis",level:3},{value:"3. Root Cause Identification",id:"3-root-cause-identification",level:3},{value:"4. Remediation Guidance",id:"4-remediation-guidance",level:3},{value:"Failure Analysis Architecture",id:"failure-analysis-architecture",level:2},{value:"Failure Detection",id:"failure-detection",level:2},{value:"Propagation Analysis",id:"propagation-analysis",level:2},{value:"Root Cause Analysis",id:"root-cause-analysis",level:2},{value:"Remediation Planning",id:"remediation-planning",level:2},{value:"Failure Report",id:"failure-report",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"-dag-failure-analyzer",children:"\ud83d\udce6 Dag Failure Analyzer"})}),"\n",(0,r.jsx)(n.p,{children:"Performs root cause analysis on DAG execution failures. Traces failure propagation, identifies systemic issues, and generates actionable remediation guidance. Activate on 'failure analysis', 'root cause', 'why did it fail', 'debug failure', 'error investigation'. NOT for execution tracing (use dag-execution-tracer) or performance issues (use dag-performance-profiler)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"dag"})," ",(0,r.jsx)(n.code,{children:"observability"})," ",(0,r.jsx)(n.code,{children:"debugging"})," ",(0,r.jsx)(n.code,{children:"failures"})," ",(0,r.jsx)(n.code,{children:"root-cause"})]}),"\n",(0,r.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_execution_tracer",children:"Dag Execution Tracer"})}),": Uses execution traces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_performance_profiler",children:"Dag Performance Profiler"})}),": Correlates with performance data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_pattern_learner",children:"Dag Pattern Learner"})}),": Provides failure patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_dynamic_replanner",children:"Dag Dynamic Replanner"})}),": Informs recovery strategies"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You are a DAG Failure Analyzer, an expert at performing root cause analysis on DAG execution failures. You trace failure propagation through the graph, identify systemic issues versus transient errors, classify failure types, and generate actionable remediation guidance."}),"\n",(0,r.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,r.jsx)(n.h3,{id:"1-failure-classification",children:"1. Failure Classification"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Categorize failure types"}),"\n",(0,r.jsx)(n.li,{children:"Distinguish root cause from symptoms"}),"\n",(0,r.jsx)(n.li,{children:"Identify transient vs systemic failures"}),"\n",(0,r.jsx)(n.li,{children:"Assess failure severity"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-propagation-analysis",children:"2. Propagation Analysis"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Trace failure through graph"}),"\n",(0,r.jsx)(n.li,{children:"Identify cascade patterns"}),"\n",(0,r.jsx)(n.li,{children:"Find failure boundaries"}),"\n",(0,r.jsx)(n.li,{children:"Map impact scope"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-root-cause-identification",children:"3. Root Cause Identification"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Analyze failure context"}),"\n",(0,r.jsx)(n.li,{children:"Correlate with execution data"}),"\n",(0,r.jsx)(n.li,{children:"Identify contributing factors"}),"\n",(0,r.jsx)(n.li,{children:"Determine primary cause"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-remediation-guidance",children:"4. Remediation Guidance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Generate actionable fixes"}),"\n",(0,r.jsx)(n.li,{children:"Suggest retry strategies"}),"\n",(0,r.jsx)(n.li,{children:"Recommend preventive measures"}),"\n",(0,r.jsx)(n.li,{children:"Prioritize by impact"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"failure-analysis-architecture",children:"Failure Analysis Architecture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FailureAnalysis {\n  analysisId: string;\n  traceId: string;\n  dagId: string;\n  analyzedAt: Date;\n  rootCause: RootCause;\n  propagation: FailurePropagation;\n  classification: FailureClassification;\n  context: FailureContext;\n  remediation: RemediationPlan;\n}\n\ninterface RootCause {\n  nodeId: NodeId;\n  type: FailureType;\n  description: string;\n  confidence: number;  // 0-1\n  evidence: Evidence[];\n  contributingFactors: ContributingFactor[];\n}\n\ntype FailureType =\n  | 'tool_error'           // Tool execution failed\n  | 'timeout'              // Execution exceeded time limit\n  | 'resource_exhaustion'  // Tokens, memory, etc.\n  | 'validation_failure'   // Output didn't meet schema\n  | 'dependency_failure'   // Upstream node failed\n  | 'permission_denied'    // Insufficient permissions\n  | 'external_service'     // External API/service error\n  | 'logic_error'          // Bug in skill logic\n  | 'data_error'           // Invalid input data\n  | 'configuration_error'  // Misconfiguration\n  | 'unknown';\n\ninterface FailureClassification {\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  impact: ImpactAssessment;\n  recoverability: 'automatic' | 'manual' | 'impossible';\n  frequency: 'isolated' | 'intermittent' | 'systemic';\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"failure-detection",children:"Failure Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FailedNode {\n  nodeId: NodeId;\n  spanId: SpanId;\n  error: TaskError;\n  context: NodeExecutionContext;\n  timing: TimingInfo;\n}\n\nfunction extractFailedNodes(trace: ExecutionTrace): FailedNode[] {\n  const failedNodes: FailedNode[] = [];\n\n  for (const [spanId, span] of trace.spans) {\n    if (span.status.code === 'ERROR') {\n      failedNodes.push({\n        nodeId: span.nodeId,\n        spanId,\n        error: parseError(span.status.message, span.attributes),\n        context: extractNodeContext(span, trace),\n        timing: {\n          startTime: span.startTime,\n          endTime: span.endTime,\n          duration: span.duration,\n        },\n      });\n    }\n  }\n\n  return failedNodes;\n}\n\nfunction parseError(\n  message: string,\n  attributes: Record<string, unknown>\n): TaskError {\n  // Extract structured error info\n  const errorPatterns: Array<{\n    pattern: RegExp;\n    type: FailureType;\n    extractor: (match: RegExpMatchArray) => Record<string, unknown>;\n  }> = [\n    {\n      pattern: /timeout after (\\d+)ms/i,\n      type: 'timeout',\n      extractor: (m) => ({ timeoutMs: parseInt(m[1]) }),\n    },\n    {\n      pattern: /permission denied: (.+)/i,\n      type: 'permission_denied',\n      extractor: (m) => ({ deniedResource: m[1] }),\n    },\n    {\n      pattern: /tool \"(.+)\" failed: (.+)/i,\n      type: 'tool_error',\n      extractor: (m) => ({ tool: m[1], toolError: m[2] }),\n    },\n    {\n      pattern: /validation failed: (.+)/i,\n      type: 'validation_failure',\n      extractor: (m) => ({ validationError: m[1] }),\n    },\n    {\n      pattern: /token limit exceeded/i,\n      type: 'resource_exhaustion',\n      extractor: () => ({ resource: 'tokens' }),\n    },\n    {\n      pattern: /external service error: (.+)/i,\n      type: 'external_service',\n      extractor: (m) => ({ service: m[1] }),\n    },\n  ];\n\n  for (const { pattern, type, extractor } of errorPatterns) {\n    const match = message.match(pattern);\n    if (match) {\n      return {\n        type,\n        message,\n        details: extractor(match),\n        stack: attributes['error.stack'] as string | undefined,\n      };\n    }\n  }\n\n  return {\n    type: 'unknown',\n    message,\n    details: {},\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"propagation-analysis",children:"Propagation Analysis"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FailurePropagation {\n  originNode: NodeId;\n  affectedNodes: NodeId[];\n  propagationPath: PropagationStep[];\n  cascadeDepth: number;\n  containmentBoundary?: NodeId[];\n}\n\ninterface PropagationStep {\n  fromNode: NodeId;\n  toNode: NodeId;\n  propagationType: 'direct_dependency' | 'shared_resource' | 'timeout_cascade';\n  timestamp: Date;\n}\n\nfunction analyzeFailurePropagation(\n  failedNodes: FailedNode[],\n  dag: DAG,\n  trace: ExecutionTrace\n): FailurePropagation {\n  // Sort by failure time to find origin\n  const sortedByTime = [...failedNodes].sort(\n    (a, b) => a.timing.startTime.getTime() - b.timing.startTime.getTime()\n  );\n\n  const originNode = sortedByTime[0].nodeId;\n  const affectedNodes: NodeId[] = [];\n  const propagationPath: PropagationStep[] = [];\n\n  // Build dependency graph for analysis\n  const dependents = buildDependentsMap(dag);\n\n  // Trace propagation from origin\n  const visited = new Set<NodeId>();\n  const queue: Array<{ node: NodeId; from?: NodeId }> = [{ node: originNode }];\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n\n    if (visited.has(current.node)) continue;\n    visited.add(current.node);\n\n    // Check if this node failed\n    const failedNode = failedNodes.find(f => f.nodeId === current.node);\n    if (failedNode && current.from) {\n      affectedNodes.push(current.node);\n      propagationPath.push({\n        fromNode: current.from,\n        toNode: current.node,\n        propagationType: determinePropagationType(current.from, current.node, dag),\n        timestamp: failedNode.timing.startTime,\n      });\n    }\n\n    // Add dependents to queue\n    const nodeDependent = dependents.get(current.node) ?? [];\n    for (const dependent of nodeDependent) {\n      queue.push({ node: dependent, from: current.node });\n    }\n  }\n\n  return {\n    originNode,\n    affectedNodes,\n    propagationPath,\n    cascadeDepth: calculateCascadeDepth(propagationPath),\n    containmentBoundary: findContainmentBoundary(dag, visited),\n  };\n}\n\nfunction buildDependentsMap(dag: DAG): Map<NodeId, NodeId[]> {\n  const dependents = new Map<NodeId, NodeId[]>();\n\n  for (const [nodeId, node] of dag.nodes) {\n    for (const dep of node.dependencies) {\n      const existing = dependents.get(dep) ?? [];\n      existing.push(nodeId);\n      dependents.set(dep, existing);\n    }\n  }\n\n  return dependents;\n}\n\nfunction determinePropagationType(\n  from: NodeId,\n  to: NodeId,\n  dag: DAG\n): PropagationStep['propagationType'] {\n  const toNode = dag.nodes.get(to);\n  if (toNode?.dependencies.includes(from)) {\n    return 'direct_dependency';\n  }\n  return 'shared_resource';\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"root-cause-analysis",children:"Root Cause Analysis"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Evidence {\n  type: 'error_message' | 'timing' | 'resource_usage' | 'pattern_match';\n  source: string;\n  observation: string;\n  weight: number;  // How strongly this supports the conclusion\n}\n\ninterface ContributingFactor {\n  factor: string;\n  contribution: number;  // 0-1\n  evidence: Evidence[];\n}\n\nfunction identifyRootCause(\n  propagation: FailurePropagation,\n  failedNodes: FailedNode[],\n  trace: ExecutionTrace,\n  history?: FailureHistory\n): RootCause {\n  const originFailure = failedNodes.find(\n    f => f.nodeId === propagation.originNode\n  )!;\n\n  const evidence: Evidence[] = [];\n  const contributingFactors: ContributingFactor[] = [];\n\n  // Evidence from error message\n  evidence.push({\n    type: 'error_message',\n    source: 'primary_error',\n    observation: originFailure.error.message,\n    weight: 0.9,\n  });\n\n  // Evidence from timing\n  if (originFailure.timing.duration && originFailure.timing.duration > 30000) {\n    evidence.push({\n      type: 'timing',\n      source: 'execution_duration',\n      observation: `Node ran for ${originFailure.timing.duration}ms before failing`,\n      weight: 0.6,\n    });\n  }\n\n  // Evidence from resource usage\n  const resourceUsage = extractResourceUsage(originFailure.context);\n  if (resourceUsage.tokensUsed > resourceUsage.tokenLimit * 0.9) {\n    evidence.push({\n      type: 'resource_usage',\n      source: 'token_usage',\n      observation: `Used ${resourceUsage.tokensUsed}/${resourceUsage.tokenLimit} tokens (${((resourceUsage.tokensUsed / resourceUsage.tokenLimit) * 100).toFixed(0)}%)`,\n      weight: 0.7,\n    });\n  }\n\n  // Check for pattern matches from history\n  if (history) {\n    const matchingPatterns = findMatchingPatterns(originFailure, history);\n    for (const pattern of matchingPatterns) {\n      evidence.push({\n        type: 'pattern_match',\n        source: 'failure_history',\n        observation: `Matches known pattern: ${pattern.name} (seen ${pattern.occurrences} times)`,\n        weight: 0.8,\n      });\n    }\n  }\n\n  // Analyze contributing factors\n  contributingFactors.push(...analyzeContributingFactors(\n    originFailure,\n    trace,\n    evidence\n  ));\n\n  // Calculate confidence based on evidence\n  const confidence = calculateConfidence(evidence, contributingFactors);\n\n  return {\n    nodeId: propagation.originNode,\n    type: originFailure.error.type,\n    description: generateRootCauseDescription(originFailure, evidence),\n    confidence,\n    evidence,\n    contributingFactors,\n  };\n}\n\nfunction analyzeContributingFactors(\n  failure: FailedNode,\n  trace: ExecutionTrace,\n  evidence: Evidence[]\n): ContributingFactor[] {\n  const factors: ContributingFactor[] = [];\n\n  // Check for high load (many concurrent nodes)\n  const concurrentNodes = countConcurrentNodes(trace, failure.timing.startTime);\n  if (concurrentNodes > 5) {\n    factors.push({\n      factor: 'High concurrent load',\n      contribution: Math.min(0.3, concurrentNodes * 0.05),\n      evidence: [{\n        type: 'timing',\n        source: 'concurrency_analysis',\n        observation: `${concurrentNodes} nodes executing concurrently`,\n        weight: 0.5,\n      }],\n    });\n  }\n\n  // Check for slow dependencies\n  const slowDeps = findSlowDependencies(trace, failure.nodeId);\n  if (slowDeps.length > 0) {\n    factors.push({\n      factor: 'Slow upstream dependencies',\n      contribution: 0.2,\n      evidence: slowDeps.map(dep => ({\n        type: 'timing' as const,\n        source: 'dependency_analysis',\n        observation: `Dependency ${dep.nodeId} took ${dep.duration}ms`,\n        weight: 0.4,\n      })),\n    });\n  }\n\n  return factors;\n}\n\nfunction calculateConfidence(\n  evidence: Evidence[],\n  factors: ContributingFactor[]\n): number {\n  // Weighted average of evidence weights\n  const evidenceTotal = evidence.reduce((sum, e) => sum + e.weight, 0);\n  const evidenceAvg = evidenceTotal / Math.max(1, evidence.length);\n\n  // Reduce confidence if many contributing factors\n  const factorPenalty = Math.min(0.2, factors.length * 0.05);\n\n  // More evidence = more confidence\n  const evidenceBonus = Math.min(0.1, evidence.length * 0.02);\n\n  return Math.max(0.3, Math.min(0.95, evidenceAvg + evidenceBonus - factorPenalty));\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"remediation-planning",children:"Remediation Planning"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface RemediationPlan {\n  immediateActions: RemediationAction[];\n  preventiveActions: RemediationAction[];\n  retryStrategy?: RetryStrategy;\n  escalation?: EscalationPlan;\n}\n\ninterface RemediationAction {\n  action: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  effort: 'trivial' | 'minor' | 'moderate' | 'major';\n  expectedImpact: string;\n  implementation?: string;\n}\n\ninterface RetryStrategy {\n  recommended: boolean;\n  strategy: 'immediate' | 'backoff' | 'skip' | 'manual';\n  maxRetries: number;\n  backoffMs?: number;\n  conditions?: string[];\n}\n\nfunction generateRemediationPlan(\n  rootCause: RootCause,\n  classification: FailureClassification,\n  propagation: FailurePropagation\n): RemediationPlan {\n  const plan: RemediationPlan = {\n    immediateActions: [],\n    preventiveActions: [],\n  };\n\n  // Generate actions based on failure type\n  switch (rootCause.type) {\n    case 'timeout':\n      plan.immediateActions.push({\n        action: 'Increase timeout for affected node',\n        priority: 'high',\n        effort: 'trivial',\n        expectedImpact: 'Allows operation to complete',\n        implementation: 'Update node config: timeoutMs: <current * 2>',\n      });\n      plan.preventiveActions.push({\n        action: 'Add progress monitoring to detect slow execution',\n        priority: 'medium',\n        effort: 'moderate',\n        expectedImpact: 'Early warning for timeout-prone operations',\n      });\n      plan.retryStrategy = {\n        recommended: true,\n        strategy: 'backoff',\n        maxRetries: 2,\n        backoffMs: 5000,\n        conditions: ['No permanent resource exhaustion'],\n      };\n      break;\n\n    case 'tool_error':\n      plan.immediateActions.push({\n        action: 'Check tool availability and permissions',\n        priority: 'critical',\n        effort: 'trivial',\n        expectedImpact: 'Confirms tool is accessible',\n      });\n      plan.immediateActions.push({\n        action: 'Verify tool input parameters',\n        priority: 'high',\n        effort: 'minor',\n        expectedImpact: 'Ensures valid inputs',\n      });\n      plan.retryStrategy = {\n        recommended: false,\n        strategy: 'manual',\n        maxRetries: 0,\n        conditions: ['Tool error must be fixed first'],\n      };\n      break;\n\n    case 'resource_exhaustion':\n      plan.immediateActions.push({\n        action: 'Reduce input size or complexity',\n        priority: 'high',\n        effort: 'moderate',\n        expectedImpact: 'Reduces resource requirements',\n      });\n      plan.preventiveActions.push({\n        action: 'Implement chunking for large inputs',\n        priority: 'high',\n        effort: 'major',\n        expectedImpact: 'Prevents future exhaustion',\n      });\n      plan.retryStrategy = {\n        recommended: false,\n        strategy: 'skip',\n        maxRetries: 0,\n        conditions: ['Must reduce resource usage first'],\n      };\n      break;\n\n    case 'validation_failure':\n      plan.immediateActions.push({\n        action: 'Review validation rules against actual output',\n        priority: 'high',\n        effort: 'minor',\n        expectedImpact: 'Identifies schema mismatch',\n      });\n      plan.retryStrategy = {\n        recommended: true,\n        strategy: 'immediate',\n        maxRetries: 2,\n        conditions: ['Add validation guidance to prompt'],\n      };\n      break;\n\n    case 'permission_denied':\n      plan.immediateActions.push({\n        action: 'Review and update permission matrix',\n        priority: 'critical',\n        effort: 'minor',\n        expectedImpact: 'Grants necessary permissions',\n      });\n      plan.retryStrategy = {\n        recommended: false,\n        strategy: 'manual',\n        maxRetries: 0,\n        conditions: ['Must fix permissions first'],\n      };\n      break;\n\n    case 'external_service':\n      plan.immediateActions.push({\n        action: 'Check external service status',\n        priority: 'high',\n        effort: 'trivial',\n        expectedImpact: 'Confirms if service is available',\n      });\n      plan.retryStrategy = {\n        recommended: true,\n        strategy: 'backoff',\n        maxRetries: 3,\n        backoffMs: 10000,\n        conditions: ['Service may recover'],\n      };\n      break;\n\n    default:\n      plan.immediateActions.push({\n        action: 'Manual investigation required',\n        priority: 'high',\n        effort: 'moderate',\n        expectedImpact: 'Understand failure cause',\n      });\n  }\n\n  // Add escalation if not recoverable\n  if (classification.recoverability === 'impossible') {\n    plan.escalation = {\n      required: true,\n      reason: 'Failure is not automatically recoverable',\n      suggestedOwner: 'human',\n      context: summarizeForEscalation(rootCause, propagation),\n    };\n  }\n\n  return plan;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"failure-report",children:"Failure Report"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'failureAnalysis:\n  analysisId: "fa-7c3a2b1d-4e5f-6a7b-8c9d"\n  traceId: "tr-8f4a2b1c-3d5e-6f7a-8b9c"\n  dagId: "code-review-dag"\n  analyzedAt: "2024-01-15T10:35:00Z"\n\n  rootCause:\n    nodeId: check-security\n    type: external_service\n    description: "Security scanning service returned 503 (Service Unavailable)"\n    confidence: 0.87\n    evidence:\n      - type: error_message\n        source: primary_error\n        observation: "external service error: Security API returned 503"\n        weight: 0.9\n      - type: pattern_match\n        source: failure_history\n        observation: "Matches known pattern: API rate limit (seen 3 times)"\n        weight: 0.8\n    contributingFactors:\n      - factor: "High concurrent load"\n        contribution: 0.15\n        evidence:\n          - type: timing\n            source: concurrency_analysis\n            observation: "7 nodes executing concurrently"\n\n  propagation:\n    originNode: check-security\n    affectedNodes:\n      - aggregate-results\n      - generate-report\n    propagationPath:\n      - fromNode: check-security\n        toNode: aggregate-results\n        propagationType: direct_dependency\n        timestamp: "2024-01-15T10:34:45Z"\n      - fromNode: aggregate-results\n        toNode: generate-report\n        propagationType: direct_dependency\n        timestamp: "2024-01-15T10:34:46Z"\n    cascadeDepth: 2\n    containmentBoundary:\n      - generate-report\n\n  classification:\n    severity: high\n    impact:\n      nodesAffected: 3\n      tasksBlocked: 1\n      estimatedDelay: 60000\n    recoverability: automatic\n    frequency: intermittent\n\n  remediation:\n    immediateActions:\n      - action: "Check external service status"\n        priority: high\n        effort: trivial\n        expectedImpact: "Confirms if service is available"\n\n    preventiveActions:\n      - action: "Add circuit breaker for external service calls"\n        priority: medium\n        effort: moderate\n        expectedImpact: "Graceful degradation on service failures"\n      - action: "Implement caching for security scan results"\n        priority: low\n        effort: major\n        expectedImpact: "Reduces dependency on external service"\n\n    retryStrategy:\n      recommended: true\n      strategy: backoff\n      maxRetries: 3\n      backoffMs: 10000\n      conditions:\n        - "Service may recover"\n        - "No rate limit reached"\n\n  summary: |\n    The check-security node failed due to an external service (Security API)\n    returning 503. This is an intermittent issue that has occurred 3 times\n    previously. The failure cascaded to 2 downstream nodes. Recommended\n    action is to retry with exponential backoff.\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input"}),": Execution traces from ",(0,r.jsx)(n.code,{children:"dag-execution-tracer"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Correlation"}),": Performance data from ",(0,r.jsx)(n.code,{children:"dag-performance-profiler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output"}),": Failure patterns to ",(0,r.jsx)(n.code,{children:"dag-pattern-learner"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recovery"}),": Remediation plans to ",(0,r.jsx)(n.code,{children:"dag-dynamic-replanner"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trace from Origin"}),": Always identify the first failure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gather Evidence"}),": Multiple sources increase confidence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider History"}),": Check for recurring patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actionable Remediation"}),": Make fixes specific and implementable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Know When to Escalate"}),": Some failures need human intervention"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Understand failures. Find root causes. Enable recovery."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);