"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[53221],{9236:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"skills/dag_task_scheduler/index","title":"\ud83d\udce6 Dag Task Scheduler","description":"Wave-based parallel scheduling for DAG execution. Manages execution order, resource allocation, and parallelism constraints. Activate on \'schedule dag\', \'execution waves\', \'parallel scheduling\', \'task queue\', \'resource allocation\'. NOT for building DAGs (use dag-graph-builder) or actual execution (use dag-parallel-executor).","source":"@site/docs/skills/dag_task_scheduler/index.md","sourceDirName":"skills/dag_task_scheduler","slug":"/skills/dag_task_scheduler/","permalink":"/docs/skills/dag_task_scheduler/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Task Scheduler","sidebar_position":1}}');var i=s(74848),t=s(28453);const r={sidebar_label:"Dag Task Scheduler",sidebar_position:1},l="\ud83d\udce6 Dag Task Scheduler",d={},o=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Wave-Based Scheduling",id:"1-wave-based-scheduling",level:3},{value:"2. Resource Management",id:"2-resource-management",level:3},{value:"3. Priority Handling",id:"3-priority-handling",level:3},{value:"4. Adaptive Scheduling",id:"4-adaptive-scheduling",level:3},{value:"Scheduling Algorithm",id:"scheduling-algorithm",level:2},{value:"Resource Allocation Strategy",id:"resource-allocation-strategy",level:2},{value:"Token Budget Management",id:"token-budget-management",level:3},{value:"Parallelism Constraints",id:"parallelism-constraints",level:3},{value:"Schedule Output Format",id:"schedule-output-format",level:2},{value:"Scheduling Strategies",id:"scheduling-strategies",level:2},{value:"1. Greedy First-Fit",id:"1-greedy-first-fit",level:3},{value:"2. Shortest Job First",id:"2-shortest-job-first",level:3},{value:"3. Priority-Based",id:"3-priority-based",level:3},{value:"4. Fair Share",id:"4-fair-share",level:3},{value:"Runtime Adaptation",id:"runtime-adaptation",level:2},{value:"Handling Early Completion",id:"handling-early-completion",level:3},{value:"Handling Task Failure",id:"handling-task-failure",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Metrics and Reporting",id:"metrics-and-reporting",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"-dag-task-scheduler",children:"\ud83d\udce6 Dag Task Scheduler"})}),"\n",(0,i.jsx)(n.p,{children:"Wave-based parallel scheduling for DAG execution. Manages execution order, resource allocation, and parallelism constraints. Activate on 'schedule dag', 'execution waves', 'parallel scheduling', 'task queue', 'resource allocation'. NOT for building DAGs (use dag-graph-builder) or actual execution (use dag-parallel-executor)."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"dag"})," ",(0,i.jsx)(n.code,{children:"orchestration"})," ",(0,i.jsx)(n.code,{children:"scheduling"})," ",(0,i.jsx)(n.code,{children:"parallelism"})," ",(0,i.jsx)(n.code,{children:"resource-allocation"})]}),"\n",(0,i.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/skills/dag_dependency_resolver",children:"Dag Dependency Resolver"})}),": Uses topologically sorted waves"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/skills/dag_parallel_executor",children:"Dag Parallel Executor"})}),": Provides schedule for execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/skills/dag_dynamic_replanner",children:"Dag Dynamic Replanner"})}),": Supports dynamic rescheduling"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"You are a DAG Task Scheduler, an expert at creating optimal execution schedules for directed acyclic graphs. You manage wave-based parallelism, resource allocation, and execution timing to maximize throughput while respecting constraints."}),"\n",(0,i.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,i.jsx)(n.h3,{id:"1-wave-based-scheduling",children:"1. Wave-Based Scheduling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Group independent tasks into parallel waves"}),"\n",(0,i.jsx)(n.li,{children:"Schedule waves for sequential execution"}),"\n",(0,i.jsx)(n.li,{children:"Maximize concurrency within resource limits"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-resource-management",children:"2. Resource Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Allocate CPU, memory, and token budgets"}),"\n",(0,i.jsx)(n.li,{children:"Prevent resource contention between parallel tasks"}),"\n",(0,i.jsx)(n.li,{children:"Balance load across available resources"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-priority-handling",children:"3. Priority Handling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement priority-based scheduling within waves"}),"\n",(0,i.jsx)(n.li,{children:"Handle urgent tasks and deadlines"}),"\n",(0,i.jsx)(n.li,{children:"Support preemption when necessary"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-adaptive-scheduling",children:"4. Adaptive Scheduling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Adjust schedules based on runtime feedback"}),"\n",(0,i.jsx)(n.li,{children:"Handle early completions and late arrivals"}),"\n",(0,i.jsx)(n.li,{children:"Support dynamic rescheduling"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"scheduling-algorithm",children:"Scheduling Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface ScheduledWave {\n  waveNumber: number;\n  tasks: ScheduledTask[];\n  estimatedStart: Date;\n  estimatedEnd: Date;\n  resourceAllocation: ResourceAllocation;\n}\n\ninterface ScheduledTask {\n  nodeId: NodeId;\n  priority: number;\n  resourceRequirements: ResourceRequirements;\n  estimatedDuration: number;\n  deadline?: Date;\n}\n\nfunction scheduleDAG(\n  waves: NodeId[][],\n  dag: DAG,\n  config: SchedulerConfig\n): ScheduledWave[] {\n  const schedule: ScheduledWave[] = [];\n  let currentTime = new Date();\n\n  for (let i = 0; i < waves.length; i++) {\n    const wave = waves[i];\n    const tasks = wave.map(nodeId => {\n      const node = dag.nodes.get(nodeId);\n      return {\n        nodeId,\n        priority: node.config.priority || 0,\n        resourceRequirements: estimateResources(node),\n        estimatedDuration: node.config.timeoutMs || 30000,\n        deadline: node.config.deadline,\n      };\n    });\n\n    // Sort by priority (higher first)\n    tasks.sort((a, b) => b.priority - a.priority);\n\n    // Apply parallelism constraints\n    const constrainedTasks = applyConstraints(tasks, config);\n\n    // Allocate resources\n    const allocation = allocateResources(constrainedTasks, config);\n\n    // Calculate timing\n    const maxDuration = Math.max(...tasks.map(t => t.estimatedDuration));\n    const waveEnd = new Date(currentTime.getTime() + maxDuration);\n\n    schedule.push({\n      waveNumber: i,\n      tasks: constrainedTasks,\n      estimatedStart: currentTime,\n      estimatedEnd: waveEnd,\n      resourceAllocation: allocation,\n    });\n\n    currentTime = waveEnd;\n  }\n\n  return schedule;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"resource-allocation-strategy",children:"Resource Allocation Strategy"}),"\n",(0,i.jsx)(n.h3,{id:"token-budget-management",children:"Token Budget Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface TokenBudget {\n  totalTokens: number;\n  usedTokens: number;\n  perWaveBudget: number;\n  perTaskBudget: number;\n}\n\nfunction allocateTokenBudget(\n  schedule: ScheduledWave[],\n  totalBudget: number\n): TokenBudget[] {\n  const waveCount = schedule.length;\n  const perWaveBudget = Math.floor(totalBudget / waveCount);\n\n  return schedule.map(wave => ({\n    totalTokens: perWaveBudget,\n    usedTokens: 0,\n    perWaveBudget,\n    perTaskBudget: Math.floor(perWaveBudget / wave.tasks.length),\n  }));\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parallelism-constraints",children:"Parallelism Constraints"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function applyConstraints(\n  tasks: ScheduledTask[],\n  config: SchedulerConfig\n): ScheduledTask[] {\n  const maxParallelism = config.maxParallelism || 3;\n\n  if (tasks.length <= maxParallelism) {\n    return tasks;\n  }\n\n  // Group tasks into sub-waves respecting parallelism limit\n  const subWaves: ScheduledTask[][] = [];\n  for (let i = 0; i < tasks.length; i += maxParallelism) {\n    subWaves.push(tasks.slice(i, i + maxParallelism));\n  }\n\n  return subWaves.flat();\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"schedule-output-format",children:"Schedule Output Format"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'schedule:\n  dagId: research-pipeline\n  totalWaves: 4\n  estimatedDuration: 120000ms\n  maxParallelism: 3\n\n  waves:\n    - wave: 0\n      status: pending\n      estimatedStart: "2024-01-15T10:00:00Z"\n      estimatedEnd: "2024-01-15T10:00:30Z"\n      tasks:\n        - nodeId: gather-sources\n          priority: 1\n          estimatedDuration: 30000\n          resources:\n            maxTokens: 5000\n            timeoutMs: 30000\n\n    - wave: 1\n      status: pending\n      estimatedStart: "2024-01-15T10:00:30Z"\n      estimatedEnd: "2024-01-15T10:01:00Z"\n      tasks:\n        - nodeId: validate-sources\n          priority: 1\n          estimatedDuration: 15000\n        - nodeId: extract-metadata\n          priority: 0\n          estimatedDuration: 20000\n\n  resourceSummary:\n    totalTokenBudget: 50000\n    perWaveBudget: 12500\n    estimatedCost: 0.25\n\n  criticalPath:\n    - gather-sources \u2192 validate-sources \u2192 analyze \u2192 report\n    - bottleneck: analyze (30000ms)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"scheduling-strategies",children:"Scheduling Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"1-greedy-first-fit",children:"1. Greedy First-Fit"}),"\n",(0,i.jsx)(n.p,{children:"Schedule tasks as soon as resources are available."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Pros: Simple, low overhead\nCons: May not be optimal\nBest for: Homogeneous task sizes\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-shortest-job-first",children:"2. Shortest Job First"}),"\n",(0,i.jsx)(n.p,{children:"Prioritize tasks with shortest estimated duration."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Pros: Minimizes average completion time\nCons: May starve long tasks\nBest for: Mixed task sizes\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-priority-based",children:"3. Priority-Based"}),"\n",(0,i.jsx)(n.p,{children:"Schedule based on explicit priority assignments."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Pros: Respects business requirements\nCons: Requires priority specification\nBest for: Deadline-sensitive workloads\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-fair-share",children:"4. Fair Share"}),"\n",(0,i.jsx)(n.p,{children:"Distribute resources evenly across task types."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Pros: Prevents starvation\nCons: May not optimize throughput\nBest for: Multi-tenant scenarios\n"})}),"\n",(0,i.jsx)(n.h2,{id:"runtime-adaptation",children:"Runtime Adaptation"}),"\n",(0,i.jsx)(n.h3,{id:"handling-early-completion",children:"Handling Early Completion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function handleEarlyCompletion(\n  completedTask: NodeId,\n  schedule: ScheduledWave[]\n): ScheduledWave[] {\n  // Check if dependent tasks can start early\n  const dependentWaves = schedule.filter(wave =>\n    wave.tasks.some(task =>\n      dag.nodes.get(task.nodeId).dependencies.includes(completedTask)\n    )\n  );\n\n  // Update timing estimates\n  for (const wave of dependentWaves) {\n    wave.estimatedStart = new Date(); // Can start now if all deps complete\n  }\n\n  return schedule;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handling-task-failure",children:"Handling Task Failure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function handleTaskFailure(\n  failedTask: NodeId,\n  schedule: ScheduledWave[],\n  errorHandling: ErrorHandlingStrategy\n): ScheduledWave[] {\n  switch (errorHandling) {\n    case 'stop-on-failure':\n      // Mark all dependent tasks as skipped\n      return markDependentsSkipped(failedTask, schedule);\n\n    case 'continue-on-failure':\n      // Continue with tasks that don't depend on failed task\n      return schedule;\n\n    case 'retry-then-skip':\n      // Retry the task, then skip if still failing\n      return addRetryToSchedule(failedTask, schedule);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Sorted waves from ",(0,i.jsx)(n.code,{children:"dag-dependency-resolver"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Execution schedule for ",(0,i.jsx)(n.code,{children:"dag-parallel-executor"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitoring"}),": Progress updates to ",(0,i.jsx)(n.code,{children:"dag-execution-tracer"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Adaptation"}),": Reschedule requests from ",(0,i.jsx)(n.code,{children:"dag-dynamic-replanner"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"metrics-and-reporting",children:"Metrics and Reporting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"metrics:\n  schedulingLatency: 5ms\n  averageWaveUtilization: 0.85\n  parallelizationEfficiency: 2.3x\n  resourceWaste: 15%\n\n  perWaveMetrics:\n    - wave: 0\n      tasksScheduled: 3\n      resourceUtilization: 0.9\n      actualDuration: 28000ms\n      estimatedDuration: 30000ms\n      variance: -7%\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Optimal schedules. Maximum parallelism. Minimal waste."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var a=s(96540);const i={},t=a.createContext(i);function r(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);