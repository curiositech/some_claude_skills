"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[67088],{17492:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"skills/hr_network_analyst/references/graph-databases","title":"Graph Database Analysis Reference","description":"Neo4j","source":"@site/docs/skills/hr_network_analyst/references/graph-databases.md","sourceDirName":"skills/hr_network_analyst/references","slug":"/skills/hr_network_analyst/references/graph-databases","permalink":"/docs/skills/hr_network_analyst/references/graph-databases","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Graph Database Analysis Reference","sidebar_label":"Graph Database Analysis Ref...","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Professional Network Data A...","permalink":"/docs/skills/hr_network_analyst/references/data-sources"},"next":{"title":"Network Theory Reference","permalink":"/docs/skills/hr_network_analyst/references/network-theory"}}');var a=s(74848),o=s(28453);const t={title:"Graph Database Analysis Reference",sidebar_label:"Graph Database Analysis Ref...",sidebar_position:4},i="Graph Database Analysis Reference",l={},d=[{value:"Neo4j",id:"neo4j",level:2},{value:"Setup",id:"setup",level:3},{value:"Data Model for Professional Networks",id:"data-model-for-professional-networks",level:3},{value:"Loading Data",id:"loading-data",level:3},{value:"Centrality Algorithms (Graph Data Science Library)",id:"centrality-algorithms-graph-data-science-library",level:3},{value:"Community Detection",id:"community-detection",level:3},{value:"Finding Bridges and Superconnectors",id:"finding-bridges-and-superconnectors",level:3},{value:"Gladwell Classification Query",id:"gladwell-classification-query",level:3},{value:"Path Finding",id:"path-finding",level:3},{value:"Multi-Source Network Fusion",id:"multi-source-network-fusion",level:3},{value:"Amazon Neptune",id:"amazon-neptune",level:2},{value:"Gremlin Queries",id:"gremlin-queries",level:3},{value:"TigerGraph",id:"tigergraph",level:2},{value:"GSQL Queries",id:"gsql-queries",level:3},{value:"ArangoDB",id:"arangodb",level:2},{value:"AQL Queries",id:"aql-queries",level:3},{value:"DGraph",id:"dgraph",level:2},{value:"DQL Queries",id:"dql-queries",level:3},{value:"Python Integration Patterns",id:"python-integration-patterns",level:2},{value:"Neo4j with Python",id:"neo4j-with-python",level:3},{value:"Bulk Loading Pattern",id:"bulk-loading-pattern",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"graph-database-analysis-reference",children:"Graph Database Analysis Reference"})}),"\n",(0,a.jsx)(n.h2,{id:"neo4j",children:"Neo4j"}),"\n",(0,a.jsx)(n.p,{children:"Neo4j is the most popular graph database for professional network analysis. It uses Cypher query language and has built-in graph data science algorithms."}),"\n",(0,a.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Create constraint for unique person IDs\nCREATE CONSTRAINT person_id IF NOT EXISTS\nFOR (p:Person) REQUIRE p.id IS UNIQUE;\n\n// Create index for faster lookups\nCREATE INDEX person_name IF NOT EXISTS\nFOR (p:Person) ON (p.name);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"data-model-for-professional-networks",children:"Data Model for Professional Networks"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Node types\n(:Person {id, name, email, role, company, linkedin_url})\n(:Company {id, name, industry, size})\n(:Conference {id, name, year, location})\n(:Publication {id, title, year, venue, doi})\n(:Project {id, name, repo_url, tech_stack})\n\n// Relationship types\n(:Person)-[:WORKS_AT {since, role}]->(:Company)\n(:Person)-[:SPOKE_AT {talk_title, track}]->(:Conference)\n(:Person)-[:COAUTHORED {position}]->(:Publication)\n(:Person)-[:CONTRIBUTED_TO {commits, role}]->(:Project)\n(:Person)-[:KNOWS {strength, source, since}]->(:Person)\n(:Person)-[:COLLABORATED_WITH {project, duration}]->(:Person)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"loading-data",children:"Loading Data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Load from CSV\nLOAD CSV WITH HEADERS FROM 'file:///people.csv' AS row\nMERGE (p:Person {id: row.id})\nSET p.name = row.name,\n    p.email = row.email,\n    p.role = row.role;\n\n// Load edges\nLOAD CSV WITH HEADERS FROM 'file:///connections.csv' AS row\nMATCH (a:Person {id: row.source})\nMATCH (b:Person {id: row.target})\nMERGE (a)-[r:KNOWS]->(b)\nSET r.strength = toFloat(row.strength),\n    r.source = row.data_source;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"centrality-algorithms-graph-data-science-library",children:"Centrality Algorithms (Graph Data Science Library)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// First, create a graph projection\nCALL gds.graph.project(\n  'professional-network',\n  'Person',\n  {\n    KNOWS: {\n      orientation: 'UNDIRECTED',\n      properties: ['strength']\n    }\n  }\n);\n\n// Betweenness Centrality\nCALL gds.betweenness.stream('professional-network')\nYIELD nodeId, score\nRETURN gds.util.asNode(nodeId).name AS name, score\nORDER BY score DESC\nLIMIT 20;\n\n// Write back to nodes\nCALL gds.betweenness.write('professional-network', {\n  writeProperty: 'betweenness'\n});\n\n// PageRank\nCALL gds.pageRank.stream('professional-network', {\n  dampingFactor: 0.85,\n  maxIterations: 20\n})\nYIELD nodeId, score\nRETURN gds.util.asNode(nodeId).name AS name, score\nORDER BY score DESC\nLIMIT 20;\n\n// Eigenvector Centrality\nCALL gds.eigenvector.stream('professional-network', {\n  maxIterations: 100\n})\nYIELD nodeId, score\nRETURN gds.util.asNode(nodeId).name AS name, score\nORDER BY score DESC;\n\n// Degree Centrality\nCALL gds.degree.stream('professional-network')\nYIELD nodeId, score\nRETURN gds.util.asNode(nodeId).name AS name, score\nORDER BY score DESC;\n\n// Closeness Centrality\nCALL gds.closeness.stream('professional-network')\nYIELD nodeId, score\nRETURN gds.util.asNode(nodeId).name AS name, score\nORDER BY score DESC;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"community-detection",children:"Community Detection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Louvain community detection\nCALL gds.louvain.stream('professional-network')\nYIELD nodeId, communityId\nRETURN gds.util.asNode(nodeId).name AS name, communityId\nORDER BY communityId;\n\n// Write communities to nodes\nCALL gds.louvain.write('professional-network', {\n  writeProperty: 'community'\n});\n\n// Label Propagation\nCALL gds.labelPropagation.stream('professional-network')\nYIELD nodeId, communityId\nRETURN communityId, collect(gds.util.asNode(nodeId).name) AS members\nORDER BY size(members) DESC;\n\n// Weakly Connected Components\nCALL gds.wcc.stream('professional-network')\nYIELD nodeId, componentId\nRETURN componentId, count(*) AS size\nORDER BY size DESC;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"finding-bridges-and-superconnectors",children:"Finding Bridges and Superconnectors"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Find people who bridge communities\nMATCH (p:Person)\nWHERE p.betweenness > 0.1\nRETURN p.name, p.betweenness, p.community\nORDER BY p.betweenness DESC;\n\n// Find people connected to multiple communities\nMATCH (p:Person)-[:KNOWS]-(other:Person)\nWITH p, collect(DISTINCT other.community) AS connected_communities\nWHERE size(connected_communities) >= 3\nRETURN p.name, connected_communities, size(connected_communities) AS bridge_score\nORDER BY bridge_score DESC;\n\n// Find structural hole spanners\nMATCH (p:Person)-[:KNOWS]-(a:Person)\nMATCH (p)-[:KNOWS]-(b:Person)\nWHERE a.community <> b.community AND NOT (a)-[:KNOWS]-(b)\nWITH p, count(DISTINCT [a.community, b.community]) AS holes_spanned\nWHERE holes_spanned > 5\nRETURN p.name, holes_spanned\nORDER BY holes_spanned DESC;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"gladwell-classification-query",children:"Gladwell Classification Query"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Classify nodes by Gladwell archetype\nMATCH (p:Person)\nWITH p,\n     percentileDisc(p.betweenness, 0.9) OVER () AS bc_threshold,\n     percentileDisc(p.degree, 0.9) OVER () AS dc_threshold,\n     percentileDisc(p.eigenvector, 0.9) OVER () AS ec_threshold\nRETURN p.name,\n       CASE\n         WHEN p.betweenness >= bc_threshold AND p.degree >= dc_threshold\n           THEN 'connector'\n         WHEN p.eigenvector >= ec_threshold AND p.degree < dc_threshold\n           THEN 'maven'\n         WHEN p.degree >= dc_threshold\n           THEN 'salesman'\n         ELSE 'standard'\n       END AS gladwell_type,\n       p.betweenness, p.degree, p.eigenvector\nORDER BY p.betweenness DESC;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"path-finding",children:"Path Finding"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Shortest path between two people\nMATCH path = shortestPath(\n  (a:Person {name: 'Alice'})-[:KNOWS*]-(b:Person {name: 'Bob'})\n)\nRETURN path, length(path) AS degrees_of_separation;\n\n// All shortest paths\nMATCH paths = allShortestPaths(\n  (a:Person {name: 'Alice'})-[:KNOWS*]-(b:Person {name: 'Bob'})\n)\nRETURN paths;\n\n// Find connectors who can introduce you\nMATCH (me:Person {name: 'Alice'})\nMATCH (target:Person {name: 'Bob'})\nMATCH path = shortestPath((me)-[:KNOWS*2..4]-(target))\nWITH nodes(path) AS path_nodes\nUNWIND range(1, size(path_nodes)-2) AS i\nWITH path_nodes[i] AS connector\nRETURN connector.name, connector.betweenness\nORDER BY connector.betweenness DESC;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"multi-source-network-fusion",children:"Multi-Source Network Fusion"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cypher",children:"// Create weighted relationships from multiple sources\nMATCH (a:Person)-[r:KNOWS]-(b:Person)\nWITH a, b, collect(r) AS rels\nSET a.connection_weight = reduce(w = 0.0, r IN rels |\n  w + CASE r.source\n    WHEN 'coauthorship' THEN 1.0\n    WHEN 'conference' THEN 0.8\n    WHEN 'linkedin' THEN 0.5\n    WHEN 'github' THEN 0.6\n    ELSE 0.3\n  END\n);\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"amazon-neptune",children:"Amazon Neptune"}),"\n",(0,a.jsx)(n.p,{children:"Neptune is AWS's managed graph database, compatible with Gremlin and SPARQL."}),"\n",(0,a.jsx)(n.h3,{id:"gremlin-queries",children:"Gremlin Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-groovy",children:"// Betweenness-like analysis (Gremlin doesn't have native betweenness)\n// Count paths through each node\ng.V().hasLabel('Person')\n  .project('name', 'pathsThrough')\n  .by('name')\n  .by(\n    __.as('p')\n    .both('KNOWS').as('start')\n    .repeat(__.both('KNOWS').simplePath())\n    .until(__.loops().is(3))\n    .path()\n    .filter(__.unfold().is('p'))\n    .count()\n  )\n  .order().by('pathsThrough', desc)\n  .limit(20)\n\n// Degree centrality\ng.V().hasLabel('Person')\n  .project('name', 'degree')\n  .by('name')\n  .by(__.both('KNOWS').count())\n  .order().by('degree', desc)\n  .limit(20)\n\n// Find bridges between communities\ng.V().hasLabel('Person')\n  .where(\n    __.both('KNOWS').values('community').dedup().count().is(gte(3))\n  )\n  .project('name', 'communities')\n  .by('name')\n  .by(__.both('KNOWS').values('community').dedup().fold())\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"tigergraph",children:"TigerGraph"}),"\n",(0,a.jsx)(n.p,{children:"TigerGraph is optimized for deep-link analytics on large graphs."}),"\n",(0,a.jsx)(n.h3,{id:"gsql-queries",children:"GSQL Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'-- Create schema\nCREATE VERTEX Person (\n  PRIMARY_ID id STRING,\n  name STRING,\n  email STRING,\n  role STRING\n)\n\nCREATE DIRECTED EDGE KNOWS (\n  FROM Person,\n  TO Person,\n  strength FLOAT,\n  source STRING\n)\n\n-- Betweenness Centrality\nCREATE QUERY betweenness_centrality() FOR GRAPH professional_network {\n  MapAccum<VERTEX<Person>, FLOAT> @@bc_scores;\n\n  Start = {Person.*};\n\n  // Run shortest paths from each node\n  FOREACH src IN Start DO\n    paths = SELECT t\n      FROM Start:s -(KNOWS:e)- Person:t\n      WHERE s == src\n      ACCUM @@bc_scores += (t -> 1.0);\n  END;\n\n  PRINT @@bc_scores;\n}\n\n-- PageRank\nCREATE QUERY pagerank(FLOAT damping = 0.85, INT max_iter = 20)\nFOR GRAPH professional_network {\n  MaxAccum<FLOAT> @pr_score = 1.0;\n  SumAccum<FLOAT> @new_score;\n\n  Start = {Person.*};\n  INT num_vertices = Start.size();\n\n  FOREACH i IN RANGE[1, max_iter] DO\n    Start = SELECT s\n      FROM Start:s -(KNOWS:e)- Person:t\n      ACCUM t.@new_score += s.@pr_score / s.outdegree("KNOWS")\n      POST-ACCUM\n        s.@pr_score = (1 - damping) / num_vertices + damping * s.@new_score,\n        s.@new_score = 0;\n  END;\n\n  PRINT Start[Start.@pr_score];\n}\n\n-- Find superconnectors\nCREATE QUERY find_superconnectors(INT top_k = 20)\nFOR GRAPH professional_network {\n  SumAccum<INT> @degree;\n  MaxAccum<FLOAT> @betweenness;\n\n  Start = {Person.*};\n\n  // Calculate degree\n  connected = SELECT s\n    FROM Start:s -(KNOWS:e)- Person:t\n    ACCUM s.@degree += 1;\n\n  // Return top by combined score\n  Result = SELECT s FROM Start:s\n    ORDER BY s.@degree DESC\n    LIMIT top_k;\n\n  PRINT Result;\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"arangodb",children:"ArangoDB"}),"\n",(0,a.jsx)(n.p,{children:"ArangoDB is a multi-model database with graph capabilities."}),"\n",(0,a.jsx)(n.h3,{id:"aql-queries",children:"AQL Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-aql",children:'// Betweenness Centrality (using Pregel)\nWITH "professional_network"\nLET result = PREGEL_RUN("betweenness", "professional_network", {\n  maxIterations: 100,\n  resultField: "betweenness"\n})\nFOR doc IN Person\n  SORT doc.betweenness DESC\n  LIMIT 20\n  RETURN {name: doc.name, betweenness: doc.betweenness}\n\n// PageRank\nWITH "professional_network"\nLET result = PREGEL_RUN("pagerank", "professional_network", {\n  maxIterations: 100,\n  dampingFactor: 0.85,\n  resultField: "pagerank"\n})\nFOR doc IN Person\n  SORT doc.pagerank DESC\n  LIMIT 20\n  RETURN {name: doc.name, pagerank: doc.pagerank}\n\n// Shortest path\nFOR v, e IN OUTBOUND SHORTEST_PATH\n  \'Person/alice\' TO \'Person/bob\'\n  GRAPH \'professional_network\'\n  RETURN v.name\n\n// K-hop neighbors\nFOR v, e, p IN 1..3 ANY \'Person/alice\'\n  GRAPH \'professional_network\'\n  RETURN DISTINCT v.name\n\n// Find bridges\nFOR person IN Person\n  LET neighbors = (\n    FOR v IN 1..1 ANY person GRAPH \'professional_network\'\n      RETURN DISTINCT v.community\n  )\n  FILTER LENGTH(neighbors) >= 3\n  SORT LENGTH(neighbors) DESC\n  RETURN {\n    name: person.name,\n    communities_bridged: neighbors,\n    bridge_score: LENGTH(neighbors)\n  }\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"dgraph",children:"DGraph"}),"\n",(0,a.jsx)(n.p,{children:"DGraph is a horizontally scalable graph database with GraphQL support."}),"\n",(0,a.jsx)(n.h3,{id:"dql-queries",children:"DQL Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'# Schema\ntype Person {\n  id: ID!\n  name: String! @index(term)\n  email: String @index(exact)\n  knows: [Person] @reverse\n  betweenness: Float\n  pagerank: Float\n}\n\n# Query high-centrality people\n{\n  superconnectors(func: ge(betweenness, 0.1), orderdesc: betweenness, first: 20) {\n    name\n    betweenness\n    pagerank\n    knows {\n      name\n    }\n  }\n}\n\n# Shortest path\n{\n  path as shortest(from: 0x1, to: 0x2) {\n    name\n  }\n}\n\n# Find all paths up to depth 3\n{\n  var(func: eq(name, "Alice")) {\n    knows @recurse(depth: 3) {\n      uid\n      name\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"python-integration-patterns",children:"Python Integration Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"neo4j-with-python",children:"Neo4j with Python"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from neo4j import GraphDatabase\nimport pandas as pd\n\nclass ProfessionalNetworkAnalyzer:\n    def __init__(self, uri, user, password):\n        self.driver = GraphDatabase.driver(uri, auth=(user, password))\n\n    def close(self):\n        self.driver.close()\n\n    def get_superconnectors(self, limit=20):\n        with self.driver.session() as session:\n            result = session.run("""\n                CALL gds.betweenness.stream(\'professional-network\')\n                YIELD nodeId, score\n                RETURN gds.util.asNode(nodeId).name AS name, score\n                ORDER BY score DESC\n                LIMIT $limit\n            """, limit=limit)\n            return pd.DataFrame([dict(r) for r in result])\n\n    def find_path_to_target(self, source_name, target_name):\n        with self.driver.session() as session:\n            result = session.run("""\n                MATCH path = shortestPath(\n                  (a:Person {name: $source})-[:KNOWS*]-(b:Person {name: $target})\n                )\n                RETURN [n IN nodes(path) | n.name] AS path,\n                       length(path) AS degrees\n            """, source=source_name, target=target_name)\n            record = result.single()\n            if record:\n                return record[\'path\'], record[\'degrees\']\n            return None, None\n\n    def classify_by_gladwell(self):\n        with self.driver.session() as session:\n            result = session.run("""\n                MATCH (p:Person)\n                WHERE p.betweenness IS NOT NULL\n                WITH p,\n                     percentileDisc(p.betweenness, 0.9) OVER () AS bc_thresh,\n                     percentileDisc(p.degree, 0.9) OVER () AS dc_thresh,\n                     percentileDisc(p.eigenvector, 0.9) OVER () AS ec_thresh\n                RETURN p.name AS name,\n                       CASE\n                         WHEN p.betweenness >= bc_thresh AND p.degree >= dc_thresh\n                           THEN \'connector\'\n                         WHEN p.eigenvector >= ec_thresh AND p.degree < dc_thresh\n                           THEN \'maven\'\n                         WHEN p.degree >= dc_thresh\n                           THEN \'salesman\'\n                         ELSE \'standard\'\n                       END AS archetype\n            """)\n            return pd.DataFrame([dict(r) for r in result])\n\n\n# Usage\nanalyzer = ProfessionalNetworkAnalyzer(\n    "bolt://localhost:7687",\n    "neo4j",\n    "password"\n)\n\nsuperconnectors = analyzer.get_superconnectors()\nprint(superconnectors.head(10))\n\npath, degrees = analyzer.find_path_to_target("Alice", "Bob")\nprint(f"Path: {\' -> \'.join(path)} ({degrees} degrees)")\n\nclassifications = analyzer.classify_by_gladwell()\nprint(classifications[classifications[\'archetype\'] == \'connector\'])\n\nanalyzer.close()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"bulk-loading-pattern",children:"Bulk Loading Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from neo4j import GraphDatabase\n\ndef bulk_load_network(driver, nodes_df, edges_df, batch_size=5000):\n    """Efficiently load network data into Neo4j."""\n\n    with driver.session() as session:\n        # Load nodes in batches\n        for i in range(0, len(nodes_df), batch_size):\n            batch = nodes_df.iloc[i:i+batch_size].to_dict(\'records\')\n            session.run("""\n                UNWIND $batch AS row\n                MERGE (p:Person {id: row.id})\n                SET p.name = row.name,\n                    p.email = row.email,\n                    p.role = row.role\n            """, batch=batch)\n            print(f"Loaded {min(i+batch_size, len(nodes_df))} nodes")\n\n        # Load edges in batches\n        for i in range(0, len(edges_df), batch_size):\n            batch = edges_df.iloc[i:i+batch_size].to_dict(\'records\')\n            session.run("""\n                UNWIND $batch AS row\n                MATCH (a:Person {id: row.source})\n                MATCH (b:Person {id: row.target})\n                MERGE (a)-[r:KNOWS]->(b)\n                SET r.strength = row.strength,\n                    r.source = row.data_source\n            """, batch=batch)\n            print(f"Loaded {min(i+batch_size, len(edges_df))} edges")\n\n\n# Usage\ndriver = GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password"))\nbulk_load_network(driver, people_df, connections_df)\ndriver.close()\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>i});var r=s(96540);const a={},o=r.createContext(a);function t(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);