"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[67113],{20416:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"skills/metal_shader_expert/references/debug-tools","title":"Debug Tools & Visualization","description":"Essential patterns for shader debugging and performance analysis.","source":"@site/docs/skills/metal_shader_expert/references/debug-tools.md","sourceDirName":"skills/metal_shader_expert/references","slug":"/skills/metal_shader_expert/references/debug-tools","permalink":"/docs/skills/metal_shader_expert/references/debug-tools","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Debug Tools & Visualization","sidebar_label":"Debug Tools & Visualization","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Metal Shader Expert","permalink":"/docs/skills/metal_shader_expert/"},"next":{"title":"Noise-Based Effects","permalink":"/docs/skills/metal_shader_expert/references/noise-effects"}}');var i=t(74848),r=t(28453);const l={title:"Debug Tools & Visualization",sidebar_label:"Debug Tools & Visualization",sidebar_position:1},o="Debug Tools & Visualization",s={},d=[{value:"Heat Map Visualization",id:"heat-map-visualization",level:2},{value:"Debug Visualization Modes",id:"debug-visualization-modes",level:2},{value:"Overdraw Visualization",id:"overdraw-visualization",level:2},{value:"Mipmap Level Visualization",id:"mipmap-level-visualization",level:2},{value:"NaN/Inf Detection",id:"naninf-detection",level:2},{value:"Wireframe Overlay",id:"wireframe-overlay",level:2},{value:"Performance Timers",id:"performance-timers",level:2},{value:"GPU Capture Integration",id:"gpu-capture-integration",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Debug Macro Pattern",id:"debug-macro-pattern",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"debug-tools--visualization",children:"Debug Tools & Visualization"})}),"\n",(0,i.jsx)(n.p,{children:"Essential patterns for shader debugging and performance analysis."}),"\n",(0,i.jsx)(n.h2,{id:"heat-map-visualization",children:"Heat Map Visualization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"// Visualize scalar values: 0=blue, 0.5=green, 1=red\nfloat3 heat_map(float v) {\n    v = saturate(v);\n    return v < 0.5\n        ? mix(float3(0,0,1), float3(0,1,0), v*2)\n        : mix(float3(0,1,0), float3(1,0,0), (v-0.5)*2);\n}\n\n// Extended heat map with purple for overflow\nfloat3 heat_map_extended(float v) {\n    if (v < 0.0) return float3(0.5, 0, 0.5);  // Magenta: negative\n    if (v > 1.0) return float3(1, 0, 1);       // Purple: overflow\n    return heat_map(v);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"debug-visualization-modes",children:"Debug Visualization Modes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"fragment float4 debug_fragment(\n    VertexOut in [[stage_in]],\n    constant uint& mode [[buffer(0)]]\n) {\n    switch (mode) {\n        case 0: // World normals\n            return float4(in.world_normal * 0.5 + 0.5, 1.0);\n\n        case 1: // UV coordinates\n            return float4(in.texcoord, 0.0, 1.0);\n\n        case 2: // Depth (linear)\n            float depth = in.position.z / in.position.w;\n            return float4(float3(depth), 1.0);\n\n        case 3: // Tangent space\n            return float4(in.tangent * 0.5 + 0.5, 1.0);\n\n        case 4: // Bitangent\n            return float4(in.bitangent * 0.5 + 0.5, 1.0);\n\n        case 5: // World position (wrapped)\n            return float4(fract(in.world_position), 1.0);\n\n        default:\n            return float4(1, 0, 1, 1);  // Magenta = error\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"overdraw-visualization",children:"Overdraw Visualization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"// Increment counter per fragment\nkernel void overdraw_counter(\n    texture2d<uint, access::read_write> counter [[texture(0)]],\n    uint2 gid [[thread_position_in_grid]]\n) {\n    uint current = counter.read(gid).r;\n    counter.write(uint4(current + 1), gid);\n}\n\n// Visualize overdraw\nfragment float4 overdraw_visualize(\n    VertexOut in [[stage_in]],\n    texture2d<uint> counter [[texture(0)]]\n) {\n    uint2 pos = uint2(in.position.xy);\n    uint count = counter.read(pos).r;\n\n    // Heat map: 1=green, 2=yellow, 3+=red\n    float normalized = float(count) / 5.0;\n    return float4(heat_map(normalized), 1.0);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"mipmap-level-visualization",children:"Mipmap Level Visualization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"// Shows which mipmap is being sampled\nfloat3 mip_colors[] = {\n    float3(1,0,0),   // Mip 0 - Red\n    float3(1,0.5,0), // Mip 1 - Orange\n    float3(1,1,0),   // Mip 2 - Yellow\n    float3(0,1,0),   // Mip 3 - Green\n    float3(0,1,1),   // Mip 4 - Cyan\n    float3(0,0,1),   // Mip 5 - Blue\n    float3(0.5,0,1), // Mip 6 - Purple\n    float3(1,0,1),   // Mip 7 - Magenta\n};\n\nfragment float4 mip_debug(\n    VertexOut in [[stage_in]],\n    texture2d<float> tex [[texture(0)]]\n) {\n    // Calculate mip level from UV derivatives\n    float2 dx = dfdx(in.texcoord);\n    float2 dy = dfdy(in.texcoord);\n    float delta = max(dot(dx, dx), dot(dy, dy));\n    float mip = 0.5 * log2(delta * tex.get_width() * tex.get_width());\n\n    int mip_index = clamp(int(mip), 0, 7);\n    return float4(mip_colors[mip_index], 1.0);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"naninf-detection",children:"NaN/Inf Detection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"float4 nan_check(float4 color) {\n    if (any(isnan(color))) return float4(1, 0, 1, 1);  // Magenta = NaN\n    if (any(isinf(color))) return float4(0, 1, 1, 1);  // Cyan = Inf\n    return color;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"wireframe-overlay",children:"Wireframe Overlay"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"// Barycentric wireframe (requires vertex shader to pass barycentrics)\nfloat wireframe(float3 bary, float thickness) {\n    float3 d = fwidth(bary);\n    float3 a = smoothstep(float3(0), d * thickness, bary);\n    return min(min(a.x, a.y), a.z);\n}\n\nfragment float4 wireframe_overlay(\n    VertexOut in [[stage_in]],\n    constant float4& base_color [[buffer(0)]],\n    constant float4& wire_color [[buffer(1)]]\n) {\n    float edge = wireframe(in.barycentrics, 1.5);\n    return mix(wire_color, base_color, edge);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-timers",children:"Performance Timers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"// Measure shader complexity by counting iterations\nkernel void complexity_visualize(\n    texture2d<float, access::write> output [[texture(0)]],\n    constant uint& max_iterations [[buffer(0)]],\n    uint2 gid [[thread_position_in_grid]]\n) {\n    uint iterations = 0;\n\n    // Your algorithm with iteration counting\n    while (/* condition */ iterations < max_iterations) {\n        // Work...\n        iterations++;\n    }\n\n    float complexity = float(iterations) / float(max_iterations);\n    output.write(float4(heat_map(complexity), 1.0), gid);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"gpu-capture-integration",children:"GPU Capture Integration"}),"\n",(0,i.jsx)(n.p,{children:"Use Xcode GPU Capture for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Frame timeline analysis"}),"\n",(0,i.jsx)(n.li,{children:"Shader profiler"}),"\n",(0,i.jsx)(n.li,{children:"Memory bandwidth"}),"\n",(0,i.jsx)(n.li,{children:"Occupancy metrics"}),"\n",(0,i.jsx)(n.li,{children:"Pipeline state inspection"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Always have a debug mode"}),": Toggle with function constant"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Color-code errors"}),": Magenta for NaN, Cyan for Inf"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visualize intermediate buffers"}),": G-buffer, shadow maps"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Add performance overlays"}),": FPS, draw calls, triangles"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hot-reload shaders"}),": Metal Library at runtime"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"debug-macro-pattern",children:"Debug Macro Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-metal",children:"#if DEBUG_MODE\n    return float4(heat_map(some_value), 1.0);\n#else\n    return final_color;\n#endif\n"})}),"\n",(0,i.jsx)(n.p,{children:"Use function constants for runtime toggling without recompilation."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var a=t(96540);const i={},r=a.createContext(i);function l(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);