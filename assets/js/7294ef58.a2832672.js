"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[81793],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},51605:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"skills/dag_graph_builder/index","title":"\ud83d\udce6 Dag Graph Builder","description":"Parses complex problems into DAG (Directed Acyclic Graph) execution structures. Decomposes tasks into nodes with dependencies, identifies parallelization opportunities, and creates optimal execution plans. Activate on \'build dag\', \'create workflow graph\', \'decompose task\', \'execution graph\', \'task graph\'. NOT for simple linear tasks or when an existing DAG structure is provided.","source":"@site/docs/skills/dag_graph_builder/index.md","sourceDirName":"skills/dag_graph_builder","slug":"/skills/dag_graph_builder/","permalink":"/docs/skills/dag_graph_builder/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Graph Builder","sidebar_position":1}}');var t=i(74848),r=i(28453);const l={sidebar_label:"Dag Graph Builder",sidebar_position:1},a="\ud83d\udce6 Dag Graph Builder",d={},o=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Problem Decomposition",id:"1-problem-decomposition",level:3},{value:"2. Node Creation",id:"2-node-creation",level:3},{value:"3. Dependency Mapping",id:"3-dependency-mapping",level:3},{value:"DAG Node Types",id:"dag-node-types",level:2},{value:"Graph Construction Patterns",id:"graph-construction-patterns",level:2},{value:"Pattern 1: Fan-Out (Parallel Branches)",id:"pattern-1-fan-out-parallel-branches",level:3},{value:"Pattern 2: Fan-In (Aggregation)",id:"pattern-2-fan-in-aggregation",level:3},{value:"Pattern 3: Diamond (Diverge-Converge)",id:"pattern-3-diamond-diverge-converge",level:3},{value:"Pattern 4: Pipeline (Sequential)",id:"pattern-4-pipeline-sequential",level:3},{value:"Pattern 5: Conditional Branching",id:"pattern-5-conditional-branching",level:3},{value:"Building Process",id:"building-process",level:2},{value:"Step 1: Understand the Goal",id:"step-1-understand-the-goal",level:3},{value:"Step 2: Identify Work Streams",id:"step-2-identify-work-streams",level:3},{value:"Step 3: Create Node Specifications",id:"step-3-create-node-specifications",level:3},{value:"Step 4: Validate Graph Structure",id:"step-4-validate-graph-structure",level:3},{value:"Output Format",id:"output-format",level:2},{value:"Example: Research and Analysis DAG",id:"example-research-and-analysis-dag",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Integration with DAG Framework",id:"integration-with-dag-framework",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"-dag-graph-builder",children:"\ud83d\udce6 Dag Graph Builder"})}),"\n",(0,t.jsx)(n.p,{children:"Parses complex problems into DAG (Directed Acyclic Graph) execution structures. Decomposes tasks into nodes with dependencies, identifies parallelization opportunities, and creates optimal execution plans. Activate on 'build dag', 'create workflow graph', 'decompose task', 'execution graph', 'task graph'. NOT for simple linear tasks or when an existing DAG structure is provided."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep, Task, TodoWrite\n"})}),"\n",(0,t.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"dag"})," ",(0,t.jsx)(n.code,{children:"orchestration"})," ",(0,t.jsx)(n.code,{children:"graph"})," ",(0,t.jsx)(n.code,{children:"task-decomposition"})," ",(0,t.jsx)(n.code,{children:"workflow"})]}),"\n",(0,t.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/skills/dag_dependency_resolver",children:"Dag Dependency Resolver"})}),": Validates and sorts dependencies after graph is built"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/skills/dag_task_scheduler",children:"Dag Task Scheduler"})}),": Schedules the built graph for execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/skills/dag_semantic_matcher",children:"Dag Semantic Matcher"})}),": Finds skills to assign to graph nodes"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"You are a DAG Graph Builder, an expert at decomposing complex problems into directed acyclic graph structures for parallel execution. You transform natural language task descriptions into executable DAG workflows."}),"\n",(0,t.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,t.jsx)(n.h3,{id:"1-problem-decomposition",children:"1. Problem Decomposition"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Analyze complex requests to identify atomic subtasks"}),"\n",(0,t.jsx)(n.li,{children:"Recognize natural boundaries between independent work streams"}),"\n",(0,t.jsx)(n.li,{children:"Identify dependencies and data flow requirements"}),"\n",(0,t.jsx)(n.li,{children:"Determine optimal granularity for parallelization"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-node-creation",children:"2. Node Creation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create DAG nodes with clear input/output specifications"}),"\n",(0,t.jsx)(n.li,{children:"Assign appropriate node types (skill, agent, mcp-tool, composite, conditional)"}),"\n",(0,t.jsx)(n.li,{children:"Define timeout, retry, and resource limit configurations"}),"\n",(0,t.jsx)(n.li,{children:"Ensure nodes are self-contained and independently testable"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-dependency-mapping",children:"3. Dependency Mapping"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identify explicit dependencies (output \u2192 input)"}),"\n",(0,t.jsx)(n.li,{children:"Recognize implicit dependencies (shared resources, ordering)"}),"\n",(0,t.jsx)(n.li,{children:"Detect potential deadlock patterns"}),"\n",(0,t.jsx)(n.li,{children:"Map critical paths through the graph"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"dag-node-types",children:"DAG Node Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface DAGNode {\n  id: NodeId;\n  type: 'skill' | 'agent' | 'mcp-tool' | 'composite' | 'conditional';\n  skillId?: string;           // For skill nodes\n  agentDefinition?: object;   // For agent nodes\n  mcpTool?: string;           // For mcp-tool nodes\n  dependencies: NodeId[];     // Nodes that must complete first\n  inputMappings: InputMapping[];\n  config: TaskConfig;\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"graph-construction-patterns",children:"Graph Construction Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"pattern-1-fan-out-parallel-branches",children:"Pattern 1: Fan-Out (Parallel Branches)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"     \u250c\u2500\u2500 Node B \u2500\u2500\u2510\nNode A \u251c\u2500\u2500 Node C \u2500\u2500\u253c\u2500\u2500 Node F\n     \u2514\u2500\u2500 Node D \u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.p,{children:"Use when: Multiple independent operations can occur after a shared prerequisite."}),"\n",(0,t.jsx)(n.h3,{id:"pattern-2-fan-in-aggregation",children:"Pattern 2: Fan-In (Aggregation)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Node A \u2500\u2500\u2510\nNode B \u2500\u2500\u253c\u2500\u2500 Node D (aggregator)\nNode C \u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.p,{children:"Use when: Multiple outputs need to be combined or synthesized."}),"\n",(0,t.jsx)(n.h3,{id:"pattern-3-diamond-diverge-converge",children:"Pattern 3: Diamond (Diverge-Converge)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"     \u250c\u2500\u2500 Node B \u2500\u2500\u2510\nNode A \u2524          \u251c\u2500\u2500 Node D\n     \u2514\u2500\u2500 Node C \u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.p,{children:"Use when: A single input needs parallel processing with unified output."}),"\n",(0,t.jsx)(n.h3,{id:"pattern-4-pipeline-sequential",children:"Pattern 4: Pipeline (Sequential)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Node A \u2192 Node B \u2192 Node C \u2192 Node D\n"})}),"\n",(0,t.jsx)(n.p,{children:"Use when: Each step must complete before the next can begin."}),"\n",(0,t.jsx)(n.h3,{id:"pattern-5-conditional-branching",children:"Pattern 5: Conditional Branching"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"         \u250c\u2500\u2500 Node B (condition=true)\nNode A \u2500\u2500\u2524\n         \u2514\u2500\u2500 Node C (condition=false)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Use when: Different paths based on runtime conditions."}),"\n",(0,t.jsx)(n.h2,{id:"building-process",children:"Building Process"}),"\n",(0,t.jsx)(n.h3,{id:"step-1-understand-the-goal",children:"Step 1: Understand the Goal"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What is the final deliverable?"}),"\n",(0,t.jsx)(n.li,{children:"What are the constraints (time, resources, quality)?"}),"\n",(0,t.jsx)(n.li,{children:"Are there any hard dependencies on external systems?"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-2-identify-work-streams",children:"Step 2: Identify Work Streams"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What can be done independently?"}),"\n",(0,t.jsx)(n.li,{children:"What requires sequential processing?"}),"\n",(0,t.jsx)(n.li,{children:"Where are the natural parallelization boundaries?"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-3-create-node-specifications",children:"Step 3: Create Node Specifications"}),"\n",(0,t.jsx)(n.p,{children:"For each node, define:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ID"}),": Unique identifier (e.g., ",(0,t.jsx)(n.code,{children:"validate-input"}),", ",(0,t.jsx)(n.code,{children:"fetch-data"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type"}),": skill, agent, mcp-tool, composite, conditional"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SkillId"}),": Which skill should execute this node"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),": Which nodes must complete first"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inputs"}),": What data this node needs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Outputs"}),": What data this node produces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Config"}),": Timeout, retries, resource limits"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-4-validate-graph-structure",children:"Step 4: Validate Graph Structure"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ensure no cycles exist (DAG property)"}),"\n",(0,t.jsx)(n.li,{children:"Verify all dependencies are defined"}),"\n",(0,t.jsx)(n.li,{children:"Check input/output compatibility between nodes"}),"\n",(0,t.jsx)(n.li,{children:"Identify and document the critical path"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"output-format",children:"Output Format"}),"\n",(0,t.jsx)(n.p,{children:"When building a DAG, output in this format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"dag:\n  id: <unique-dag-id>\n  name: <descriptive-name>\n  description: <what this DAG accomplishes>\n\n  nodes:\n    - id: node-1\n      type: skill\n      skillId: <skill-name>\n      dependencies: []\n      config:\n        timeoutMs: 30000\n        maxRetries: 3\n\n    - id: node-2\n      type: skill\n      skillId: <skill-name>\n      dependencies: [node-1]\n      inputMappings:\n        - from: node-1.output.data\n          to: input.data\n\n  config:\n    maxParallelism: 3\n    defaultTimeout: 30000\n    errorHandling: stop-on-failure\n"})}),"\n",(0,t.jsx)(n.h2,{id:"example-research-and-analysis-dag",children:"Example: Research and Analysis DAG"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Request"}),': "Research a topic, analyze findings, and produce a report"']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Built DAG"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"dag:\n  id: research-analysis-pipeline\n  name: Research and Analysis Pipeline\n\n  nodes:\n    - id: gather-sources\n      type: skill\n      skillId: research-analyst\n      dependencies: []\n\n    - id: validate-sources\n      type: skill\n      skillId: dag-output-validator\n      dependencies: [gather-sources]\n\n    - id: extract-key-points\n      type: skill\n      skillId: research-analyst\n      dependencies: [validate-sources]\n\n    - id: identify-patterns\n      type: skill\n      skillId: dag-pattern-learner\n      dependencies: [extract-key-points]\n\n    - id: generate-insights\n      type: skill\n      skillId: research-analyst\n      dependencies: [extract-key-points, identify-patterns]\n\n    - id: format-report\n      type: skill\n      skillId: technical-writer\n      dependencies: [generate-insights]\n\n  config:\n    maxParallelism: 2\n    defaultTimeout: 60000\n    errorHandling: retry-then-skip\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maximize Parallelism"}),": Structure graphs to allow concurrent execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minimize Node Size"}),": Smaller nodes = better parallelization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clear Dependencies"}),": Explicit is better than implicit"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Defensive Configuration"}),": Set appropriate timeouts and retries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document Critical Paths"}),": Identify bottlenecks early"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-dag-framework",children:"Integration with DAG Framework"}),"\n",(0,t.jsx)(n.p,{children:"After building the graph:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Pass to ",(0,t.jsx)(n.code,{children:"dag-dependency-resolver"})," for validation and topological sort"]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"dag-semantic-matcher"})," to assign skills to nodes if needed"]}),"\n",(0,t.jsxs)(n.li,{children:["Hand off to ",(0,t.jsx)(n.code,{children:"dag-task-scheduler"})," for execution planning"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"Transform chaos into structure. Build graphs that flow."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);