"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[78975],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const i={},c=r.createContext(i);function s(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(c.Provider,{value:n},e.children)}},36744:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"skills/pwa_expert/references/background-sync","title":"Background Sync","description":"Background Sync allows queuing actions while offline and executing them when connectivity returns.","source":"@site/docs/skills/pwa_expert/references/background-sync.md","sourceDirName":"skills/pwa_expert/references","slug":"/skills/pwa_expert/references/background-sync","permalink":"/docs/skills/pwa_expert/references/background-sync","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Background Sync","sidebar_label":"Background Sync","sidebar_position":1}}');var i=t(74848),c=t(28453);const s={title:"Background Sync",sidebar_label:"Background Sync",sidebar_position:1},a="Background Sync",o={},d=[{value:"Service Worker Sync Handler",id:"service-worker-sync-handler",level:2},{value:"Register Sync from App",id:"register-sync-from-app",level:2},{value:"IndexedDB Helper",id:"indexeddb-helper",level:2},{value:"Sync with Retry Logic",id:"sync-with-retry-logic",level:2},{value:"Browser Support",id:"browser-support",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"background-sync",children:"Background Sync"})}),"\n",(0,i.jsx)(n.p,{children:"Background Sync allows queuing actions while offline and executing them when connectivity returns."}),"\n",(0,i.jsx)(n.h2,{id:"service-worker-sync-handler",children:"Service Worker Sync Handler"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// In service worker\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'sync-checkins') {\n    event.waitUntil(syncCheckins());\n  }\n});\n\nasync function syncCheckins() {\n  const db = await openDB();\n  const pendingCheckins = await db.getAll('pending-checkins');\n\n  for (const checkin of pendingCheckins) {\n    try {\n      await fetch('/api/checkins', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(checkin),\n      });\n      await db.delete('pending-checkins', checkin.id);\n    } catch (error) {\n      // Will retry on next sync\n      console.error('Sync failed:', error);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"register-sync-from-app",children:"Register Sync from App"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// When saving data offline\nasync function saveCheckin(data: CheckinData) {\n  // Save to IndexedDB first\n  await db.add('pending-checkins', { ...data, id: crypto.randomUUID() });\n\n  // Request background sync\n  if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n    const registration = await navigator.serviceWorker.ready;\n    await registration.sync.register('sync-checkins');\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"indexeddb-helper",children:"IndexedDB Helper"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// lib/db.ts\nimport { openDB as idbOpen } from 'idb';\n\nexport async function openDB() {\n  return idbOpen('jb4l-offline', 1, {\n    upgrade(db) {\n      db.createObjectStore('pending-checkins', { keyPath: 'id' });\n      db.createObjectStore('pending-journal', { keyPath: 'id' });\n    },\n  });\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"sync-with-retry-logic",children:"Sync with Retry Logic"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"async function syncWithRetry(items, endpoint, storeName, maxRetries = 3) {\n  const db = await openDB();\n\n  for (const item of items) {\n    let attempts = item.attempts || 0;\n\n    try {\n      await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(item.data),\n      });\n\n      // Success - remove from queue\n      await db.delete(storeName, item.id);\n\n    } catch (error) {\n      attempts++;\n\n      if (attempts >= maxRetries) {\n        // Move to failed queue for manual review\n        await db.put('failed-syncs', { ...item, attempts, error: error.message });\n        await db.delete(storeName, item.id);\n      } else {\n        // Update attempt count\n        await db.put(storeName, { ...item, attempts });\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"browser-support",children:"Browser Support"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Chrome 49+"}),"\n",(0,i.jsx)(n.li,{children:"Edge 79+"}),"\n",(0,i.jsx)(n.li,{children:"Firefox: Behind flag"}),"\n",(0,i.jsx)(n.li,{children:"Safari: Not supported (use periodic manual sync)"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);