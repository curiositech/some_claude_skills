"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[18509],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var a=i(96540);const r={},t=a.createContext(r);function s(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(t.Provider,{value:n},e.children)}},90523:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"skills/collage_layout_expert/references/mathematical-foundations","title":"Mathematical Foundations","description":"Optimal Transport for Color Harmonization","source":"@site/docs/skills/collage_layout_expert/references/mathematical-foundations.md","sourceDirName":"skills/collage_layout_expert/references","slug":"/skills/collage_layout_expert/references/mathematical-foundations","permalink":"/docs/skills/collage_layout_expert/references/mathematical-foundations","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Mathematical Foundations","sidebar_label":"Mathematical Foundations","sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Line Detection Algorithms (...","permalink":"/docs/skills/collage_layout_expert/references/line-detection"},"next":{"title":"2000s Visualization Expert","permalink":"/docs/skills/2000s_visualization_expert/"}}');var r=i(74848),t=i(28453);const s={title:"Mathematical Foundations",sidebar_label:"Mathematical Foundations",sidebar_position:9},o="Mathematical Foundations",l={},c=[{value:"Optimal Transport for Color Harmonization",id:"optimal-transport-for-color-harmonization",level:2},{value:"Wasserstein Distance (Earth Mover&#39;s Distance)",id:"wasserstein-distance-earth-movers-distance",level:3},{value:"Sinkhorn Algorithm (entropy-regularized)",id:"sinkhorn-algorithm-entropy-regularized",level:3},{value:"Affine Approximation (for real-time)",id:"affine-approximation-for-real-time",level:3},{value:"Why LAB Space",id:"why-lab-space",level:3},{value:"Poisson Blending for Seamless Junctions",id:"poisson-blending-for-seamless-junctions",level:2},{value:"Poisson Equation",id:"poisson-equation",level:3},{value:"Discrete Form (pixel grid)",id:"discrete-form-pixel-grid",level:3},{value:"Jacobi Iteration Solver",id:"jacobi-iteration-solver",level:3},{value:"Metal Implementation (GPU acceleration)",id:"metal-implementation-gpu-acceleration",level:3},{value:"Energy Function for Composition Optimization",id:"energy-function-for-composition-optimization",level:2},{value:"Total Energy",id:"total-energy",level:3},{value:"1. Semantic Energy (CLIP similarity)",id:"1-semantic-energy-clip-similarity",level:3},{value:"2. Geometric Energy (boundary compatibility)",id:"2-geometric-energy-boundary-compatibility",level:3},{value:"3. Aesthetic Energy (composition principles)",id:"3-aesthetic-energy-composition-principles",level:3},{value:"Typical Weight Values",id:"typical-weight-values",level:3},{value:"User Modes",id:"user-modes",level:3},{value:"Aesthetic Principles",id:"aesthetic-principles",level:2},{value:"Rule of Thirds",id:"rule-of-thirds",level:3},{value:"Visual Weight",id:"visual-weight",level:3},{value:"Balance Score",id:"balance-score",level:3},{value:"Golden Ratio",id:"golden-ratio",level:3},{value:"Negative Space Quality",id:"negative-space-quality",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"mathematical-foundations",children:"Mathematical Foundations"})}),"\n",(0,r.jsx)(n.h2,{id:"optimal-transport-for-color-harmonization",children:"Optimal Transport for Color Harmonization"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Harmonize shard colors with global palette without destroying local structure."]}),"\n",(0,r.jsx)(n.h3,{id:"wasserstein-distance-earth-movers-distance",children:"Wasserstein Distance (Earth Mover's Distance)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"W\u2082(\u03bc, \u03bd)\xb2 = inf{\u03b3 \u2208 \u03a0(\u03bc,\u03bd)} \u222b\u222b \u2016x - y\u2016\xb2 d\u03b3(x,y)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u03bc = shard's color distribution (LAB histogram)"}),"\n",(0,r.jsx)(n.li,{children:"\u03bd = target/global distribution"}),"\n",(0,r.jsx)(n.li,{children:"\u03b3 = transport plan (how to move color mass)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sinkhorn-algorithm-entropy-regularized",children:"Sinkhorn Algorithm (entropy-regularized)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def sinkhorn_optimal_transport(source_hist, target_hist, epsilon=0.1, max_iters=100):\n    """\n    Compute optimal transport plan using Sinkhorn iterations.\n    epsilon: regularization strength (smaller = closer to true OT)\n    """\n    # Cost matrix: squared distances in LAB space\n    C = compute_cost_matrix_lab(source_hist.bins, target_hist.bins)\n\n    # Kernel matrix\n    K = np.exp(-C / epsilon)\n\n    # Initialize\n    u = np.ones(len(source_hist))\n    v = np.ones(len(target_hist))\n\n    # Iterate (converges exponentially fast)\n    for _ in range(max_iters):\n        u = source_hist.weights / (K @ v)\n        v = target_hist.weights / (K.T @ u)\n\n    # Optimal transport plan\n    gamma = np.diag(u) @ K @ np.diag(v)\n\n    return gamma  # gamma[i,j] = mass to move from bin i to bin j\n'})}),"\n",(0,r.jsx)(n.h3,{id:"affine-approximation-for-real-time",children:"Affine Approximation (for real-time)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def fit_affine_color_transform(source_hist, target_hist):\n    """\n    Approximate optimal transport as affine transform in LAB space.\n    Returns: (M, b) where transformed_color = M @ color + b\n    """\n    # 1. Compute OT plan\n    gamma = sinkhorn_optimal_transport(source_hist, target_hist)\n\n    # 2. Sample points from distributions\n    source_samples = source_hist.sample(n=256)\n    target_samples = target_hist.sample(n=256)\n\n    # 3. Weighted least squares\n    X = source_samples  # Nx3 (L, a, b)\n    Y = target_samples  # Mx3\n\n    M = (Y.T @ gamma @ X.T) @ np.linalg.inv(X.T @ gamma.T @ X)\n    b = target_hist.mean() - M @ source_hist.mean()\n\n    return M, b\n'})}),"\n",(0,r.jsx)(n.h3,{id:"why-lab-space",children:"Why LAB Space"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Perceptually uniform"}),": Euclidean distance \u2248 perceived color difference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Separates luminance from chrominance"}),": L (lightness), a (green-red), b (blue-yellow)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better blending"}),": Avoids hue shifts that occur in RGB"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"poisson-blending-for-seamless-junctions",children:"Poisson Blending for Seamless Junctions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Blend overlapping halos without visible seams."]}),"\n",(0,r.jsx)(n.h3,{id:"poisson-equation",children:"Poisson Equation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u2207\xb2f = div(g)  in \u03a9\nf = T         on \u2202\u03a9\n"})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"f = unknown blended image"}),"\n",(0,r.jsx)(n.li,{children:"g = guidance field (gradients from source images)"}),"\n",(0,r.jsx)(n.li,{children:"\u03a9 = blend region (halo intersection)"}),"\n",(0,r.jsx)(n.li,{children:"\u2202\u03a9 = boundary (fixed to target values)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"discrete-form-pixel-grid",children:"Discrete Form (pixel grid)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# For each interior pixel (i, j):\n4\xb7f[i,j] - f[i-1,j] - f[i+1,j] - f[i,j-1] - f[i,j+1] = div(g)[i,j]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"jacobi-iteration-solver",children:"Jacobi Iteration Solver"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def poisson_blend_jacobi(source, target, mask, max_iters=50):\n    """\n    Solve Poisson equation using Jacobi iteration.\n    Perfect for GPU parallelization (Metal shader).\n    """\n    # Compute guidance field (source gradients)\n    gx = np.gradient(source, axis=1)\n    gy = np.gradient(source, axis=0)\n\n    # Divergence of guidance field\n    div_g = np.gradient(gx, axis=1) + np.gradient(gy, axis=0)\n\n    # Initialize solution with target\n    f = target.copy()\n    f_new = f.copy()\n\n    # Iterate\n    for iteration in range(max_iters):\n        for i in range(1, mask.shape[0] - 1):\n            for j in range(1, mask.shape[1] - 1):\n                if mask[i, j]:  # Interior pixel\n                    f_new[i, j] = 0.25 * (\n                        f[i-1, j] + f[i+1, j] +\n                        f[i, j-1] + f[i, j+1] +\n                        div_g[i, j]\n                    )\n                # else: boundary pixel, keep f_new[i,j] = target[i,j]\n\n        f = f_new.copy()\n\n    return f\n'})}),"\n",(0,r.jsx)(n.h3,{id:"metal-implementation-gpu-acceleration",children:"Metal Implementation (GPU acceleration)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-metal",children:"kernel void poisson_jacobi_step(\n    texture2d<float, access::read> f_current [[texture(0)]],\n    texture2d<float, access::read> divergence [[texture(1)]],\n    texture2d<float, access::write> f_next [[texture(2)]],\n    texture2d<uint, access::read> mask [[texture(3)]],\n    uint2 gid [[thread_position_in_grid]]\n) {\n    if (mask.read(gid).r == 0) {\n        // Boundary: keep original\n        f_next.write(f_current.read(gid), gid);\n        return;\n    }\n\n    // Interior: Jacobi update\n    float left  = f_current.read(gid + uint2(-1,  0)).r;\n    float right = f_current.read(gid + uint2( 1,  0)).r;\n    float down  = f_current.read(gid + uint2( 0, -1)).r;\n    float up    = f_current.read(gid + uint2( 0,  1)).r;\n    float div   = divergence.read(gid).r;\n\n    float f_new = 0.25 * (left + right + down + up + div);\n\n    f_next.write(float4(f_new, 0, 0, 0), gid);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": ~20ms for 512\xd7512 image on M2 GPU (50 iterations)"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"energy-function-for-composition-optimization",children:"Energy Function for Composition Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"total-energy",children:"Total Energy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"E(C) = \u03b1\xb7E_semantic(C) + \u03b2\xb7E_geometric(C) + \u03b3\xb7E_aesthetic(C)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"1-semantic-energy-clip-similarity",children:"1. Semantic Energy (CLIP similarity)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_semantic_energy(canvas):\n    """Reward semantically coherent adjacencies."""\n    energy = 0.0\n\n    for (i, j) in canvas.adjacent_pairs():\n        similarity = cosine_similarity(\n            canvas.shards[i].clip_embedding,\n            canvas.shards[j].clip_embedding\n        )\n        energy -= similarity  # Negative: higher similarity \u2192 lower energy\n\n    return energy / len(canvas.adjacent_pairs())\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-geometric-energy-boundary-compatibility",children:"2. Geometric Energy (boundary compatibility)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_geometric_energy(canvas):\n    """Penalize geometric incompatibilities at junctions."""\n    energy = 0.0\n\n    for (i, j) in canvas.adjacent_pairs():\n        # Tangent angle mismatch\n        angle_diff = abs(canvas.tangent_angle[i] - canvas.tangent_angle[j])\n        angle_diff = min(angle_diff, 180 - angle_diff)\n        energy += (angle_diff / 180.0) ** 2\n\n        # Curvature mismatch\n        curv_diff = abs(canvas.curvature[i] - canvas.curvature[j])\n        energy += curv_diff ** 2\n\n    return energy / len(canvas.adjacent_pairs())\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-aesthetic-energy-composition-principles",children:"3. Aesthetic Energy (composition principles)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_aesthetic_energy(canvas):\n    """Classical aesthetic principles."""\n\n    # Balance: visual weight distribution\n    weights = [compute_visual_weight(s) for s in canvas.shards]\n    quadrants = canvas.divide_into_quadrants()\n    quadrant_weights = [sum(weights[s] for s in q) for q in quadrants]\n    balance = np.var(quadrant_weights)\n\n    # Symmetry\n    symmetry = compute_symmetry(canvas)\n\n    # Density variance\n    density_grid = canvas.compute_density_grid(grid_size=10)\n    density_variance = np.var(density_grid)\n\n    # Rule of thirds\n    thirds_score = compute_rule_of_thirds_score(canvas)\n\n    return (\n        0.3 * balance +\n        0.2 * (1 - symmetry) +\n        0.3 * density_variance +\n        0.2 * (1 - thirds_score)\n    )\n'})}),"\n",(0,r.jsx)(n.h3,{id:"typical-weight-values",children:"Typical Weight Values"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"\u03b1 = 1.0"}),": Semantic coherence is primary"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"\u03b2 = 0.5"}),": Geometry important but secondary"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"\u03b3 = 0.3"}),": Aesthetics are subtle refinements"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"user-modes",children:"User Modes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"Coherent"'}),": \u03b1=1.5, \u03b2=0.8, \u03b3=0.2 (prioritize meaning)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"Balanced"'}),": \u03b1=1.0, \u03b2=0.5, \u03b3=0.3 (default)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'"Chaotic"'}),": \u03b1=0.2, \u03b2=0.1, \u03b3=0.7 (prioritize aesthetics, allow surprises)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"aesthetic-principles",children:"Aesthetic Principles"}),"\n",(0,r.jsx)(n.h3,{id:"rule-of-thirds",children:"Rule of Thirds"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_rule_of_thirds_score(canvas):\n    """Score how well composition follows rule of thirds."""\n    thirds_points = [\n        (1/3, 1/3), (1/3, 2/3),\n        (2/3, 1/3), (2/3, 2/3)\n    ]\n\n    salient_shards = [s for s in canvas.shards if s.salience > 0.7]\n\n    if not salient_shards:\n        return 0.5\n\n    scores = []\n    for shard in salient_shards:\n        center = shard.center_normalized()\n        distances = [\n            np.linalg.norm(np.array(center) - np.array(tp))\n            for tp in thirds_points\n        ]\n        min_distance = min(distances)\n        score = max(0.0, 1.0 - min_distance / 0.5)\n        scores.append(score * shard.salience)\n\n    return np.mean(scores)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"visual-weight",children:"Visual Weight"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_visual_weight(shard):\n    """\n    Visual weight considers:\n    - Area (larger = heavier)\n    - Contrast (higher contrast = heavier)\n    - Color saturation (vibrant = heavier)\n    - Semantic importance (faces = heavier)\n    """\n    weight = shard.area / 10000.0\n    weight *= (1 + shard.contrast)\n    weight *= (1 + shard.saturation)\n\n    if shard.contains_face:\n        weight *= 1.5\n\n    return weight\n'})}),"\n",(0,r.jsx)(n.h3,{id:"balance-score",children:"Balance Score"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_balance(canvas):\n    """Check if visual weight is distributed evenly."""\n    quadrants = canvas.divide_into_quadrants()\n    weights = [\n        sum(compute_visual_weight(s) for s in q)\n        for q in quadrants\n    ]\n\n    variance = np.var(weights)\n    return max(0.0, 1.0 - variance / 10.0)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"golden-ratio",children:"Golden Ratio"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def check_golden_ratio(canvas):\n    """Bonus if composition exhibits \u03c6 \u2248 1.618 proportions."""\n    phi = (1 + np.sqrt(5)) / 2  # 1.618...\n\n    aspect_ratio = canvas.width / canvas.height\n    aspect_score = np.exp(-abs(aspect_ratio - phi))\n\n    return aspect_score\n'})}),"\n",(0,r.jsx)(n.h3,{id:"negative-space-quality",children:"Negative Space Quality"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_negative_space_quality(canvas):\n    """\n    High-quality negative space:\n    - Exists (at least 20% of canvas)\n    - Is simple/clean (low variance)\n    - Is strategically placed\n    """\n    coverage = canvas.compute_coverage()\n    negative_ratio = 1.0 - coverage\n\n    if negative_ratio < 0.2:\n        return 0.0  # Too crowded\n    if negative_ratio > 0.6:\n        return 0.0  # Too sparse\n\n    negative_regions = canvas.extract_negative_space()\n    simplicity = 1.0 - np.mean([np.var(r) for r in negative_regions])\n\n    return simplicity\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);