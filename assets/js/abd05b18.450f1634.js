"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[57104],{25754:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"skills/color_theory_palette_harmony_expert/references/optimal-transport","title":"Optimal Transport for Color Matching","description":"Earth-Mover Distance (Wasserstein Metric)","source":"@site/docs/skills/color_theory_palette_harmony_expert/references/optimal-transport.md","sourceDirName":"skills/color_theory_palette_harmony_expert/references","slug":"/skills/color_theory_palette_harmony_expert/references/optimal-transport","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/optimal-transport","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Optimal Transport for Color Matching","sidebar_label":"Optimal Transport for Color...","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Implementation Guide","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/implementation-guide"},"next":{"title":"Perceptual Color Spaces","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/perceptual-color-spaces"}}');var i=r(74848),s=r(28453);const o={title:"Optimal Transport for Color Matching",sidebar_label:"Optimal Transport for Color...",sidebar_position:4},a="Optimal Transport for Color Matching",l={},c=[{value:"Earth-Mover Distance (Wasserstein Metric)",id:"earth-mover-distance-wasserstein-metric",level:2},{value:"The Palette Matching Problem",id:"the-palette-matching-problem",level:3},{value:"Intuition",id:"intuition",level:3},{value:"Mathematical Formulation",id:"mathematical-formulation",level:3},{value:"Discrete Form (for implementation)",id:"discrete-form-for-implementation",level:3},{value:"Sinkhorn Algorithm: Fast Entropic EMD",id:"sinkhorn-algorithm-fast-entropic-emd",level:2},{value:"Entropic Regularization",id:"entropic-regularization",level:3},{value:"Sinkhorn&#39;s Algorithm",id:"sinkhorns-algorithm",level:3},{value:"Choosing \u03b5",id:"choosing-\u03b5",level:3},{value:"Multiscale Sliced Wasserstein Distance (2024-2025 Cutting Edge)",id:"multiscale-sliced-wasserstein-distance-2024-2025-cutting-edge",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Algorithm",id:"algorithm",level:3},{value:"When to Use MS-SWD vs Sinkhorn",id:"when-to-use-ms-swd-vs-sinkhorn",level:3},{value:"Sinkhorn Algorithm Tuning",id:"sinkhorn-algorithm-tuning",level:2},{value:"Approximate EMD for Large Palettes",id:"approximate-emd-for-large-palettes",level:2},{value:"Adaptive Epsilon for Sinkhorn",id:"adaptive-epsilon-for-sinkhorn",level:2},{value:"References",id:"references",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"optimal-transport-for-color-matching",children:"Optimal Transport for Color Matching"})}),"\n",(0,i.jsx)(n.h2,{id:"earth-mover-distance-wasserstein-metric",children:"Earth-Mover Distance (Wasserstein Metric)"}),"\n",(0,i.jsx)(n.h3,{id:"the-palette-matching-problem",children:"The Palette Matching Problem"}),"\n",(0,i.jsx)(n.p,{children:'Given two photos with color distributions \u03bc and \u03bd, how "different" are they perceptually?'}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Na\xefve Approach:"})," Compare dominant colors pairwise \u2192 ",(0,i.jsx)(n.strong,{children:"WRONG"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ignores color abundance (weight)"}),"\n",(0,i.jsx)(n.li,{children:"Arbitrary pairing"}),"\n",(0,i.jsx)(n.li,{children:"Doesn't capture overall distribution shift"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Correct Approach:"})," Earth-Mover Distance (EMD) / Wasserstein Metric"]}),"\n",(0,i.jsx)(n.h3,{id:"intuition",children:"Intuition"}),"\n",(0,i.jsx)(n.p,{children:"Imagine color histograms as piles of dirt. How much work (distance \xd7 amount) to transform one pile into the other?"}),"\n",(0,i.jsx)(n.h3,{id:"mathematical-formulation",children:"Mathematical Formulation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"2-Wasserstein distance"})," between distributions \u03bc and \u03bd is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"W\u2082(\u03bc, \u03bd)\xb2 = inf{\u03b3 \u2208 \u03a0(\u03bc,\u03bd)} \u222b\u222b \u2016x - y\u2016\xb2 d\u03b3(x,y)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u03a0(\u03bc,\u03bd): Set of all joint probability measures with marginals \u03bc, \u03bd"}),"\n",(0,i.jsx)(n.li,{children:"\u03b3: Transport plan (how much mass to move from color x to color y)"}),"\n",(0,i.jsx)(n.li,{children:"\u2016x - y\u2016\xb2: Squared distance in LAB space (or CIEDE2000)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"discrete-form-for-implementation",children:"Discrete Form (for implementation)"}),"\n",(0,i.jsx)(n.p,{children:"Photos represented as color palettes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u03bc = {(c\u2081, w\u2081), (c\u2082, w\u2082), ..., (c\u2099, w\u2099)}  where \u03a3w\u1d62 = 1\n\u03bd = {(d\u2081, v\u2081), (d\u2082, v\u2082), ..., (d\u2098, v\u2098)}  where \u03a3v\u2c7c = 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"EMD becomes a linear programming problem:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"minimize:   \u03a3\u1d62\u2c7c Cost(c\u1d62, d\u2c7c) \xb7 \u03b3\u1d62\u2c7c\nsubject to: \u03a3\u2c7c \u03b3\u1d62\u2c7c = w\u1d62  \u2200i    (row sums = source weights)\n            \u03a3\u1d62 \u03b3\u1d62\u2c7c = v\u2c7c  \u2200j    (column sums = target weights)\n            \u03b3\u1d62\u2c7c \u2265 0\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where Cost(c\u1d62, d\u2c7c) = CIEDE2000(c\u1d62, d\u2c7c)\xb2 (squared perceptual distance)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem:"})," O(N\xb2M) variables for general LP solvers \u2192 expensive!"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"sinkhorn-algorithm-fast-entropic-emd",children:"Sinkhorn Algorithm: Fast Entropic EMD"}),"\n",(0,i.jsx)(n.h3,{id:"entropic-regularization",children:"Entropic Regularization"}),"\n",(0,i.jsx)(n.p,{children:"Add entropy term to smooth the transport plan:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"minimize:   \u03a3\u1d62\u2c7c Cost(c\u1d62, d\u2c7c) \xb7 \u03b3\u1d62\u2c7c + \u03b5 \xb7 H(\u03b3)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where H(\u03b3) = -\u03a3\u1d62\u2c7c \u03b3\u1d62\u2c7c log(\u03b3\u1d62\u2c7c) is entropy."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Effect:"}),' As \u03b5 \u2192 0, recovers exact EMD. For \u03b5 > 0, transport plan is "spread out" but computation is much faster.']}),"\n",(0,i.jsx)(n.h3,{id:"sinkhorns-algorithm",children:"Sinkhorn's Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def sinkhorn_emd(palette1, palette2, epsilon=0.1, max_iters=100):\n    """\n    Compute approximate EMD using Sinkhorn algorithm.\n\n    Args:\n        palette1: List of (color, weight) tuples in LAB space\n        palette2: List of (color, weight) tuples in LAB space\n        epsilon: Entropic regularization parameter (smaller = more accurate)\n        max_iters: Maximum iterations\n\n    Returns:\n        float: Approximate earth-mover distance\n    """\n    N = len(palette1)\n    M = len(palette2)\n\n    # Extract colors and weights\n    colors1 = np.array([c for c, w in palette1])\n    colors2 = np.array([c for c, w in palette2])\n    a = np.array([w for c, w in palette1])\n    b = np.array([w for c, w in palette2])\n\n    # Compute cost matrix (CIEDE2000 distances squared)\n    C = np.zeros((N, M))\n    for i in range(N):\n        for j in range(M):\n            C[i, j] = ciede2000_squared(colors1[i], colors2[j])\n\n    # Kernel matrix K = exp(-C / \u03b5)\n    K = np.exp(-C / epsilon)\n\n    # Sinkhorn iterations\n    u = np.ones(N)\n    v = np.ones(M)\n\n    for iteration in range(max_iters):\n        u_prev = u.copy()\n        u = a / (K @ v)\n        v = b / (K.T @ u)\n\n        # Check convergence\n        if np.max(np.abs(u - u_prev)) < 1e-6:\n            break\n\n    # Optimal transport plan\n    gamma = np.diag(u) @ K @ np.diag(v)\n\n    # Compute EMD\n    emd = np.sum(gamma * C)\n\n    return np.sqrt(emd)  # Return distance, not squared distance\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Convergence:"})," Exponentially fast, typically 10-50 iterations."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Complexity:"})," O(NM) per iteration (just matrix-vector products)."]}),"\n",(0,i.jsx)(n.h3,{id:"choosing-\u03b5",children:"Choosing \u03b5"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u03b5 = 0.01: Nearly exact EMD, slower convergence (50-100 iterations)"}),"\n",(0,i.jsx)(n.li,{children:"\u03b5 = 0.1: Good approximation, fast (10-20 iterations)"}),"\n",(0,i.jsx)(n.li,{children:"\u03b5 = 1.0: Very approximate, instant (<5 iterations)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"For collage assembly:"})," \u03b5 = 0.1 is recommended balance."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"multiscale-sliced-wasserstein-distance-2024-2025-cutting-edge",children:"Multiscale Sliced Wasserstein Distance (2024-2025 Cutting Edge)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"New Research (ECCV 2024):"})," Multiscale Sliced Wasserstein Distance (MS-SWD) offers:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Faster computation:"})," O(M log M) vs O(M^2.5) for standard Wasserstein"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Handles misalignment:"})," Compares patch distributions, not co-located pixels"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Metric properties:"})," Satisfies non-negativity, symmetry, triangle inequality"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Better than CIEDE2000 for non-aligned images"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Slicing:"})," Project high-dimensional color distributions onto 1D lines"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"1D Wasserstein:"})," Compute EMD in 1D (cheap: just sort and compare)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integration:"})," Average over many random projection directions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multiscale:"})," Repeat at different image pyramid levels"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def multiscale_sliced_wasserstein(palette1, palette2, n_projections=100, n_scales=3):\n    """\n    Compute MS-SWD between two color palettes.\n\n    Based on: "Multiscale Sliced Wasserstein Distances as Perceptual\n    Color Difference Measures" (ECCV 2024)\n\n    Args:\n        palette1: [(color_LAB, weight), ...] for photo 1\n        palette2: [(color_LAB, weight), ...] for photo 2\n        n_projections: Number of random 1D projections\n        n_scales: Number of pyramid scales\n\n    Returns:\n        float: MS-SWD distance\n    """\n    total_distance = 0.0\n\n    for scale in range(n_scales):\n        # At each scale, compute sliced Wasserstein\n        scale_distance = 0.0\n\n        for _ in range(n_projections):\n            # Random unit vector in 3D LAB space\n            theta = np.random.randn(3)\n            theta /= np.linalg.norm(theta)\n\n            # Project colors onto this direction\n            proj1 = [(np.dot(c, theta), w) for c, w in palette1]\n            proj2 = [(np.dot(c, theta), w) for c, w in palette2]\n\n            # Sort by projection value\n            proj1.sort(key=lambda x: x[0])\n            proj2.sort(key=lambda x: x[0])\n\n            # 1D Wasserstein = area between CDFs\n            distance_1d = earth_movers_distance_1d(proj1, proj2)\n            scale_distance += distance_1d\n\n        scale_distance /= n_projections\n        total_distance += scale_distance * (2 ** (-scale))  # Weight by scale\n\n    return total_distance\n'})}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-ms-swd-vs-sinkhorn",children:"When to Use MS-SWD vs Sinkhorn"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"MS-SWD:"})," When photos might have same colors but different spatial distributions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sinkhorn EMD:"})," When you care only about color histogram match (ignores spatial structure)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CIEDE2000 + Sinkhorn:"})," Best for palette-to-palette comparison in collage assembly"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"sinkhorn-algorithm-tuning",children:"Sinkhorn Algorithm Tuning"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# For collage assembly (real-time):\nepsilon = 0.1  # Good approximation, fast\nmax_iters = 50  # Typically converges in 10-20\n\n# For final color grading (offline):\nepsilon = 0.01  # More accurate\nmax_iters = 200  # Allow more iterations\n\n# For quick preview:\nepsilon = 1.0   # Very approximate but instant\nmax_iters = 10\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"approximate-emd-for-large-palettes",children:"Approximate EMD for Large Palettes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def fast_palette_distance(palette1, palette2):\n    """\n    O(N log N) approximate EMD using dominant colors only.\n\n    For real-time preview, use top 3 colors instead of full palette.\n    """\n    # Keep only top 3 colors by weight\n    top1 = sorted(palette1, key=lambda x: x[1], reverse=True)[:3]\n    top2 = sorted(palette2, key=lambda x: x[1], reverse=True)[:3]\n\n    # Renormalize weights\n    total1 = sum(w for c, w in top1)\n    total2 = sum(w for c, w in top2)\n    top1 = [(c, w/total1) for c, w in top1]\n    top2 = [(c, w/total2) for c, w in top2]\n\n    # Compute EMD on small palettes (fast)\n    return sinkhorn_emd(top1, top2, epsilon=0.5, max_iters=20)\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"adaptive-epsilon-for-sinkhorn",children:"Adaptive Epsilon for Sinkhorn"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def adaptive_sinkhorn(palette1, palette2):\n    """Start with high epsilon for rough estimate, refine if needed."""\n    # Quick estimate\n    rough_emd = sinkhorn_emd(palette1, palette2, epsilon=1.0, max_iters=10)\n\n    if rough_emd < 20:  # Very similar\n        return rough_emd\n    elif rough_emd > 80:  # Very different\n        return rough_emd\n    else:  # Uncertain, refine\n        return sinkhorn_emd(palette1, palette2, epsilon=0.05, max_iters=100)\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Peyr\xe9, G., & Cuturi, M. (2019). "Computational Optimal Transport." Foundations and Trends in Machine Learning.'}),"\n",(0,i.jsx)(n.li,{children:'"Multiscale Sliced Wasserstein Distances as Perceptual Color Difference Measures" (ECCV 2024)'}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(96540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);