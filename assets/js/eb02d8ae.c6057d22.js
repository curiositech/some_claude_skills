"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[99922],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},96186:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"skills/event_detection_temporal_intelligence_expert/references/st-dbscan-implementation","title":"ST-DBSCAN Implementation Reference","description":"Standard DBSCAN Review","source":"@site/docs/skills/event_detection_temporal_intelligence_expert/references/st-dbscan-implementation.md","sourceDirName":"skills/event_detection_temporal_intelligence_expert/references","slug":"/skills/event_detection_temporal_intelligence_expert/references/st-dbscan-implementation","permalink":"/docs/skills/event_detection_temporal_intelligence_expert/references/st-dbscan-implementation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"ST-DBSCAN Implementation Reference","sidebar_label":"ST-DBSCAN Implementation Re...","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Place Recognition & Life Ev...","permalink":"/docs/skills/event_detection_temporal_intelligence_expert/references/place-recognition-life-events"},"next":{"title":"Temporal Diversity & Comple...","permalink":"/docs/skills/event_detection_temporal_intelligence_expert/references/temporal-diversity-pipeline"}}');var t=i(74848),r=i(28453);const o={title:"ST-DBSCAN Implementation Reference",sidebar_label:"ST-DBSCAN Implementation Re...",sidebar_position:3},a="ST-DBSCAN Implementation Reference",l={},p=[{value:"Standard DBSCAN Review",id:"standard-dbscan-review",level:2},{value:"ST-DBSCAN (Spatio-Temporal DBSCAN)",id:"st-dbscan-spatio-temporal-dbscan",level:2},{value:"DeepDBSCAN: Integrating Visual Content",id:"deepdbscan-integrating-visual-content",level:2},{value:"Parameter Tuning Guide",id:"parameter-tuning-guide",level:2},{value:"Hierarchical Event Detection",id:"hierarchical-event-detection",level:2},{value:"References",id:"references",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"st-dbscan-implementation-reference",children:"ST-DBSCAN Implementation Reference"})}),"\n",(0,t.jsx)(n.h2,{id:"standard-dbscan-review",children:"Standard DBSCAN Review"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"DBSCAN (Density-Based Spatial Clustering of Applications with Noise):"})}),"\n",(0,t.jsx)(n.p,{children:"Core idea: Clusters are dense regions separated by sparse regions."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u03b5 (epsilon): Maximum distance for neighborhood"}),"\n",(0,t.jsx)(n.li,{children:"MinPts: Minimum points to form dense region"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def dbscan(points, epsilon, min_pts):\n    """\n    Standard DBSCAN clustering.\n\n    Args:\n        points: List of data points\n        epsilon: Neighborhood radius\n        min_pts: Minimum points for core point\n\n    Returns:\n        List of cluster labels (-1 = noise)\n    """\n    labels = [-1] * len(points)  # -1 = unvisited\n    cluster_id = 0\n\n    for i, point in enumerate(points):\n        if labels[i] != -1:\n            continue  # Already visited\n\n        # Find neighbors within epsilon\n        neighbors = find_neighbors(points, point, epsilon)\n\n        if len(neighbors) < min_pts:\n            labels[i] = -2  # Mark as noise\n        else:\n            # Start new cluster\n            expand_cluster(points, labels, i, neighbors, cluster_id,\n                          epsilon, min_pts)\n            cluster_id += 1\n\n    return labels\n\n\ndef find_neighbors(points, query_point, epsilon):\n    """Find all points within epsilon distance."""\n    neighbors = []\n    for i, p in enumerate(points):\n        if distance(query_point, p) <= epsilon:\n            neighbors.append(i)\n    return neighbors\n\n\ndef expand_cluster(points, labels, point_idx, neighbors, cluster_id,\n                   epsilon, min_pts):\n    """Expand cluster by adding density-reachable points."""\n    labels[point_idx] = cluster_id\n\n    queue = list(neighbors)\n    while queue:\n        current_idx = queue.pop(0)\n\n        if labels[current_idx] == -2:  # Was noise\n            labels[current_idx] = cluster_id\n\n        if labels[current_idx] != -1:  # Already processed\n            continue\n\n        labels[current_idx] = cluster_id\n\n        # Find neighbors of current point\n        current_neighbors = find_neighbors(points, points[current_idx], epsilon)\n\n        if len(current_neighbors) >= min_pts:\n            queue.extend(current_neighbors)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"st-dbscan-spatio-temporal-dbscan",children:"ST-DBSCAN (Spatio-Temporal DBSCAN)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Innovation:"})," Separate thresholds for spatial (\u03b51) and temporal (\u03b52) dimensions."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Insight:"})," 100 meters apart in same minute = same event. 100 meters apart 3 days later = different events."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Modified Neighborhood Definition:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"N\u03b51,\u03b52(p) = {q | spatial_dist(p, q) \u2264 \u03b51 AND temporal_dist(p, q) \u2264 \u03b52}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u03b51: Maximum spatial distance (meters, e.g., 100m)"}),"\n",(0,t.jsx)(n.li,{children:"\u03b52: Maximum temporal distance (seconds, e.g., 4 hours = 14400s)"}),"\n",(0,t.jsx)(n.li,{children:"MinPts: Minimum points for core (e.g., 3 photos)"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from datetime import timedelta\nimport numpy as np\n\n@dataclass\nclass PhotoPoint:\n    photo_id: str\n    timestamp: datetime\n    lat: float\n    lon: float\n    # Optional: visual_embedding for content-based clustering\n\n\ndef st_dbscan(photos, eps_spatial_meters, eps_temporal_seconds, min_pts):\n    """\n    Spatio-Temporal DBSCAN for photo event detection.\n\n    Based on: "ST-DBSCAN: An algorithm for clustering spatial-temporal data"\n              (Birant & Kut, 2007)\n\n    Args:\n        photos: List of PhotoPoint objects\n        eps_spatial_meters: Maximum spatial distance (e.g., 100)\n        eps_temporal_seconds: Maximum temporal distance (e.g., 4 * 3600)\n        min_pts: Minimum photos for event (e.g., 3)\n\n    Returns:\n        List of cluster labels (event IDs), -1 = noise\n    """\n    n = len(photos)\n    labels = [-1] * n\n    cluster_id = 0\n\n    for i in range(n):\n        if labels[i] != -1:\n            continue\n\n        # Find spatio-temporal neighbors\n        neighbors = st_neighbors(photos, i, eps_spatial_meters,\n                                eps_temporal_seconds)\n\n        if len(neighbors) < min_pts:\n            labels[i] = -2  # Noise\n        else:\n            expand_st_cluster(photos, labels, i, neighbors, cluster_id,\n                            eps_spatial_meters, eps_temporal_seconds, min_pts)\n            cluster_id += 1\n\n    return labels\n\n\ndef st_neighbors(photos, query_idx, eps_spatial, eps_temporal):\n    """\n    Find spatio-temporal neighbors.\n\n    Both spatial AND temporal constraints must be satisfied.\n    """\n    query = photos[query_idx]\n    neighbors = []\n\n    for i, photo in enumerate(photos):\n        # Temporal distance\n        time_diff = abs((photo.timestamp - query.timestamp).total_seconds())\n\n        # Spatial distance (Haversine formula for GPS)\n        spatial_dist = haversine_distance(query.lat, query.lon,\n                                         photo.lat, photo.lon)\n\n        # Both constraints must be satisfied\n        if time_diff <= eps_temporal and spatial_dist <= eps_spatial:\n            neighbors.append(i)\n\n    return neighbors\n\n\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    """\n    Calculate distance between two GPS coordinates in meters.\n\n    Uses Haversine formula for great-circle distance.\n    """\n    R = 6371000  # Earth radius in meters\n\n    phi1 = np.radians(lat1)\n    phi2 = np.radians(lat2)\n    delta_phi = np.radians(lat2 - lat1)\n    delta_lambda = np.radians(lon2 - lon1)\n\n    a = (np.sin(delta_phi / 2) ** 2 +\n         np.cos(phi1) * np.cos(phi2) * np.sin(delta_lambda / 2) ** 2)\n    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))\n\n    return R * c\n\n\ndef expand_st_cluster(photos, labels, point_idx, neighbors, cluster_id,\n                     eps_spatial, eps_temporal, min_pts):\n    """Expand cluster using spatio-temporal connectivity."""\n    labels[point_idx] = cluster_id\n\n    queue = list(neighbors)\n    processed = {point_idx}\n\n    while queue:\n        current_idx = queue.pop(0)\n\n        if current_idx in processed:\n            continue\n\n        processed.add(current_idx)\n\n        if labels[current_idx] == -2:  # Was noise, add to cluster\n            labels[current_idx] = cluster_id\n\n        if labels[current_idx] != -1:  # Already in cluster\n            continue\n\n        labels[current_idx] = cluster_id\n\n        # Find neighbors of current point\n        current_neighbors = st_neighbors(photos, current_idx,\n                                        eps_spatial, eps_temporal)\n\n        if len(current_neighbors) >= min_pts:\n            queue.extend(current_neighbors)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"deepdbscan-integrating-visual-content",children:"DeepDBSCAN: Integrating Visual Content"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," ST-DBSCAN only uses time + GPS. What about photos taken at same place/time but of different subjects?"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," Wedding at venue. Some photos are ceremony (important), some are empty chairs during setup (mundane)."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," Add visual similarity dimension using CLIP embeddings."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Three-Dimensional Clustering:"})," Time \xd7 Space \xd7 Visual Content"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def deep_st_dbscan(photos, eps_spatial, eps_temporal, eps_visual, min_pts):\n    """\n    DeepDBSCAN: ST-DBSCAN + Visual Similarity.\n\n    Based on: "DeepDBSCAN: Deep Density-Based Clustering for Geo-Tagged Photos"\n              (ISPRS, 2021)\n\n    Args:\n        photos: List of PhotoPoint with .clip_embedding attribute\n        eps_spatial: Spatial threshold (meters)\n        eps_temporal: Temporal threshold (seconds)\n        eps_visual: Visual similarity threshold (cosine distance)\n        min_pts: Minimum photos for event\n\n    Returns:\n        Cluster labels\n    """\n    n = len(photos)\n    labels = [-1] * n\n    cluster_id = 0\n\n    for i in range(n):\n        if labels[i] != -1:\n            continue\n\n        # Find neighbors satisfying ALL THREE constraints\n        neighbors = deep_st_neighbors(photos, i, eps_spatial,\n                                      eps_temporal, eps_visual)\n\n        if len(neighbors) < min_pts:\n            labels[i] = -2  # Noise\n        else:\n            expand_deep_st_cluster(photos, labels, i, neighbors, cluster_id,\n                                  eps_spatial, eps_temporal, eps_visual, min_pts)\n            cluster_id += 1\n\n    return labels\n\n\ndef deep_st_neighbors(photos, query_idx, eps_spatial, eps_temporal, eps_visual):\n    """Find neighbors satisfying time, space, AND visual similarity."""\n    query = photos[query_idx]\n    neighbors = []\n\n    for i, photo in enumerate(photos):\n        # Temporal constraint\n        time_diff = abs((photo.timestamp - query.timestamp).total_seconds())\n        if time_diff > eps_temporal:\n            continue\n\n        # Spatial constraint\n        spatial_dist = haversine_distance(query.lat, query.lon,\n                                         photo.lat, photo.lon)\n        if spatial_dist > eps_spatial:\n            continue\n\n        # Visual similarity (cosine similarity of CLIP embeddings)\n        visual_sim = cosine_similarity(query.clip_embedding,\n                                       photo.clip_embedding)\n\n        # Convert similarity to distance\n        visual_dist = 1 - visual_sim\n\n        if visual_dist <= eps_visual:\n            neighbors.append(i)\n\n    return neighbors\n\n\ndef cosine_similarity(vec1, vec2):\n    """Cosine similarity between two vectors."""\n    return np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2))\n'})}),"\n",(0,t.jsx)(n.h2,{id:"parameter-tuning-guide",children:"Parameter Tuning Guide"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"eps_spatial:  50m for indoor events, 500m for outdoor festivals, 5km for city tours\neps_temporal: 1 hour for short events, 8 hours for day trips, 24 hours for multi-day\neps_visual:   0.3 for similar subjects (all photos of ceremony), 0.5 for diverse event\nmin_pts:      3 for small gatherings, 10 for large events/trips\n"})}),"\n",(0,t.jsx)(n.h2,{id:"hierarchical-event-detection",children:"Hierarchical Event Detection"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"}),' Events have natural hierarchy. "Paris Vacation" contains "Day 1: Louvre Visit", "Day 2: Eiffel Tower", etc.']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," Multi-level ST-DBSCAN with cascading thresholds."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def hierarchical_event_detection(photos):\n    """\n    Detect events at multiple temporal scales.\n\n    Returns:\n        Hierarchy of events (tree structure)\n    """\n    # Level 1: Multi-day events (vacations, trips)\n    high_level_events = st_dbscan(\n        photos,\n        eps_spatial=50_000,  # 50km (whole city/region)\n        eps_temporal=72 * 3600,  # 3 days\n        min_pts=10\n    )\n\n    event_hierarchy = {}\n\n    # Level 2: Daily events within each high-level event\n    for event_id in set(high_level_events):\n        if event_id == -1:  # Skip noise\n            continue\n\n        # Photos in this high-level event\n        event_photos = [p for i, p in enumerate(photos)\n                       if high_level_events[i] == event_id]\n\n        # Cluster into daily sub-events\n        sub_events = st_dbscan(\n            event_photos,\n            eps_spatial=5000,  # 5km (neighborhood)\n            eps_temporal=12 * 3600,  # 12 hours\n            min_pts=3\n        )\n\n        event_hierarchy[event_id] = {\n            \'photos\': event_photos,\n            \'sub_events\': sub_events\n        }\n\n    return event_hierarchy\n'})}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ST-DBSCAN"}),': Birant, D., & Kut, A. (2007). "ST-DBSCAN: An algorithm for clustering spatial-temporal data." Data & Knowledge Engineering.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"DeepDBSCAN"}),': "DeepDBSCAN: Deep Density-Based Clustering for Geo-Tagged Photos" (ISPRS, 2021)']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"HDBSCAN"}),": For hierarchical density-based clustering with automatic parameter selection"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);