"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[20812],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},76926:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"skills/event_detection_temporal_intelligence_expert/references/place-recognition-life-events","title":"Place Recognition & Life Event Detection","description":"Place Recognition & Semantic Location","source":"@site/docs/skills/event_detection_temporal_intelligence_expert/references/place-recognition-life-events.md","sourceDirName":"skills/event_detection_temporal_intelligence_expert/references","slug":"/skills/event_detection_temporal_intelligence_expert/references/place-recognition-life-events","permalink":"/docs/skills/event_detection_temporal_intelligence_expert/references/place-recognition-life-events","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Place Recognition & Life Event Detection","sidebar_label":"Place Recognition & Life Ev...","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Event Significance Scoring ...","permalink":"/docs/skills/event_detection_temporal_intelligence_expert/references/event-scoring-shareability"},"next":{"title":"ST-DBSCAN Implementation Re...","permalink":"/docs/skills/event_detection_temporal_intelligence_expert/references/st-dbscan-implementation"}}');var s=t(74848),o=t(28453);const a={title:"Place Recognition & Life Event Detection",sidebar_label:"Place Recognition & Life Ev...",sidebar_position:2},r="Place Recognition & Life Event Detection",l={},c=[{value:"Place Recognition &amp; Semantic Location",id:"place-recognition--semantic-location",level:2},{value:"Levels of Location Abstraction",id:"levels-of-location-abstraction",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Location-Based Event Labeling",id:"location-based-event-labeling",level:3},{value:"Life Event Detection",id:"life-event-detection",level:2},{value:"Multi-Signal Detection Approach",id:"multi-signal-detection-approach",level:3},{value:"Graduation Detection",id:"graduation-detection",level:3},{value:"Wedding Detection",id:"wedding-detection",level:3},{value:"Birth/Newborn Detection",id:"birthnewborn-detection",level:3},{value:"Residential Move Detection",id:"residential-move-detection",level:3},{value:"Travel Milestone Detection",id:"travel-milestone-detection",level:3},{value:"Life Event Detection Summary",id:"life-event-detection-summary",level:2},{value:"References",id:"references",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"place-recognition--life-event-detection",children:"Place Recognition & Life Event Detection"})}),"\n",(0,s.jsx)(n.h2,{id:"place-recognition--semantic-location",children:"Place Recognition & Semantic Location"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal:"})," Understand WHERE photos were taken beyond GPS coordinates."]}),"\n",(0,s.jsx)(n.h3,{id:"levels-of-location-abstraction",children:"Levels of Location Abstraction"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raw GPS:"})," (40.7589, -73.9851)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Address:"}),' "Times Square, New York, NY"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Semantic Place:"}),' "Tourist landmark, entertainment district"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User Context:"}),' "Vacation destination" vs "Daily commute"']}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class PlaceRecognizer:\n    \"\"\"\n    Multi-level place understanding from GPS coordinates.\n    \"\"\"\n\n    def __init__(self):\n        self.reverse_geocoder = self.init_geocoder()  # OpenStreetMap Nominatim\n        self.user_location_history = {}  # Track user's common places\n\n    def analyze_location(self, lat, lon, photo_history):\n        \"\"\"\n        Analyze location at multiple levels.\n\n        Args:\n            lat, lon: GPS coordinates\n            photo_history: User's photo corpus for context\n\n        Returns:\n            dict with place analysis\n        \"\"\"\n        analysis = {}\n\n        # Level 1: Reverse geocoding\n        address = self.reverse_geocode(lat, lon)\n        analysis['address'] = address\n\n        # Level 2: Place categorization\n        place_type = self.categorize_place(address)\n        analysis['place_type'] = place_type\n\n        # Level 3: Frequency in user's history\n        frequency = self.compute_location_frequency(lat, lon, photo_history)\n        analysis['frequency'] = frequency\n\n        # Level 4: User context\n        if frequency > 0.1:\n            analysis['user_context'] = 'familiar'  # Home, work, frequent spots\n        elif frequency > 0.01:\n            analysis['user_context'] = 'occasional'\n        else:\n            analysis['user_context'] = 'novel'  # Travel, rare visit\n\n        # Level 5: Semantic richness\n        analysis['is_landmark'] = self.is_famous_landmark(address)\n        analysis['is_natural'] = 'park' in place_type or 'beach' in place_type\n        analysis['is_urban'] = 'city' in address.lower() or 'downtown' in address.lower()\n\n        return analysis\n\n    def categorize_place(self, address):\n        \"\"\"Categorize place type from address keywords.\"\"\"\n        address_lower = address.lower()\n\n        place_keywords = {\n            'landmark': ['tower', 'monument', 'statue', 'palace', 'temple'],\n            'restaurant': ['restaurant', 'cafe', 'bistro', 'diner'],\n            'park': ['park', 'garden', 'trail', 'forest'],\n            'beach': ['beach', 'coast', 'shore'],\n            'museum': ['museum', 'gallery', 'exhibition'],\n            'venue': ['stadium', 'arena', 'theater', 'concert hall'],\n            'transit': ['airport', 'station', 'terminal'],\n        }\n\n        for place_type, keywords in place_keywords.items():\n            if any(kw in address_lower for kw in keywords):\n                return place_type\n\n        return 'generic'\n"})}),"\n",(0,s.jsx)(n.h3,{id:"location-based-event-labeling",children:"Location-Based Event Labeling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def label_event_by_location(event_photos, place_recognizer):\n    """\n    Automatically label event based on location.\n\n    Examples:\n    - "Trip to Paris"\n    - "Visit to Grandma\'s House"\n    - "Yellowstone National Park"\n    """\n    # Get median location\n    median_lat = np.median([p.lat for p in event_photos])\n    median_lon = np.median([p.lon for p in event_photos])\n\n    # Analyze place\n    place_analysis = place_recognizer.analyze_location(\n        median_lat, median_lon, event_photos\n    )\n\n    # Generate label\n    if place_analysis[\'is_landmark\']:\n        landmark_name = extract_landmark_name(place_analysis[\'address\'])\n        return f"Visit to {landmark_name}"\n\n    elif place_analysis[\'user_context\'] == \'novel\':\n        city = extract_city(place_analysis[\'address\'])\n        return f"Trip to {city}"\n\n    elif place_analysis[\'user_context\'] == \'familiar\':\n        return "At Home"\n\n    else:\n        return place_analysis[\'place_type\'].title()\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"life-event-detection",children:"Life Event Detection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal:"})," Automatically detect major life events (graduations, weddings, births, etc.)"]}),"\n",(0,s.jsx)(n.h3,{id:"multi-signal-detection-approach",children:"Multi-Signal Detection Approach"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class LifeEventDetector:\n    """\n    Detect major life events from photo collection.\n    """\n\n    def detect_life_events(self, photo_corpus):\n        """\n        Scan corpus for life events.\n\n        Returns:\n            List of LifeEvent objects\n        """\n        life_events = []\n\n        life_events.extend(self.detect_graduations(photo_corpus))\n        life_events.extend(self.detect_weddings(photo_corpus))\n        life_events.extend(self.detect_births(photo_corpus))\n        life_events.extend(self.detect_moves(photo_corpus))\n        life_events.extend(self.detect_travel_milestones(photo_corpus))\n\n        return life_events\n'})}),"\n",(0,s.jsx)(n.h3,{id:"graduation-detection",children:"Graduation Detection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signals:"})," Academic regalia, diplomas, ceremony settings"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def detect_graduations(self, photos):\n    \"\"\"Detect graduation events using CLIP zero-shot classification.\"\"\"\n    graduation_events = []\n\n    for event in self.cluster_events(photos):\n        signals = {\n            'cap_gown': 0,\n            'diploma': 0,\n            'auditorium': 0,\n            'formal_group': 0,\n        }\n\n        for photo in event.photos:\n            probs = clip_classify(photo.image, [\n                'graduation cap and gown',\n                'diploma certificate',\n                'auditorium ceremony',\n                'formal group photo',\n            ])\n\n            for key, prob in zip(signals.keys(), probs):\n                if prob > 0.4:\n                    signals[key] = max(signals[key], prob)\n\n        # Weighted confidence\n        confidence = (\n            signals['cap_gown'] * 0.4 +\n            signals['diploma'] * 0.3 +\n            signals['auditorium'] * 0.2 +\n            signals['formal_group'] * 0.1\n        )\n\n        if confidence > 0.6:\n            graduation_events.append(LifeEvent(\n                type='graduation',\n                timestamp=event.start_time,\n                photos=event.photos,\n                confidence=confidence\n            ))\n\n    return graduation_events\n"})}),"\n",(0,s.jsx)(n.h3,{id:"wedding-detection",children:"Wedding Detection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signals:"})," Formal attire, flowers, rings, venue"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def detect_weddings(self, photos):\n    \"\"\"Detect wedding events.\"\"\"\n    wedding_events = []\n\n    for event in self.cluster_events(photos):\n        signals = clip_classify_batch(event.photos, [\n            'wedding dress and tuxedo',\n            'wedding bouquet',\n            'wedding rings',\n            'wedding ceremony venue',\n            'wedding cake',\n        ])\n\n        avg_signals = np.mean(signals, axis=0)\n        confidence = np.max(avg_signals)\n\n        if confidence > 0.7:\n            wedding_events.append(LifeEvent(\n                type='wedding',\n                timestamp=event.start_time,\n                photos=event.photos,\n                confidence=confidence\n            ))\n\n    return wedding_events\n"})}),"\n",(0,s.jsx)(n.h3,{id:"birthnewborn-detection",children:"Birth/Newborn Detection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signals:"})," Hospital setting, newborn, new face cluster appearing"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def detect_births(self, photos):\n    \"\"\"\n    Detect newborn/birth events.\n\n    Key insight: Look for sudden appearance of new face cluster (newborn)\n    \"\"\"\n    face_clusters = self.face_clusterer.cluster_all_faces(photos)\n    birth_events = []\n\n    for cluster_id, faces in face_clusters.items():\n        first_appearance = min(f.photo.timestamp for f in faces)\n        cluster_duration = (max(f.photo.timestamp for f in faces) -\n                          first_appearance).days\n\n        # Infant detection via CLIP\n        infant_scores = [clip_classify(f.crop, ['infant', 'newborn'])[0]\n                       for f in faces[:10]]\n\n        avg_infant_score = np.mean(infant_scores)\n\n        if avg_infant_score > 0.8 and cluster_duration < 365:\n            birth_events.append(LifeEvent(\n                type='birth',\n                timestamp=first_appearance,\n                photos=[f.photo for f in faces],\n                confidence=avg_infant_score,\n                metadata={'person_cluster_id': cluster_id}\n            ))\n\n    return birth_events\n"})}),"\n",(0,s.jsx)(n.h3,{id:"residential-move-detection",children:"Residential Move Detection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signal:"})," Sudden permanent shift in common photo location"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def detect_moves(self, photos):\n    \"\"\"Detect residential moves via location history analysis.\"\"\"\n    location_clusters = self.cluster_by_location(photos)\n    moves = []\n\n    for i in range(len(location_clusters) - 1):\n        cluster_a = location_clusters[i]\n        cluster_b = location_clusters[i + 1]\n\n        distance = haversine_distance(\n            cluster_a.median_location[0], cluster_a.median_location[1],\n            cluster_b.median_location[0], cluster_b.median_location[1]\n        )\n\n        if distance > 50_000:  # 50km = different city\n            duration_b = (cluster_b.photos[-1].timestamp -\n                        cluster_b.photos[0].timestamp).days\n\n            if duration_b > 30:  # Permanent move (&gt;30 days)\n                moves.append(LifeEvent(\n                    type='residential_move',\n                    timestamp=cluster_b.photos[0].timestamp,\n                    photos=cluster_b.photos[:20],\n                    confidence=0.8,\n                    metadata={\n                        'from': self.get_city_name(cluster_a.median_location),\n                        'to': self.get_city_name(cluster_b.median_location),\n                    }\n                ))\n\n    return moves\n"})}),"\n",(0,s.jsx)(n.h3,{id:"travel-milestone-detection",children:"Travel Milestone Detection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signal:"})," First visit to new country/continent"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def detect_travel_milestones(self, photos):\n    \"\"\"Detect first visits to new countries.\"\"\"\n    location_history = {}\n    milestones = []\n\n    for photo in sorted(photos, key=lambda p: p.timestamp):\n        country = self.get_country(photo.lat, photo.lon)\n\n        if country not in location_history:\n            location_history[country] = photo.timestamp\n\n    for country, first_visit in location_history.items():\n        if country != self.user_home_country:\n            milestones.append(LifeEvent(\n                type='travel_milestone',\n                timestamp=first_visit,\n                photos=self.get_photos_in_country(photos, country)[:10],\n                confidence=1.0,\n                metadata={'country': country, 'milestone': 'first_visit'}\n            ))\n\n    return milestones\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"life-event-detection-summary",children:"Life Event Detection Summary"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event Type"}),(0,s.jsx)(n.th,{children:"Primary Signals"}),(0,s.jsx)(n.th,{children:"Confidence Threshold"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Graduation"}),(0,s.jsx)(n.td,{children:"Cap/gown, diploma, auditorium"}),(0,s.jsx)(n.td,{children:"0.6"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Wedding"}),(0,s.jsx)(n.td,{children:"Formal attire, bouquet, cake"}),(0,s.jsx)(n.td,{children:"0.7"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Birth"}),(0,s.jsx)(n.td,{children:"New infant face cluster, hospital"}),(0,s.jsx)(n.td,{children:"0.8"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Residential Move"}),(0,s.jsx)(n.td,{children:"50km+ location shift, >30 days"}),(0,s.jsx)(n.td,{children:"0.8"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Travel Milestone"}),(0,s.jsx)(n.td,{children:"First visit to new country"}),(0,s.jsx)(n.td,{children:"1.0"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"GeoNames & OpenStreetMap: Reverse geocoding APIs"}),"\n",(0,s.jsx)(n.li,{children:"Face clustering for person tracking across photos"}),"\n",(0,s.jsx)(n.li,{children:"CLIP zero-shot classification for event content detection"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);