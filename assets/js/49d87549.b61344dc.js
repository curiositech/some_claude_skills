"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[30767],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(96540);const o={},i=r.createContext(o);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},63138:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"skills/dag_context_bridger/index","title":"\ud83d\udce6 Dag Context Bridger","description":"Manages context passing between DAG nodes and spawned agents. Handles context summarization, selective forwarding, and token budget optimization. Activate on \'bridge context\', \'pass context\', \'summarize context\', \'context management\', \'agent context\'. NOT for execution (use dag-parallel-executor) or aggregation (use dag-result-aggregator).","source":"@site/docs/skills/dag_context_bridger/index.md","sourceDirName":"skills/dag_context_bridger","slug":"/skills/dag_context_bridger/","permalink":"/docs/skills/dag_context_bridger/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Context Bridger","sidebar_position":1}}');var o=t(74848),i=t(28453);const a={sidebar_label:"Dag Context Bridger",sidebar_position:1},s="\ud83d\udce6 Dag Context Bridger",d={},l=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Context Collection",id:"1-context-collection",level:3},{value:"2. Context Summarization",id:"2-context-summarization",level:3},{value:"3. Context Forwarding",id:"3-context-forwarding",level:3},{value:"4. Token Optimization",id:"4-token-optimization",level:3},{value:"Context Flow Model",id:"context-flow-model",level:2},{value:"Context Bridging Strategies",id:"context-bridging-strategies",level:2},{value:"Strategy 1: Full Forward",id:"strategy-1-full-forward",level:3},{value:"Strategy 2: Output Only",id:"strategy-2-output-only",level:3},{value:"Strategy 3: Summarized",id:"strategy-3-summarized",level:3},{value:"Strategy 4: Selective",id:"strategy-4-selective",level:3},{value:"Summarization Techniques",id:"summarization-techniques",level:2},{value:"Hierarchical Summarization",id:"hierarchical-summarization",level:3},{value:"Progressive Context Loading",id:"progressive-context-loading",level:3},{value:"Context Configuration",id:"context-configuration",level:2},{value:"Token Budget Management",id:"token-budget-management",level:2},{value:"Context Tracking",id:"context-tracking",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"-dag-context-bridger",children:"\ud83d\udce6 Dag Context Bridger"})}),"\n",(0,o.jsx)(n.p,{children:"Manages context passing between DAG nodes and spawned agents. Handles context summarization, selective forwarding, and token budget optimization. Activate on 'bridge context', 'pass context', 'summarize context', 'context management', 'agent context'. NOT for execution (use dag-parallel-executor) or aggregation (use dag-result-aggregator)."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,o.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"dag"})," ",(0,o.jsx)(n.code,{children:"orchestration"})," ",(0,o.jsx)(n.code,{children:"context"})," ",(0,o.jsx)(n.code,{children:"summarization"})," ",(0,o.jsx)(n.code,{children:"token-management"})]}),"\n",(0,o.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/skills/dag_parallel_executor",children:"Dag Parallel Executor"})}),": Provides context to spawned agents"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/skills/dag_result_aggregator",children:"Dag Result Aggregator"})}),": Receives context from aggregated results"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/docs/skills/dag_performance_profiler",children:"Dag Performance Profiler"})}),": Tracks context token usage"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You are a DAG Context Bridger, an expert at managing context flow between DAG nodes and spawned agents. You optimize context passing to minimize token usage while preserving essential information for downstream tasks."}),"\n",(0,o.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,o.jsx)(n.h3,{id:"1-context-collection",children:"1. Context Collection"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Gather relevant context from completed nodes"}),"\n",(0,o.jsx)(n.li,{children:"Filter context by relevance to downstream tasks"}),"\n",(0,o.jsx)(n.li,{children:"Track context provenance and dependencies"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"2-context-summarization",children:"2. Context Summarization"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Compress large contexts to fit token budgets"}),"\n",(0,o.jsx)(n.li,{children:"Preserve key information during summarization"}),"\n",(0,o.jsx)(n.li,{children:"Create hierarchical summaries for different depths"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"3-context-forwarding",children:"3. Context Forwarding"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Route context to appropriate downstream nodes"}),"\n",(0,o.jsx)(n.li,{children:"Handle context inheritance rules"}),"\n",(0,o.jsx)(n.li,{children:"Manage context scope and visibility"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"4-token-optimization",children:"4. Token Optimization"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Monitor context token usage"}),"\n",(0,o.jsx)(n.li,{children:"Optimize context size for efficiency"}),"\n",(0,o.jsx)(n.li,{children:"Implement progressive context loading"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"context-flow-model",children:"Context Flow Model"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface NodeContext {\n  nodeId: NodeId;\n\n  // Inherited context from dependencies\n  inherited: ContextFragment[];\n\n  // Context generated by this node\n  generated: ContextFragment;\n\n  // Context to forward to dependents\n  forwarded: ContextFragment[];\n\n  // Token accounting\n  tokens: {\n    inherited: number;\n    generated: number;\n    forwarded: number;\n    budget: number;\n  };\n}\n\ninterface ContextFragment {\n  id: string;\n  sourceNode: NodeId;\n  type: 'input' | 'output' | 'summary' | 'metadata';\n  content: unknown;\n  tokenCount: number;\n  relevanceScore?: number;\n  createdAt: Date;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"context-bridging-strategies",children:"Context Bridging Strategies"}),"\n",(0,o.jsx)(n.h3,{id:"strategy-1-full-forward",children:"Strategy 1: Full Forward"}),"\n",(0,o.jsx)(n.p,{children:"Pass all context from dependencies."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"function fullForward(\n  dependencies: NodeContext[]\n): ContextFragment[] {\n  return dependencies.flatMap(dep => [\n    ...dep.inherited,\n    dep.generated,\n  ]);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use when"}),": Token budget is ample, context is small."]}),"\n",(0,o.jsx)(n.h3,{id:"strategy-2-output-only",children:"Strategy 2: Output Only"}),"\n",(0,o.jsx)(n.p,{children:"Forward only the outputs from dependencies."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"function outputOnly(\n  dependencies: NodeContext[]\n): ContextFragment[] {\n  return dependencies.map(dep => dep.generated);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use when"}),": Only final results are needed, not process details."]}),"\n",(0,o.jsx)(n.h3,{id:"strategy-3-summarized",children:"Strategy 3: Summarized"}),"\n",(0,o.jsx)(n.p,{children:"Summarize context to fit within budget."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"async function summarizedForward(\n  dependencies: NodeContext[],\n  tokenBudget: number\n): Promise<ContextFragment[]> {\n  const allContext = fullForward(dependencies);\n  const totalTokens = sumTokens(allContext);\n\n  if (totalTokens <= tokenBudget) {\n    return allContext;\n  }\n\n  // Need to summarize\n  return await summarizeContext(allContext, tokenBudget);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use when"}),": Context exceeds token budget."]}),"\n",(0,o.jsx)(n.h3,{id:"strategy-4-selective",children:"Strategy 4: Selective"}),"\n",(0,o.jsx)(n.p,{children:"Forward only context relevant to downstream task."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"function selectiveForward(\n  dependencies: NodeContext[],\n  downstreamTask: DAGNode,\n  relevanceThreshold: number\n): ContextFragment[] {\n  const allFragments = dependencies.flatMap(dep => [\n    ...dep.inherited,\n    dep.generated,\n  ]);\n\n  return allFragments\n    .map(fragment => ({\n      ...fragment,\n      relevanceScore: calculateRelevance(fragment, downstreamTask),\n    }))\n    .filter(f => f.relevanceScore >= relevanceThreshold)\n    .sort((a, b) => b.relevanceScore - a.relevanceScore);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use when"}),": Downstream task has specific context needs."]}),"\n",(0,o.jsx)(n.h2,{id:"summarization-techniques",children:"Summarization Techniques"}),"\n",(0,o.jsx)(n.h3,{id:"hierarchical-summarization",children:"Hierarchical Summarization"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface SummaryHierarchy {\n  brief: string;      // ~100 tokens\n  standard: string;   // ~500 tokens\n  detailed: string;   // ~2000 tokens\n  full: string;       // Original content\n}\n\nasync function createHierarchicalSummary(\n  context: ContextFragment[]\n): Promise<SummaryHierarchy> {\n  const full = serializeContext(context);\n\n  return {\n    full,\n    detailed: await summarize(full, 2000),\n    standard: await summarize(full, 500),\n    brief: await summarize(full, 100),\n  };\n}\n\nfunction selectSummaryLevel(\n  hierarchy: SummaryHierarchy,\n  tokenBudget: number\n): string {\n  if (tokenBudget >= countTokens(hierarchy.full)) {\n    return hierarchy.full;\n  }\n  if (tokenBudget >= countTokens(hierarchy.detailed)) {\n    return hierarchy.detailed;\n  }\n  if (tokenBudget >= countTokens(hierarchy.standard)) {\n    return hierarchy.standard;\n  }\n  return hierarchy.brief;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"progressive-context-loading",children:"Progressive Context Loading"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface ProgressiveContext {\n  essential: ContextFragment[];  // Always included\n  important: ContextFragment[];  // Include if budget allows\n  optional: ContextFragment[];   // Include only if ample budget\n}\n\nfunction buildProgressiveContext(\n  fragments: ContextFragment[],\n  tokenBudget: number\n): ContextFragment[] {\n  const categorized = categorizeByImportance(fragments);\n  const result: ContextFragment[] = [];\n  let usedTokens = 0;\n\n  // Always include essential\n  for (const fragment of categorized.essential) {\n    result.push(fragment);\n    usedTokens += fragment.tokenCount;\n  }\n\n  // Add important if room\n  for (const fragment of categorized.important) {\n    if (usedTokens + fragment.tokenCount <= tokenBudget) {\n      result.push(fragment);\n      usedTokens += fragment.tokenCount;\n    }\n  }\n\n  // Add optional if still room\n  for (const fragment of categorized.optional) {\n    if (usedTokens + fragment.tokenCount <= tokenBudget) {\n      result.push(fragment);\n      usedTokens += fragment.tokenCount;\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"context-configuration",children:"Context Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"contextBridging:\n  nodeId: process-data\n\n  inheritance:\n    strategy: selective\n    relevanceThreshold: 0.7\n    maxTokens: 4000\n\n  forwarding:\n    strategy: summarized\n    summaryLevel: standard\n    preserveFields:\n      - key_findings\n      - errors\n      - metadata\n\n  optimization:\n    enableCaching: true\n    compressionLevel: medium\n    deduplication: true\n"})}),"\n",(0,o.jsx)(n.h2,{id:"token-budget-management",children:"Token Budget Management"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface TokenBudget {\n  total: number;           // Total budget for execution\n  perNode: number;         // Default per-node budget\n  contextReserve: number;  // Reserved for context passing\n  outputReserve: number;   // Reserved for output\n}\n\nfunction allocateContextBudget(\n  dag: DAG,\n  totalBudget: number\n): Map<NodeId, number> {\n  const budgets = new Map<NodeId, number>();\n  const nodeCount = dag.nodes.size;\n\n  // Reserve 30% for context passing\n  const contextBudget = totalBudget * 0.3;\n  const perNodeBudget = contextBudget / nodeCount;\n\n  for (const [nodeId, node] of dag.nodes) {\n    // Adjust based on dependency count\n    const depCount = node.dependencies.length;\n    const adjustment = 1 + (depCount * 0.1);\n    budgets.set(nodeId, Math.floor(perNodeBudget * adjustment));\n  }\n\n  return budgets;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"context-tracking",children:"Context Tracking"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"contextReport:\n  dagId: research-pipeline\n\n  nodeContexts:\n    - nodeId: gather-sources\n      inherited: 0\n      generated: 1500\n      forwarded: 1500\n\n    - nodeId: analyze-sources\n      inherited: 1500\n      generated: 2000\n      forwarded: 800  # Summarized\n\n    - nodeId: generate-report\n      inherited: 800\n      generated: 3000\n      forwarded: 0\n\n  totals:\n    totalContextTokens: 8800\n    summarizationSavings: 2700\n    averageForwardRatio: 0.65\n"})}),"\n",(0,o.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Receives"}),": Results from ",(0,o.jsx)(n.code,{children:"dag-parallel-executor"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sends"}),": Context to spawned agents via Task tool"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Metrics"}),": Token usage to ",(0,o.jsx)(n.code,{children:"dag-performance-profiler"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Summaries"}),": Via built-in summarization or external tools"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Budget Early"}),": Allocate token budgets before execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Summarize Proactively"}),": Don't wait until budget exceeded"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Track Provenance"}),": Know where each context piece came from"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cache Summaries"}),": Reuse summaries across similar nodes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Monitor Usage"}),": Track actual vs budgeted tokens"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"Context flows. Information preserved. Tokens optimized."})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);