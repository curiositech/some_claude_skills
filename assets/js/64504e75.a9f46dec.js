"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[41947],{28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>l});var n=i(96540);const s={},r=n.createContext(s);function a(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:t},e.children)}},95113:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"skills/bot_developer/references/rate-limiting","title":"Rate Limiting (Production-Grade)","description":"Distributed and adaptive rate limiting implementations.","source":"@site/docs/skills/bot_developer/references/rate-limiting.md","sourceDirName":"skills/bot_developer/references","slug":"/skills/bot_developer/references/rate-limiting","permalink":"/docs/skills/bot_developer/references/rate-limiting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Rate Limiting (Production-Grade)","sidebar_label":"Rate Limiting (Production-G...","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Platform Templates","permalink":"/docs/skills/bot_developer/references/platform-templates"},"next":{"title":"Research Analyst","permalink":"/docs/skills/research_analyst/"}}');var s=i(74848),r=i(28453);const a={title:"Rate Limiting (Production-Grade)",sidebar_label:"Rate Limiting (Production-G...",sidebar_position:4},l="Rate Limiting (Production-Grade)",d={},o=[{value:"Distributed Rate Limiter (Redis)",id:"distributed-rate-limiter-redis",level:2},{value:"Adaptive Rate Limiter (API Response-Based)",id:"adaptive-rate-limiter-api-response-based",level:2},{value:"Common Rate Limit Configurations",id:"common-rate-limit-configurations",level:2},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"rate-limiting-production-grade",children:"Rate Limiting (Production-Grade)"})}),"\n",(0,s.jsx)(t.p,{children:"Distributed and adaptive rate limiting implementations."}),"\n",(0,s.jsx)(t.h2,{id:"distributed-rate-limiter-redis",children:"Distributed Rate Limiter (Redis)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import asyncio\nimport time\nfrom dataclasses import dataclass\nfrom collections import defaultdict\nimport redis.asyncio as redis\n\n@dataclass\nclass RateLimitConfig:\n    requests: int      # Number of requests\n    window: int        # Time window in seconds\n    burst: int = 0     # Additional burst allowance\n\nclass DistributedRateLimiter:\n    """\n    Token bucket rate limiter with Redis backend.\n    Handles distributed deployments and provides consistent limiting\n    across multiple bot instances.\n    """\n\n    def __init__(self, redis_client: redis.Redis, prefix: str = "ratelimit"):\n        self.redis = redis_client\n        self.prefix = prefix\n\n    async def is_allowed(self, key: str, config: RateLimitConfig) -> tuple[bool, float]:\n        """\n        Check if request is allowed under rate limit.\n        Returns: (allowed: bool, retry_after: float)\n        Uses sliding window log algorithm for accuracy.\n        """\n        full_key = f"{self.prefix}:{key}"\n        now = time.time()\n        window_start = now - config.window\n\n        async with self.redis.pipeline(transaction=True) as pipe:\n            # Remove old entries\n            await pipe.zremrangebyscore(full_key, 0, window_start)\n            # Count current entries\n            await pipe.zcard(full_key)\n            # Add new entry\n            await pipe.zadd(full_key, {str(now): now})\n            # Set expiry\n            await pipe.expire(full_key, config.window + 1)\n\n            results = await pipe.execute()\n\n        current_count = results[1]\n        max_allowed = config.requests + config.burst\n\n        if current_count < max_allowed:\n            return True, 0\n\n        # Calculate retry time\n        oldest = await self.redis.zrange(full_key, 0, 0, withscores=True)\n        if oldest:\n            retry_after = oldest[0][1] + config.window - now\n            return False, max(0, retry_after)\n\n        return False, config.window\n'})}),"\n",(0,s.jsx)(t.h2,{id:"adaptive-rate-limiter-api-response-based",children:"Adaptive Rate Limiter (API Response-Based)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"class AdaptiveRateLimiter:\n    \"\"\"\n    Rate limiter that adapts to API responses.\n    Handles Discord's dynamic rate limits, 429s, and global limits.\n    \"\"\"\n\n    def __init__(self):\n        self.buckets: dict[str, dict] = defaultdict(lambda: {\n            'remaining': float('inf'),\n            'reset_at': 0,\n            'limit': float('inf')\n        })\n        self.global_lock = asyncio.Lock()\n        self.global_reset_at = 0\n\n    async def acquire(self, bucket: str) -> None:\n        \"\"\"Wait until we can make a request to this bucket.\"\"\"\n        # Check global limit first\n        if self.global_reset_at > time.time():\n            await asyncio.sleep(self.global_reset_at - time.time())\n\n        bucket_info = self.buckets[bucket]\n\n        if bucket_info['remaining'] <= 0:\n            wait_time = bucket_info['reset_at'] - time.time()\n            if wait_time > 0:\n                await asyncio.sleep(wait_time)\n\n        bucket_info['remaining'] -= 1\n\n    def update_from_headers(self, bucket: str, headers: dict) -> None:\n        \"\"\"Update rate limit info from API response headers.\"\"\"\n        if 'X-RateLimit-Remaining' in headers:\n            self.buckets[bucket]['remaining'] = int(headers['X-RateLimit-Remaining'])\n        if 'X-RateLimit-Reset' in headers:\n            self.buckets[bucket]['reset_at'] = float(headers['X-RateLimit-Reset'])\n        if 'X-RateLimit-Limit' in headers:\n            self.buckets[bucket]['limit'] = int(headers['X-RateLimit-Limit'])\n\n        # Handle global rate limit\n        if headers.get('X-RateLimit-Global'):\n            retry_after = float(headers.get('Retry-After', 1))\n            self.global_reset_at = time.time() + retry_after\n"})}),"\n",(0,s.jsx)(t.h2,{id:"common-rate-limit-configurations",children:"Common Rate Limit Configurations"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Context"}),(0,s.jsx)(t.th,{children:"Requests"}),(0,s.jsx)(t.th,{children:"Window"}),(0,s.jsx)(t.th,{children:"Burst"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"User commands"}),(0,s.jsx)(t.td,{children:"10"}),(0,s.jsx)(t.td,{children:"60s"}),(0,s.jsx)(t.td,{children:"3"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"API calls per user"}),(0,s.jsx)(t.td,{children:"30"}),(0,s.jsx)(t.td,{children:"60s"}),(0,s.jsx)(t.td,{children:"5"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Guild-wide actions"}),(0,s.jsx)(t.td,{children:"100"}),(0,s.jsx)(t.td,{children:"60s"}),(0,s.jsx)(t.td,{children:"10"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Message spam"}),(0,s.jsx)(t.td,{children:"5"}),(0,s.jsx)(t.td,{children:"10s"}),(0,s.jsx)(t.td,{children:"2"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"DM operations"}),(0,s.jsx)(t.td,{children:"5"}),(0,s.jsx)(t.td,{children:"30s"}),(0,s.jsx)(t.td,{children:"1"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Use distributed limiter"})," for multi-instance deployments"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Implement adaptive limits"})," that respect API response headers"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Separate buckets"})," for different action types (commands, API calls, moderation)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Allow small burst"})," for bursty but legitimate use patterns"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Graceful degradation"}),": Inform users of retry time instead of silent failure"]}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);