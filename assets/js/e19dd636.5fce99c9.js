"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[25311],{28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var t=r(96540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},45894:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"skills/llm_streaming_response_handler/references/sse-protocol","title":"Server-Sent Events (SSE) Protocol","description":"Deep dive into the SSE specification and implementation details for LLM streaming.","source":"@site/docs/skills/llm_streaming_response_handler/references/sse-protocol.md","sourceDirName":"skills/llm_streaming_response_handler/references","slug":"/skills/llm_streaming_response_handler/references/sse-protocol","permalink":"/docs/skills/llm_streaming_response_handler/references/sse-protocol","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Server-Sent Events (SSE) Protocol","sidebar_label":"Server-Sent Events (SSE) Pr...","sidebar_position":2}}');var s=r(74848),o=r(28453);const i={title:"Server-Sent Events (SSE) Protocol",sidebar_label:"Server-Sent Events (SSE) Pr...",sidebar_position:2},l="Server-Sent Events (SSE) Protocol",c={},a=[{value:"Protocol Basics",id:"protocol-basics",level:2},{value:"Message Format",id:"message-format",level:2},{value:"Data Field",id:"data-field",level:3},{value:"Event Field",id:"event-field",level:3},{value:"ID Field",id:"id-field",level:3},{value:"Retry Field",id:"retry-field",level:3},{value:"Client Implementation",id:"client-implementation",level:2},{value:"EventSource API (Browser)",id:"eventsource-api-browser",level:3},{value:"Fetch API (More Control)",id:"fetch-api-more-control",level:3},{value:"Server Implementation",id:"server-implementation",level:2},{value:"Node.js (Express)",id:"nodejs-express",level:3},{value:"Next.js (App Router)",id:"nextjs-app-router",level:3},{value:"Edge Runtime (Vercel/Cloudflare)",id:"edge-runtime-vercelcloudflare",level:3},{value:"Reconnection Logic",id:"reconnection-logic",level:2},{value:"CORS Configuration",id:"cors-configuration",level:2},{value:"Heartbeat Pattern",id:"heartbeat-pattern",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Client-Side Errors",id:"client-side-errors",level:3},{value:"Server-Side Errors",id:"server-side-errors",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Backpressure",id:"backpressure",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Security",id:"security",level:2},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Production Checklist",id:"production-checklist",level:2},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"server-sent-events-sse-protocol",children:"Server-Sent Events (SSE) Protocol"})}),"\n",(0,s.jsx)(n.p,{children:"Deep dive into the SSE specification and implementation details for LLM streaming."}),"\n",(0,s.jsx)(n.h2,{id:"protocol-basics",children:"Protocol Basics"}),"\n",(0,s.jsx)(n.p,{children:"SSE is a simple HTTP-based protocol for server-to-client streaming."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Request"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"GET /api/stream HTTP/1.1\nAccept: text/event-stream\nCache-Control: no-cache\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Response"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:'HTTP/1.1 200 OK\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n\ndata: First message\n\ndata: Second message\n\ndata: {"type":"completion","text":"Token"}\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"message-format",children:"Message Format"}),"\n",(0,s.jsx)(n.h3,{id:"data-field",children:"Data Field"}),"\n",(0,s.jsx)(n.p,{children:"The only required field. Can span multiple lines."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'data: Simple message\n\ndata: Multi-line\ndata: message\ndata: here\n\ndata: {"json":"works too"}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"event-field",children:"Event Field"}),"\n",(0,s.jsx)(n.p,{children:'Custom event types (default is "message").'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'event: status\ndata: {"state":"processing"}\n\nevent: completion\ndata: {"content":"Hello"}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"id-field",children:"ID Field"}),"\n",(0,s.jsx)(n.p,{children:"Event identifier for reconnection."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"id: 1\ndata: First event\n\nid: 2\ndata: Second event\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Client can reconnect with ",(0,s.jsx)(n.code,{children:"Last-Event-ID"})," header:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:"GET /api/stream HTTP/1.1\nLast-Event-ID: 2\n"})}),"\n",(0,s.jsx)(n.h3,{id:"retry-field",children:"Retry Field"}),"\n",(0,s.jsx)(n.p,{children:"Reconnection delay in milliseconds."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"retry: 3000\ndata: Reconnect after 3 seconds if disconnected\n\n"})}),"\n",(0,s.jsx)(n.h2,{id:"client-implementation",children:"Client Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"eventsource-api-browser",children:"EventSource API (Browser)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const eventSource = new EventSource('/api/stream');\n\neventSource.onmessage = (event) => {\n  console.log('Data:', event.data);\n};\n\neventSource.addEventListener('status', (event) => {\n  console.log('Status:', JSON.parse(event.data));\n});\n\neventSource.onerror = (error) => {\n  console.error('SSE error:', error);\n  eventSource.close();\n};\n\n// Close connection\neventSource.close();\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Limitations"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No custom headers (can't send Authorization)"}),"\n",(0,s.jsx)(n.li,{children:"No POST requests (GET only)"}),"\n",(0,s.jsx)(n.li,{children:"Limited error handling"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"fetch-api-more-control",children:"Fetch API (More Control)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const response = await fetch('/api/stream', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${token}`\n  },\n  body: JSON.stringify({ prompt: 'Hello' })\n});\n\nconst reader = response.body!.getReader();\nconst decoder = new TextDecoder();\n\nwhile (true) {\n  const { done, value } = await reader.read();\n  if (done) break;\n\n  const chunk = decoder.decode(value);\n  console.log(chunk);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Custom headers"}),"\n",(0,s.jsx)(n.li,{children:"POST requests"}),"\n",(0,s.jsx)(n.li,{children:"AbortController support"}),"\n",(0,s.jsx)(n.li,{children:"Better error handling"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"server-implementation",children:"Server Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"nodejs-express",children:"Node.js (Express)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import express from 'express';\n\napp.get('/api/stream', (req, res) => {\n  // Set SSE headers\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n\n  // Send initial message\n  res.write('data: Connected\\n\\n');\n\n  // Send periodic updates\n  const interval = setInterval(() => {\n    res.write(`data: ${Date.now()}\\n\\n`);\n  }, 1000);\n\n  // Cleanup on disconnect\n  req.on('close', () => {\n    clearInterval(interval);\n    res.end();\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"nextjs-app-router",children:"Next.js (App Router)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/api/stream/route.ts\nexport async function GET() {\n  const encoder = new TextEncoder();\n\n  const stream = new ReadableStream({\n    async start(controller) {\n      // Send messages\n      controller.enqueue(encoder.encode('data: Hello\\n\\n'));\n      controller.enqueue(encoder.encode('data: World\\n\\n'));\n\n      // Close stream\n      controller.close();\n    }\n  });\n\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive'\n    }\n  });\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"edge-runtime-vercelcloudflare",children:"Edge Runtime (Vercel/Cloudflare)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const runtime = 'edge';\n\nexport async function POST(req: Request) {\n  const { prompt } = await req.json();\n\n  const stream = new ReadableStream({\n    async start(controller) {\n      const encoder = new TextEncoder();\n\n      // Stream from LLM\n      for await (const chunk of llmStream(prompt)) {\n        const message = `data: ${JSON.stringify({ content: chunk })}\\n\\n`;\n        controller.enqueue(encoder.encode(message));\n      }\n\n      controller.close();\n    }\n  });\n\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache'\n    }\n  });\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reconnection-logic",children:"Reconnection Logic"}),"\n",(0,s.jsx)(n.p,{children:"SSE has built-in reconnection, but Fetch API requires manual implementation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class SSEClient {\n  private reconnectDelay = 1000;\n  private maxReconnectDelay = 30000;\n  private reconnectAttempts = 0;\n\n  async connect(url: string, onMessage: (data: string) => void) {\n    try {\n      const response = await fetch(url);\n      const reader = response.body!.getReader();\n      const decoder = new TextDecoder();\n\n      // Reset reconnect state on successful connection\n      this.reconnectAttempts = 0;\n      this.reconnectDelay = 1000;\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            onMessage(line.slice(6));\n          }\n        }\n      }\n    } catch (error) {\n      // Exponential backoff\n      this.reconnectAttempts++;\n      this.reconnectDelay = Math.min(\n        this.reconnectDelay * 2,\n        this.maxReconnectDelay\n      );\n\n      console.log(`Reconnecting in ${this.reconnectDelay}ms...`);\n\n      setTimeout(() => {\n        this.connect(url, onMessage);\n      }, this.reconnectDelay);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cors-configuration",children:"CORS Configuration"}),"\n",(0,s.jsx)(n.p,{children:"SSE requires proper CORS headers."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Server-side\napp.use((req, res, next) => {\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n  next();\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"heartbeat-pattern",children:"Heartbeat Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Send periodic pings to keep connection alive."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Server\nconst heartbeat = setInterval(() => {\n  res.write(': heartbeat\\n\\n'); // Comment, ignored by client\n}, 15000);\n\nreq.on('close', () => {\n  clearInterval(heartbeat);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why"}),": Some proxies close idle connections after 30 seconds."]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"client-side-errors",children:"Client-Side Errors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"try {\n  const response = await fetch('/api/stream');\n\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}`);\n  }\n\n  if (!response.body) {\n    throw new Error('No response body');\n  }\n\n  // Stream handling...\n} catch (error) {\n  if (error.name === 'AbortError') {\n    console.log('Stream cancelled');\n  } else if (error.message.includes('Failed to fetch')) {\n    console.error('Network error');\n  } else {\n    console.error('Unknown error:', error);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"server-side-errors",children:"Server-Side Errors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Send error as SSE event\nasync start(controller) {\n  try {\n    // Streaming logic...\n  } catch (error) {\n    const errorMessage = `event: error\\ndata: ${JSON.stringify({\n      message: error.message\n    })}\\n\\n`;\n    controller.enqueue(encoder.encode(errorMessage));\n    controller.close();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"backpressure",children:"Backpressure"}),"\n",(0,s.jsx)(n.p,{children:"Slow clients can overwhelm server. Handle backpressure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const stream = new ReadableStream({\n  async start(controller) {\n    for await (const chunk of dataSource) {\n      // Wait if client is slow\n      if (controller.desiredSize !== null && controller.desiredSize <= 0) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n\n      controller.enqueue(encoder.encode(`data: ${chunk}\\n\\n`));\n    }\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(n.p,{children:"Close connections when done:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Client\nuseEffect(() => {\n  const controller = new AbortController();\n\n  fetch('/api/stream', { signal: controller.signal })\n    .then(/* ... */);\n\n  return () => {\n    controller.abort();\n  };\n}, []);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security",children:"Security"}),"\n",(0,s.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import rateLimit from 'express-rate-limit';\n\nconst limiter = rateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 10, // 10 requests per minute\n  message: 'Too many requests'\n});\n\napp.get('/api/stream', limiter, (req, res) => {\n  // Stream handler...\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Server\nconst token = req.headers.authorization?.split(' ')[1];\nif (!verifyToken(token)) {\n  return res.status(401).send('Unauthorized');\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"production-checklist",children:"Production Checklist"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u25a1 Content-Type: text/event-stream header set\n\u25a1 Cache-Control: no-cache header set\n\u25a1 CORS configured correctly\n\u25a1 Heartbeat implemented (for proxies)\n\u25a1 Reconnection logic with exponential backoff\n\u25a1 Error events sent to client\n\u25a1 Rate limiting enabled\n\u25a1 Authentication required\n\u25a1 Memory cleanup on disconnect\n\u25a1 Timeout for long-running streams\n"})}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events",children:"MDN: Server-Sent Events"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/server-sent-events.html",children:"SSE Specification"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/EventSource",children:"EventSource API"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);