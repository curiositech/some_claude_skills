"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3533],{2034:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"skills/automatic_stateful_prompt_improver/references/dspy-patterns","title":"DSPy Optimization Patterns for Prompt Learning","description":"This document covers DSPy-style programmatic prompt optimization patterns.","source":"@site/docs/skills/automatic_stateful_prompt_improver/references/dspy-patterns.md","sourceDirName":"skills/automatic_stateful_prompt_improver/references","slug":"/skills/automatic_stateful_prompt_improver/references/dspy-patterns","permalink":"/docs/skills/automatic_stateful_prompt_improver/references/dspy-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"DSPy Optimization Patterns for Prompt Learning","sidebar_label":"DSPy Optimization Patterns ...","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"APE and OPRO Implementation...","permalink":"/docs/skills/automatic_stateful_prompt_improver/references/ape-opro-implementation"},"next":{"title":"Embedding Architecture for ...","permalink":"/docs/skills/automatic_stateful_prompt_improver/references/embedding-architecture"}}');var s=t(74848),r=t(28453);const a={title:"DSPy Optimization Patterns for Prompt Learning",sidebar_label:"DSPy Optimization Patterns ...",sidebar_position:2},o="DSPy Optimization Patterns for Prompt Learning",l={},d=[{value:"Core Philosophy",id:"core-philosophy",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Signatures",id:"signatures",level:3},{value:"Modules",id:"modules",level:3},{value:"Optimization Algorithms",id:"optimization-algorithms",level:2},{value:"BootstrapRS (Random Search)",id:"bootstraprs-random-search",level:3},{value:"MIPROv2 (Bayesian Optimization)",id:"miprov2-bayesian-optimization",level:3},{value:"COPRO (Coordinate Optimization)",id:"copro-coordinate-optimization",level:3},{value:"Practical Patterns for Prompt Improvement",id:"practical-patterns-for-prompt-improvement",level:2},{value:"Pattern 1: Bootstrap \u2192 Optimize \u2192 Ensemble",id:"pattern-1-bootstrap--optimize--ensemble",level:3},{value:"Pattern 2: Metric-Driven Optimization",id:"pattern-2-metric-driven-optimization",level:3},{value:"Pattern 3: Assertion-Based Validation",id:"pattern-3-assertion-based-validation",level:3},{value:"Pattern 4: Multi-Stage Pipelines",id:"pattern-4-multi-stage-pipelines",level:3},{value:"Adapting DSPy Patterns for Claude Code",id:"adapting-dspy-patterns-for-claude-code",level:2},{value:"Mental Bootstrapping",id:"mental-bootstrapping",level:3},{value:"Instruction Optimization Loop",id:"instruction-optimization-loop",level:3},{value:"Few-Shot Selection",id:"few-shot-selection",level:3},{value:"Convergence Criteria",id:"convergence-criteria",level:2},{value:"When to Stop Optimizing",id:"when-to-stop-optimizing",level:3},{value:"Iteration Count Heuristics",id:"iteration-count-heuristics",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Memory Efficiency",id:"memory-efficiency",level:3},{value:"Reproducibility",id:"reproducibility",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"dspy-optimization-patterns-for-prompt-learning",children:"DSPy Optimization Patterns for Prompt Learning"})}),"\n",(0,s.jsx)(n.p,{children:"This document covers DSPy-style programmatic prompt optimization patterns."}),"\n",(0,s.jsx)(n.h2,{id:"core-philosophy",children:"Core Philosophy"}),"\n",(0,s.jsxs)(n.p,{children:["DSPy treats prompts as ",(0,s.jsx)(n.strong,{children:"trainable parameters"})," rather than brittle strings. Instead of manually crafting prompts, you define:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"What the module should do (signature)"}),"\n",(0,s.jsx)(n.li,{children:"How to measure success (metric)"}),"\n",(0,s.jsx)(n.li,{children:"Let the optimizer find the best prompt"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"signatures",children:"Signatures"}),"\n",(0,s.jsx)(n.p,{children:"Signatures declare input/output behavior:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Simple signature\nclass QA(dspy.Signature):\n    """Answer questions with brief responses."""\n    question = dspy.InputField()\n    answer = dspy.OutputField()\n\n# Complex signature with constraints\nclass CodeReview(dspy.Signature):\n    """Review code for bugs, style issues, and improvements."""\n    code = dspy.InputField(desc="The code to review")\n    language = dspy.InputField(desc="Programming language")\n    severity_filter = dspy.InputField(desc="min, major, critical", default="min")\n\n    bugs = dspy.OutputField(desc="List of potential bugs found")\n    style_issues = dspy.OutputField(desc="Style violations")\n    improvements = dspy.OutputField(desc="Suggested improvements")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"modules",children:"Modules"}),"\n",(0,s.jsx)(n.p,{children:"Modules define HOW to accomplish the signature:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Basic prediction\npredictor = dspy.Predict(QA)\n\n# Chain-of-thought reasoning\ncot = dspy.ChainOfThought(QA)\n\n# ReAct with tool use\nreact = dspy.ReAct(QA, tools=[search_tool, calculator])\n\n# Multi-step pipeline\nclass RAGPipeline(dspy.Module):\n    def __init__(self, num_passages=3):\n        self.retrieve = dspy.Retrieve(k=num_passages)\n        self.generate = dspy.ChainOfThought("context, question -> answer")\n\n    def forward(self, question):\n        context = self.retrieve(question).passages\n        return self.generate(context=context, question=question)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"optimization-algorithms",children:"Optimization Algorithms"}),"\n",(0,s.jsx)(n.h3,{id:"bootstraprs-random-search",children:"BootstrapRS (Random Search)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Best for"}),": Quick optimization, small datasets"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Generates few-shot examples from successful executions\noptimizer = dspy.BootstrapRS(\n    metric=my_metric,\n    max_bootstrapped_demos=4,  # Examples to include\n    max_labeled_demos=4,\n    num_candidate_programs=16\n)\n\noptimized = optimizer.compile(\n    student=my_module,\n    trainset=train_examples\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How it works"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Run the module on training examples"}),"\n",(0,s.jsx)(n.li,{children:"Identify successful executions"}),"\n",(0,s.jsx)(n.li,{children:"Use those as few-shot demonstrations"}),"\n",(0,s.jsx)(n.li,{children:"Select best combination randomly"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"miprov2-bayesian-optimization",children:"MIPROv2 (Bayesian Optimization)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Best for"}),": Production optimization, larger datasets"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'optimizer = dspy.MIPROv2(\n    metric=my_metric,\n    auto="medium",  # light, medium, heavy\n    num_threads=4\n)\n\noptimized = optimizer.compile(\n    student=my_module,\n    trainset=train_examples,\n    valset=val_examples,  # Important for evaluation\n    max_bootstrapped_demos=4,\n    max_labeled_demos=4\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How it works"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bootstrap"}),": Collect successful execution traces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Propose"}),": LLM generates instruction candidates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Search"}),": Bayesian optimization over instruction space"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Refine"}),": Iteratively improve best candidates"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cost/Performance (from research)"}),":"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Examples"}),(0,s.jsx)(n.th,{children:"Time"}),(0,s.jsx)(n.th,{children:"Cost"}),(0,s.jsx)(n.th,{children:"Improvement"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Light"}),(0,s.jsx)(n.td,{children:"500"}),(0,s.jsx)(n.td,{children:"20min"}),(0,s.jsx)(n.td,{children:"~$2"}),(0,s.jsx)(n.td,{children:"10-20%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"1000"}),(0,s.jsx)(n.td,{children:"1-2hr"}),(0,s.jsx)(n.td,{children:"~$10"}),(0,s.jsx)(n.td,{children:"20-35%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Heavy"}),(0,s.jsx)(n.td,{children:"2000+"}),(0,s.jsx)(n.td,{children:"4-8hr"}),(0,s.jsx)(n.td,{children:"~$50"}),(0,s.jsx)(n.td,{children:"35-50%"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"copro-coordinate-optimization",children:"COPRO (Coordinate Optimization)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Best for"}),": Instruction-only optimization"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"optimizer = dspy.COPRO(\n    metric=my_metric,\n    depth=3,  # Optimization iterations\n    breadth=10,  # Candidates per iteration\n    init_temperature=1.0\n)\n\n# Only optimizes instructions, not examples\noptimized = optimizer.compile(\n    student=my_module,\n    trainset=train_examples\n)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"practical-patterns-for-prompt-improvement",children:"Practical Patterns for Prompt Improvement"}),"\n",(0,s.jsx)(n.h3,{id:"pattern-1-bootstrap--optimize--ensemble",children:"Pattern 1: Bootstrap \u2192 Optimize \u2192 Ensemble"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def full_optimization_pipeline(module, trainset, valset):\n    """\n    Three-stage optimization for best results.\n    """\n    # Stage 1: Bootstrap few-shot examples\n    bootstrap = dspy.BootstrapRS(\n        metric=accuracy_metric,\n        max_bootstrapped_demos=4\n    )\n    bootstrapped = bootstrap.compile(module, trainset=trainset)\n\n    # Stage 2: Optimize instructions\n    mipro = dspy.MIPROv2(metric=accuracy_metric, auto="medium")\n    optimized = mipro.compile(\n        bootstrapped,\n        trainset=trainset,\n        valset=valset\n    )\n\n    # Stage 3: Create ensemble (optional)\n    # Run optimization 3 times, ensemble the results\n    programs = []\n    for _ in range(3):\n        opt = dspy.MIPROv2(metric=accuracy_metric, auto="light")\n        programs.append(opt.compile(module, trainset=trainset, valset=valset))\n\n    ensemble = dspy.Ensemble(programs, strategy="majority")\n\n    return optimized, ensemble\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-2-metric-driven-optimization",children:"Pattern 2: Metric-Driven Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def create_composite_metric():\n    """\n    Multi-objective metric combining accuracy, cost, and quality.\n    """\n    def metric(example, prediction, trace=None):\n        # Accuracy (0-1)\n        accuracy = 1.0 if prediction.answer == example.expected else 0.0\n\n        # Token efficiency (penalize verbose responses)\n        tokens_used = len(prediction.answer.split())\n        efficiency = 1.0 / (1.0 + tokens_used / 100)\n\n        # Quality heuristics\n        has_reasoning = "because" in prediction.answer.lower()\n        quality = 1.0 if has_reasoning else 0.5\n\n        # Weighted combination\n        return 0.6 * accuracy + 0.2 * efficiency + 0.2 * quality\n\n    return metric\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-3-assertion-based-validation",children:"Pattern 3: Assertion-Based Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ValidatedQA(dspy.Module):\n    """\n    Module with built-in validation via assertions.\n    """\n    def __init__(self):\n        self.generate = dspy.ChainOfThought("question -> answer")\n\n    def forward(self, question):\n        response = self.generate(question=question)\n\n        # Validate response\n        dspy.Assert(\n            len(response.answer) > 10,\n            "Answer too short - provide more detail"\n        )\n\n        dspy.Assert(\n            response.answer[-1] in ".!?",\n            "Answer should end with punctuation"\n        )\n\n        dspy.Suggest(\n            "step" in response.rationale.lower() or "because" in response.rationale.lower(),\n            "Consider explaining your reasoning step by step"\n        )\n\n        return response\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pattern-4-multi-stage-pipelines",children:"Pattern 4: Multi-Stage Pipelines"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class OptimizedPipeline(dspy.Module):\n    """\n    Multi-stage pipeline where each stage can be optimized independently.\n    """\n    def __init__(self):\n        # Stage 1: Extract key information\n        self.extract = dspy.ChainOfThought(\n            "document -> key_points, entities, summary"\n        )\n\n        # Stage 2: Reason about the information\n        self.reason = dspy.ChainOfThought(\n            "key_points, entities, question -> reasoning"\n        )\n\n        # Stage 3: Generate final answer\n        self.answer = dspy.Predict(\n            "summary, reasoning, question -> answer"\n        )\n\n    def forward(self, document, question):\n        # Stage 1\n        extracted = self.extract(document=document)\n\n        # Stage 2\n        reasoned = self.reason(\n            key_points=extracted.key_points,\n            entities=extracted.entities,\n            question=question\n        )\n\n        # Stage 3\n        result = self.answer(\n            summary=extracted.summary,\n            reasoning=reasoned.reasoning,\n            question=question\n        )\n\n        return result\n'})}),"\n",(0,s.jsx)(n.h2,{id:"adapting-dspy-patterns-for-claude-code",children:"Adapting DSPy Patterns for Claude Code"}),"\n",(0,s.jsx)(n.p,{children:"Since we can't use DSPy's Python framework directly in Claude Code, we adapt the patterns:"}),"\n",(0,s.jsx)(n.h3,{id:"mental-bootstrapping",children:"Mental Bootstrapping"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:'## Bootstrap Pattern (Manual)\n\nWhen improving a prompt, I will:\n\n1. **Generate variations**: Create 5-10 instruction candidates\n2. **Mental evaluation**: For each, consider:\n   - Clarity: Is it unambiguous?\n   - Completeness: Does it cover all cases?\n   - Constraint density: Right amount of guidance?\n3. **Select best**: Choose highest-scoring candidate\n4. **Extract patterns**: What made it better?\n\nExample:\nOriginal: "Summarize the text"\n\nCandidates:\n- "Extract the main points from this text" (clarity: 7)\n- "Provide a 3-sentence summary" (constraint: 8)\n- "Identify thesis, evidence, and conclusion" (structure: 9)\n\nBest: Combine structure (9) + constraint (8)\nResult: "Identify the thesis, key evidence, and conclusion, then summarize in 2-3 sentences"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"instruction-optimization-loop",children:"Instruction Optimization Loop"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"## COPRO Pattern (Manual)\n\nFor instruction optimization:\n\n1. **Baseline**: Evaluate current prompt\n2. **Generate candidates**: Create variations\n3. **Evaluate each**: Score on clarity/specificity/effectiveness\n4. **Select best**: Choose highest scorer\n5. **Iterate**: Use best as new baseline\n6. **Stop when**: Improvement < threshold or max iterations\n\nTrack:\n- Iteration 1: Score 0.65\n- Iteration 2: Score 0.72 (+0.07)\n- Iteration 3: Score 0.75 (+0.03)\n- Iteration 4: Score 0.76 (+0.01) \u2190 Converging\n- STOP: Improvement < 0.02\n"})}),"\n",(0,s.jsx)(n.h3,{id:"few-shot-selection",children:"Few-Shot Selection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"## Example Selection Pattern\n\nWhen adding few-shot examples:\n\n1. **Diversity**: Cover different scenarios\n2. **Relevance**: Similar to expected inputs\n3. **Difficulty**: Progress from easy to hard\n4. **Quality**: Only include high-quality examples\n\nAnti-patterns:\n- All examples from same category \u2190 Low coverage\n- Examples too different from test case \u2190 Low relevance\n- All easy or all hard \u2190 Imbalanced\n"})}),"\n",(0,s.jsx)(n.h2,{id:"convergence-criteria",children:"Convergence Criteria"}),"\n",(0,s.jsx)(n.h3,{id:"when-to-stop-optimizing",children:"When to Stop Optimizing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def should_stop_optimization(\n    scores: list[float],\n    iterations: int,\n    max_iterations: int = 20,\n    window: int = 3,\n    threshold: float = 0.01\n) -> tuple[bool, str]:\n    """\n    Determine if optimization should stop.\n\n    Returns:\n        (should_stop, reason)\n    """\n    # Max iterations reached\n    if iterations >= max_iterations:\n        return True, "max_iterations_reached"\n\n    # Not enough data\n    if len(scores) < window:\n        return False, "insufficient_data"\n\n    # Performance plateau\n    recent_improvement = max(scores[-window:]) - scores[-window]\n    if recent_improvement < threshold:\n        return True, f"plateau_detected (improvement: {recent_improvement:.4f})"\n\n    # High enough score\n    if scores[-1] > 0.95:\n        return True, f"target_reached (score: {scores[-1]:.4f})"\n\n    return False, "continue"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"iteration-count-heuristics",children:"Iteration Count Heuristics"}),"\n",(0,s.jsx)(n.p,{children:"Based on research and empirical testing:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Task Type"}),(0,s.jsx)(n.th,{children:"Recommended Iterations"}),(0,s.jsx)(n.th,{children:"Reason"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Simple classification"}),(0,s.jsx)(n.td,{children:"3-5"}),(0,s.jsx)(n.td,{children:"Small search space"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Text generation"}),(0,s.jsx)(n.td,{children:"5-10"}),(0,s.jsx)(n.td,{children:"Format variations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Complex reasoning"}),(0,s.jsx)(n.td,{children:"10-15"}),(0,s.jsx)(n.td,{children:"Multiple strategies"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Multi-step pipeline"}),(0,s.jsx)(n.td,{children:"15-20"}),(0,s.jsx)(n.td,{children:"Component interactions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Agent optimization"}),(0,s.jsx)(n.td,{children:"20-30"}),(0,s.jsx)(n.td,{children:"High complexity"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,s.jsx)(n.h3,{id:"memory-efficiency",children:"Memory Efficiency"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Keep only top-k candidates to manage memory\nclass CandidatePool:\n    def __init__(self, max_size: int = 10):\n        self.candidates = []\n        self.max_size = max_size\n\n    def add(self, candidate: str, score: float):\n        self.candidates.append((candidate, score))\n        self.candidates.sort(key=lambda x: x[1], reverse=True)\n        self.candidates = self.candidates[:self.max_size]\n\n    def get_best(self) -> str:\n        return self.candidates[0][0] if self.candidates else None\n"})}),"\n",(0,s.jsx)(n.h3,{id:"reproducibility",children:"Reproducibility"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Track optimization history for reproducibility\noptimization_history = {\n    "initial_prompt": "...",\n    "iterations": [\n        {"candidate": "...", "score": 0.65, "selected": False},\n        {"candidate": "...", "score": 0.72, "selected": True},\n    ],\n    "final_prompt": "...",\n    "final_score": 0.76,\n    "convergence_reason": "plateau_detected"\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"These patterns form the foundation for systematic, measurable prompt optimization that can be applied even without access to DSPy's infrastructure."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);