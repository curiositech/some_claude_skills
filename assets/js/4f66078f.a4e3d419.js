"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[72044],{9321:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"skills/dag_hallucination_detector/index","title":"\ud83d\udce6 Dag Hallucination Detector","description":"Detects fabricated content, false citations, and unverifiable claims in agent outputs. Uses source verification and consistency checking. Activate on \'detect hallucination\', \'fact check\', \'verify claims\', \'check accuracy\', \'find fabrications\'. NOT for validation (use dag-output-validator) or confidence scoring (use dag-confidence-scorer).","source":"@site/docs/skills/dag_hallucination_detector/index.md","sourceDirName":"skills/dag_hallucination_detector","slug":"/skills/dag_hallucination_detector/","permalink":"/docs/skills/dag_hallucination_detector/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Hallucination Detector","sidebar_position":1}}');var c=t(74848),a=t(28453);const s={sidebar_label:"Dag Hallucination Detector",sidebar_position:1},o="\ud83d\udce6 Dag Hallucination Detector",r={},l=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Citation Verification",id:"1-citation-verification",level:3},{value:"2. Factual Claim Checking",id:"2-factual-claim-checking",level:3},{value:"3. Consistency Analysis",id:"3-consistency-analysis",level:3},{value:"4. Pattern Detection",id:"4-pattern-detection",level:3},{value:"Detection Architecture",id:"detection-architecture",level:2},{value:"Citation Verification",id:"citation-verification",level:2},{value:"Factual Claim Detection",id:"factual-claim-detection",level:2},{value:"Consistency Checking",id:"consistency-checking",level:2},{value:"Hallucination Patterns",id:"hallucination-patterns",level:2},{value:"Detection Report",id:"detection-report",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(e.header,{children:(0,c.jsx)(e.h1,{id:"-dag-hallucination-detector",children:"\ud83d\udce6 Dag Hallucination Detector"})}),"\n",(0,c.jsx)(e.p,{children:"Detects fabricated content, false citations, and unverifiable claims in agent outputs. Uses source verification and consistency checking. Activate on 'detect hallucination', 'fact check', 'verify claims', 'check accuracy', 'find fabrications'. NOT for validation (use dag-output-validator) or confidence scoring (use dag-confidence-scorer)."}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"Read, Write, Edit, Glob, Grep, WebFetch, WebSearch\n"})}),"\n",(0,c.jsx)(e.h2,{id:"tags",children:"Tags"}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"dag"})," ",(0,c.jsx)(e.code,{children:"quality"})," ",(0,c.jsx)(e.code,{children:"hallucination"})," ",(0,c.jsx)(e.code,{children:"fact-checking"})," ",(0,c.jsx)(e.code,{children:"verification"})]}),"\n",(0,c.jsx)(e.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.a,{href:"/docs/skills/dag_output_validator",children:"Dag Output Validator"})}),": Works with validation pipeline"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.a,{href:"/docs/skills/dag_confidence_scorer",children:"Dag Confidence Scorer"})}),": Low confidence triggers detection"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.a,{href:"/docs/skills/dag_feedback_synthesizer",children:"Dag Feedback Synthesizer"})}),": Reports hallucinations for feedback"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"You are a DAG Hallucination Detector, an expert at identifying fabricated content, false citations, and unverifiable claims in agent outputs. You use source verification, cross-referencing, and consistency analysis to detect when agents have generated plausible-sounding but incorrect information."}),"\n",(0,c.jsx)(e.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,c.jsx)(e.h3,{id:"1-citation-verification",children:"1. Citation Verification"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Verify quoted sources exist"}),"\n",(0,c.jsx)(e.li,{children:"Check citation accuracy"}),"\n",(0,c.jsx)(e.li,{children:"Detect fabricated references"}),"\n"]}),"\n",(0,c.jsx)(e.h3,{id:"2-factual-claim-checking",children:"2. Factual Claim Checking"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Identify verifiable claims"}),"\n",(0,c.jsx)(e.li,{children:"Cross-reference with sources"}),"\n",(0,c.jsx)(e.li,{children:"Flag unverifiable assertions"}),"\n"]}),"\n",(0,c.jsx)(e.h3,{id:"3-consistency-analysis",children:"3. Consistency Analysis"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Detect internal contradictions"}),"\n",(0,c.jsx)(e.li,{children:"Compare with known facts"}),"\n",(0,c.jsx)(e.li,{children:"Identify logical impossibilities"}),"\n"]}),"\n",(0,c.jsx)(e.h3,{id:"4-pattern-detection",children:"4. Pattern Detection"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Recognize hallucination patterns"}),"\n",(0,c.jsx)(e.li,{children:"Track agent-specific tendencies"}),"\n",(0,c.jsx)(e.li,{children:"Learn from past detections"}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"detection-architecture",children:"Detection Architecture"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-typescript",children:"interface HallucinationReport {\n  outputId: string;\n  scannedAt: Date;\n  overallRisk: 'low' | 'medium' | 'high' | 'critical';\n  findings: HallucinationFinding[];\n  verifiedClaims: VerifiedClaim[];\n  unverifiableClaims: UnverifiableClaim[];\n  summary: DetectionSummary;\n}\n\ninterface HallucinationFinding {\n  id: string;\n  type: HallucinationType;\n  severity: 'warning' | 'likely' | 'confirmed';\n  location: {\n    start: number;\n    end: number;\n    context: string;\n  };\n  claim: string;\n  evidence: string;\n  confidence: number;\n}\n\ntype HallucinationType =\n  | 'fabricated_citation'\n  | 'false_quote'\n  | 'invented_statistic'\n  | 'nonexistent_entity'\n  | 'incorrect_fact'\n  | 'logical_impossibility'\n  | 'temporal_error'\n  | 'self_contradiction';\n"})}),"\n",(0,c.jsx)(e.h2,{id:"citation-verification",children:"Citation Verification"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-typescript",children:"interface Citation {\n  text: string;\n  type: 'url' | 'paper' | 'quote' | 'reference';\n  source?: string;\n  author?: string;\n  date?: string;\n}\n\nasync function verifyCitations(\n  content: string,\n  context: VerificationContext\n): Promise<CitationVerification[]> {\n  const citations = extractCitations(content);\n  const results: CitationVerification[] = [];\n\n  for (const citation of citations) {\n    const verification = await verifySingleCitation(citation, context);\n    results.push(verification);\n  }\n\n  return results;\n}\n\nfunction extractCitations(content: string): Citation[] {\n  const citations: Citation[] = [];\n\n  // URL citations\n  const urlPattern = /https?:\\/\\/[^\\s\\)]+/g;\n  const urls = content.match(urlPattern) || [];\n  for (const url of urls) {\n    citations.push({ text: url, type: 'url' });\n  }\n\n  // Academic citations [Author, Year]\n  const academicPattern = /\\[([A-Z][a-z]+(?:\\s+(?:et\\s+al\\.|&\\s+[A-Z][a-z]+))?),?\\s*(\\d{4})\\]/g;\n  let match;\n  while ((match = academicPattern.exec(content)) !== null) {\n    citations.push({\n      text: match[0],\n      type: 'paper',\n      author: match[1],\n      date: match[2],\n    });\n  }\n\n  // Quoted text with attribution\n  const quotePattern = /\"([^\"]+)\"\\s*[-\u2013\u2014]\\s*([A-Za-z\\s]+)/g;\n  while ((match = quotePattern.exec(content)) !== null) {\n    citations.push({\n      text: match[0],\n      type: 'quote',\n      source: match[2],\n    });\n  }\n\n  return citations;\n}\n\nasync function verifySingleCitation(\n  citation: Citation,\n  context: VerificationContext\n): Promise<CitationVerification> {\n  switch (citation.type) {\n    case 'url':\n      return await verifyUrl(citation.text, context);\n    case 'paper':\n      return await verifyAcademicCitation(citation, context);\n    case 'quote':\n      return await verifyQuote(citation, context);\n    default:\n      return { verified: false, confidence: 0, reason: 'Unknown citation type' };\n  }\n}\n\nasync function verifyUrl(\n  url: string,\n  context: VerificationContext\n): Promise<CitationVerification> {\n  // Check if URL pattern looks legitimate\n  const suspiciousPatterns = [\n    /\\d{10,}/,  // Random long numbers\n    /[a-z]{20,}/,  // Random long strings\n    /example\\.com/,\n    /fake|test|demo/i,\n  ];\n\n  for (const pattern of suspiciousPatterns) {\n    if (pattern.test(url)) {\n      return {\n        verified: false,\n        confidence: 0.7,\n        reason: `URL matches suspicious pattern: ${pattern}`,\n        finding: {\n          type: 'fabricated_citation',\n          severity: 'likely',\n        },\n      };\n    }\n  }\n\n  // Try to fetch (if enabled)\n  if (context.allowNetworkVerification) {\n    try {\n      const response = await fetch(url, { method: 'HEAD' });\n      if (!response.ok) {\n        return {\n          verified: false,\n          confidence: 0.9,\n          reason: `URL returned ${response.status}`,\n          finding: {\n            type: 'fabricated_citation',\n            severity: 'confirmed',\n          },\n        };\n      }\n      return { verified: true, confidence: 0.9 };\n    } catch (error) {\n      return {\n        verified: false,\n        confidence: 0.8,\n        reason: `URL unreachable: ${error}`,\n        finding: {\n          type: 'fabricated_citation',\n          severity: 'likely',\n        },\n      };\n    }\n  }\n\n  return { verified: null, confidence: 0, reason: 'Network verification disabled' };\n}\n"})}),"\n",(0,c.jsx)(e.h2,{id:"factual-claim-detection",children:"Factual Claim Detection"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-typescript",children:"interface FactualClaim {\n  text: string;\n  type: 'statistic' | 'date' | 'name' | 'event' | 'definition' | 'comparison';\n  verifiable: boolean;\n  specificity: 'low' | 'medium' | 'high';\n}\n\nfunction extractFactualClaims(content: string): FactualClaim[] {\n  const claims: FactualClaim[] = [];\n\n  // Statistics\n  const statPatterns = [\n    /(\\d+(?:\\.\\d+)?%)\\s+(?:of\\s+)?[\\w\\s]+/g,\n    /(\\d+(?:,\\d{3})*(?:\\.\\d+)?)\\s+(people|users|companies|countries)/g,\n    /increased?\\s+by\\s+(\\d+(?:\\.\\d+)?%?)/g,\n  ];\n\n  for (const pattern of statPatterns) {\n    const matches = content.matchAll(pattern);\n    for (const match of matches) {\n      claims.push({\n        text: match[0],\n        type: 'statistic',\n        verifiable: true,\n        specificity: 'high',\n      });\n    }\n  }\n\n  // Specific dates\n  const datePattern = /(?:in|on|since)\\s+(\\d{4}|\\w+\\s+\\d{1,2},?\\s*\\d{4})/g;\n  const dateMatches = content.matchAll(datePattern);\n  for (const match of dateMatches) {\n    claims.push({\n      text: match[0],\n      type: 'date',\n      verifiable: true,\n      specificity: 'high',\n    });\n  }\n\n  // Named entities with claims\n  const namedEntityPattern = /([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)\\s+(?:is|was|are|were|has|have)\\s+/g;\n  const entityMatches = content.matchAll(namedEntityPattern);\n  for (const match of entityMatches) {\n    claims.push({\n      text: match[0] + content.slice(match.index! + match[0].length).split(/[.!?]/)[0],\n      type: 'name',\n      verifiable: true,\n      specificity: 'medium',\n    });\n  }\n\n  return claims;\n}\n\nasync function verifyFactualClaim(\n  claim: FactualClaim,\n  context: VerificationContext\n): Promise<ClaimVerification> {\n  // Check against provided ground truth\n  if (context.groundTruth) {\n    const contradiction = findContradiction(claim, context.groundTruth);\n    if (contradiction) {\n      return {\n        verified: false,\n        confidence: 0.95,\n        reason: `Contradicts ground truth: ${contradiction}`,\n        finding: {\n          type: 'incorrect_fact',\n          severity: 'confirmed',\n        },\n      };\n    }\n  }\n\n  // Check for impossible claims\n  const impossibility = checkLogicalImpossibility(claim);\n  if (impossibility) {\n    return {\n      verified: false,\n      confidence: 0.99,\n      reason: impossibility,\n      finding: {\n        type: 'logical_impossibility',\n        severity: 'confirmed',\n      },\n    };\n  }\n\n  // Check temporal validity\n  const temporalError = checkTemporalValidity(claim);\n  if (temporalError) {\n    return {\n      verified: false,\n      confidence: 0.9,\n      reason: temporalError,\n      finding: {\n        type: 'temporal_error',\n        severity: 'likely',\n      },\n    };\n  }\n\n  return { verified: null, confidence: 0, reason: 'Unable to verify' };\n}\n\nfunction checkLogicalImpossibility(claim: FactualClaim): string | null {\n  // Percentages over 100% (unless explicitly about growth)\n  if (claim.type === 'statistic') {\n    const percentMatch = claim.text.match(/(\\d+(?:\\.\\d+)?)%/);\n    if (percentMatch) {\n      const value = parseFloat(percentMatch[1]);\n      if (value > 100 && !claim.text.includes('growth') && !claim.text.includes('increase')) {\n        return `Percentage ${value}% exceeds 100% without growth context`;\n      }\n    }\n  }\n\n  // Negative counts\n  const negativeCount = claim.text.match(/-(\\d+)\\s+(people|users|items)/);\n  if (negativeCount) {\n    return `Negative count: ${negativeCount[0]}`;\n  }\n\n  return null;\n}\n\nfunction checkTemporalValidity(claim: FactualClaim): string | null {\n  if (claim.type !== 'date') return null;\n\n  const yearMatch = claim.text.match(/\\d{4}/);\n  if (yearMatch) {\n    const year = parseInt(yearMatch[0]);\n    const currentYear = new Date().getFullYear();\n\n    if (year > currentYear + 1) {\n      return `Future date ${year} treated as historical fact`;\n    }\n\n    // Check for anachronisms (would need domain knowledge)\n    // e.g., \"invented the internet in 1850\"\n  }\n\n  return null;\n}\n"})}),"\n",(0,c.jsx)(e.h2,{id:"consistency-checking",children:"Consistency Checking"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-typescript",children:"function checkInternalConsistency(content: string): ConsistencyResult {\n  const findings: HallucinationFinding[] = [];\n\n  // Extract all numeric claims and check for contradictions\n  const numerics = extractNumericClaims(content);\n  const numericContradictions = findNumericContradictions(numerics);\n\n  for (const contradiction of numericContradictions) {\n    findings.push({\n      id: generateId(),\n      type: 'self_contradiction',\n      severity: 'confirmed',\n      location: contradiction.location,\n      claim: contradiction.claim1,\n      evidence: `Contradicts earlier claim: \"${contradiction.claim2}\"`,\n      confidence: 0.95,\n    });\n  }\n\n  // Check for opposing assertions\n  const assertions = extractAssertions(content);\n  const oppositions = findOpposingAssertions(assertions);\n\n  for (const opposition of oppositions) {\n    findings.push({\n      id: generateId(),\n      type: 'self_contradiction',\n      severity: 'likely',\n      location: opposition.location,\n      claim: opposition.assertion1,\n      evidence: `Opposes: \"${opposition.assertion2}\"`,\n      confidence: 0.8,\n    });\n  }\n\n  return {\n    consistent: findings.length === 0,\n    findings,\n  };\n}\n\nfunction extractNumericClaims(content: string): NumericClaim[] {\n  const claims: NumericClaim[] = [];\n  const pattern = /(\\d+(?:,\\d{3})*(?:\\.\\d+)?)\\s*([\\w\\s]+)/g;\n\n  let match;\n  while ((match = pattern.exec(content)) !== null) {\n    claims.push({\n      value: parseFloat(match[1].replace(/,/g, '')),\n      unit: match[2].trim(),\n      position: match.index,\n      text: match[0],\n    });\n  }\n\n  return claims;\n}\n\nfunction findNumericContradictions(claims: NumericClaim[]): Contradiction[] {\n  const contradictions: Contradiction[] = [];\n\n  // Group by unit/topic\n  const byUnit = groupBy(claims, c => c.unit.toLowerCase());\n\n  for (const [unit, unitClaims] of Object.entries(byUnit)) {\n    if (unitClaims.length < 2) continue;\n\n    // Check for significant differences (&gt;50% different)\n    for (let i = 0; i < unitClaims.length; i++) {\n      for (let j = i + 1; j < unitClaims.length; j++) {\n        const ratio = unitClaims[i].value / unitClaims[j].value;\n        if (ratio > 2 || ratio < 0.5) {\n          contradictions.push({\n            claim1: unitClaims[i].text,\n            claim2: unitClaims[j].text,\n            location: { start: unitClaims[j].position, end: unitClaims[j].position + unitClaims[j].text.length },\n          });\n        }\n      }\n    }\n  }\n\n  return contradictions;\n}\n"})}),"\n",(0,c.jsx)(e.h2,{id:"hallucination-patterns",children:"Hallucination Patterns"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-typescript",children:'const HALLUCINATION_PATTERNS = {\n  // Fabricated entity patterns\n  inventedCompany: /(?:company|corporation|firm)\\s+called\\s+"?([A-Z][a-zA-Z]+(?:\\s+[A-Z][a-zA-Z]+)*)"?/g,\n\n  // Suspicious specificity\n  tooSpecific: /exactly\\s+(\\d+(?:\\.\\d{3,})?)/g,\n\n  // Made-up studies\n  vagueStufy: /(?:a\\s+)?(?:recent\\s+)?study\\s+(?:shows|found|suggests)\\s+that/gi,\n\n  // Invented quotes\n  genericQuote: /"[^"]{50,200}"\\s*[-\u2013\u2014]\\s*(?:Anonymous|Unknown|Expert)/g,\n\n  // Round number suspicion\n  suspiciousRounding: /(?:approximately|about|around)\\s+(\\d+(?:,000)+)/g,\n\n  // Fake precision\n  fakePrecision: /\\d+\\.\\d{4,}%/g,\n};\n\nfunction detectHallucinationPatterns(content: string): HallucinationFinding[] {\n  const findings: HallucinationFinding[] = [];\n\n  for (const [patternName, pattern] of Object.entries(HALLUCINATION_PATTERNS)) {\n    const matches = content.matchAll(pattern);\n    for (const match of matches) {\n      findings.push({\n        id: generateId(),\n        type: mapPatternToType(patternName),\n        severity: \'warning\',\n        location: {\n          start: match.index!,\n          end: match.index! + match[0].length,\n          context: getContext(content, match.index!),\n        },\n        claim: match[0],\n        evidence: `Matches hallucination pattern: ${patternName}`,\n        confidence: 0.6,\n      });\n    }\n  }\n\n  return findings;\n}\n'})}),"\n",(0,c.jsx)(e.h2,{id:"detection-report",children:"Detection Report"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-yaml",children:'hallucinationReport:\n  outputId: research-output-2024-01-15\n  scannedAt: "2024-01-15T10:30:00Z"\n  overallRisk: medium\n\n  summary:\n    totalClaims: 23\n    verifiedClaims: 15\n    unverifiableClaims: 5\n    likelyHallucinations: 3\n    confirmedHallucinations: 0\n\n  findings:\n    - id: h-001\n      type: fabricated_citation\n      severity: likely\n      location:\n        start: 1245\n        end: 1298\n        context: "...as documented at https://fake-research.org/study..."\n      claim: "https://fake-research.org/study"\n      evidence: "URL returned 404, domain appears fabricated"\n      confidence: 0.85\n\n    - id: h-002\n      type: invented_statistic\n      severity: warning\n      location:\n        start: 892\n        end: 945\n        context: "...improves performance by 73.847%..."\n      claim: "73.847%"\n      evidence: "Suspicious precision for performance claim"\n      confidence: 0.6\n\n    - id: h-003\n      type: self_contradiction\n      severity: likely\n      location:\n        start: 2100\n        end: 2150\n        context: "...only 5% of users..."\n      claim: "5% of users"\n      evidence: "Earlier stated \'45% of users\' for same metric"\n      confidence: 0.9\n\n  verifiedClaims:\n    - claim: "TypeScript was released in 2012"\n      source: "Microsoft documentation"\n      confidence: 0.95\n\n    - claim: "React uses a virtual DOM"\n      source: "React official docs"\n      confidence: 0.98\n\n  unverifiableClaims:\n    - claim: "Most developers prefer X"\n      reason: "No source provided, subjective claim"\n\n  recommendations:\n    - "Remove or verify URL at position 1245"\n    - "Round statistic at position 892 or cite source"\n    - "Resolve contradiction between 5% and 45% claims"\n'})}),"\n",(0,c.jsx)(e.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Input"}),": Outputs from any DAG node, especially text-heavy"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Upstream"}),": ",(0,c.jsx)(e.code,{children:"dag-confidence-scorer"})," triggers detection for low confidence"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Downstream"}),": ",(0,c.jsx)(e.code,{children:"dag-feedback-synthesizer"})," for correction hints"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Learning"}),": ",(0,c.jsx)(e.code,{children:"dag-pattern-learner"})," tracks hallucination patterns"]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Verify Before Trust"}),": Check all specific claims"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Pattern Recognition"}),": Learn common hallucination types"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Source Hierarchy"}),": Weight verification by source quality"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"False Positive Tolerance"}),": Balance precision vs recall"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Continuous Learning"}),": Update patterns from confirmed cases"]}),"\n"]}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.p,{children:"Truth detection. Source verification. No hallucinations pass."})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var i=t(96540);const c={},a=i.createContext(c);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);