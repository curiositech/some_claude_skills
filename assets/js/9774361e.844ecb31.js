"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[70351],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var s=r(96540);const t={},a=s.createContext(t);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},41401:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"skills/react_performance_optimizer/references/memory-leaks","title":"React Memory Leaks Guide","description":"Common memory leak patterns in React and how to detect and fix them.","source":"@site/docs/skills/react_performance_optimizer/references/memory-leaks.md","sourceDirName":"skills/react_performance_optimizer/references","slug":"/skills/react_performance_optimizer/references/memory-leaks","permalink":"/docs/skills/react_performance_optimizer/references/memory-leaks","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"React Memory Leaks Guide","sidebar_label":"React Memory Leaks Guide","sidebar_position":2}}');var t=r(74848),a=r(28453);const o={title:"React Memory Leaks Guide",sidebar_label:"React Memory Leaks Guide",sidebar_position:2},i="React Memory Leaks Guide",l={},c=[{value:"What Are Memory Leaks?",id:"what-are-memory-leaks",level:2},{value:"Detecting Memory Leaks",id:"detecting-memory-leaks",level:2},{value:"Method 1: Chrome DevTools Memory Profiler",id:"method-1-chrome-devtools-memory-profiler",level:3},{value:"Method 2: Performance Monitor",id:"method-2-performance-monitor",level:3},{value:"Method 3: Automated Detection",id:"method-3-automated-detection",level:3},{value:"Common Leak Patterns",id:"common-leak-patterns",level:2},{value:"Pattern 1: Event Listeners Not Cleaned Up",id:"pattern-1-event-listeners-not-cleaned-up",level:3},{value:"Pattern 2: Timers Not Cleared",id:"pattern-2-timers-not-cleared",level:3},{value:"Pattern 3: Subscriptions Not Unsubscribed",id:"pattern-3-subscriptions-not-unsubscribed",level:3},{value:"Pattern 4: State Updates on Unmounted Components",id:"pattern-4-state-updates-on-unmounted-components",level:3},{value:"Pattern 5: Closures Capturing Large Objects",id:"pattern-5-closures-capturing-large-objects",level:3},{value:"Pattern 6: DOM References Not Cleared",id:"pattern-6-dom-references-not-cleared",level:3},{value:"Pattern 7: Global State Not Cleaned",id:"pattern-7-global-state-not-cleaned",level:3},{value:"Pattern 8: Third-Party Library Instances",id:"pattern-8-third-party-library-instances",level:3},{value:"Advanced Debugging",id:"advanced-debugging",level:2},{value:"Using Chrome DevTools Memory Allocation Timeline",id:"using-chrome-devtools-memory-allocation-timeline",level:3},{value:"Heap Snapshot Comparison",id:"heap-snapshot-comparison",level:3},{value:"React DevTools Profiler",id:"react-devtools-profiler",level:3},{value:"Testing for Memory Leaks",id:"testing-for-memory-leaks",level:2},{value:"Automated Test (Jest + Puppeteer)",id:"automated-test-jest--puppeteer",level:3},{value:"Prevention Checklist",id:"prevention-checklist",level:2},{value:"Common Libraries and Cleanup",id:"common-libraries-and-cleanup",level:2},{value:"Real-World Example",id:"real-world-example",level:2},{value:"Problem: Dashboard Leaking 50MB per Navigation",id:"problem-dashboard-leaking-50mb-per-navigation",level:3},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"react-memory-leaks-guide",children:"React Memory Leaks Guide"})}),"\n",(0,t.jsx)(n.p,{children:"Common memory leak patterns in React and how to detect and fix them."}),"\n",(0,t.jsx)(n.h2,{id:"what-are-memory-leaks",children:"What Are Memory Leaks?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition"}),": Memory that's allocated but never freed, causing increasing memory usage over time."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptoms"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Page becomes slower over time"}),"\n",(0,t.jsx)(n.li,{children:"Browser tab crashes after extended use"}),"\n",(0,t.jsx)(n.li,{children:"High memory usage in Task Manager"}),"\n",(0,t.jsx)(n.li,{children:"Performance degrades after navigation"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"100MB leak \u2192 Tab crash after 30 minutes"}),"\n",(0,t.jsx)(n.li,{children:"10MB leak \u2192 Noticeable slowdown after 1 hour"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"detecting-memory-leaks",children:"Detecting Memory Leaks"}),"\n",(0,t.jsx)(n.h3,{id:"method-1-chrome-devtools-memory-profiler",children:"Method 1: Chrome DevTools Memory Profiler"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"1. Open DevTools \u2192 Memory tab\n2. Take heap snapshot (baseline)\n3. Interact with app (open/close components, navigate)\n4. Take second snapshot\n5. Compare snapshots\n6. Look for objects that should have been freed\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What to look for"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Detached DOM nodes (should be 0)"}),"\n",(0,t.jsx)(n.li,{children:"Event listeners still attached"}),"\n",(0,t.jsx)(n.li,{children:"Timers still running"}),"\n",(0,t.jsx)(n.li,{children:"Components in memory after unmount"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"method-2-performance-monitor",children:"Method 2: Performance Monitor"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'1. Open DevTools \u2192 Performance Monitor\n2. Watch "JS heap size"\n3. Interact with app\n4. Heap should return to baseline after actions\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Normal"}),": Memory spikes then drops (garbage collected)\n",(0,t.jsx)(n.strong,{children:"Leak"}),": Memory increases steadily, never drops"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"method-3-automated-detection",children:"Method 3: Automated Detection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Add to development environment\nif (process.env.NODE_ENV === 'development') {\n  let previousHeap = 0;\n\n  setInterval(() => {\n    const current = (performance as any).memory?.usedJSHeapSize || 0;\n\n    if (current > previousHeap * 1.5) {\n      console.warn('Possible memory leak detected', {\n        previous: previousHeap,\n        current,\n        increase: current - previousHeap\n      });\n    }\n\n    previousHeap = current;\n  }, 5000);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-leak-patterns",children:"Common Leak Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"pattern-1-event-listeners-not-cleaned-up",children:"Pattern 1: Event Listeners Not Cleaned Up"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Event listener remains after component unmounts"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function SearchBox() {\n  useEffect(() => {\n    // Add listener\n    window.addEventListener('resize', handleResize);\n\n    // \u274c Missing cleanup\n  }, []);\n\n  return <input />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it leaks"}),": ",(0,t.jsx)(n.code,{children:"handleResize"})," references component, preventing garbage collection"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function SearchBox() {\n  useEffect(() => {\n    const handleResize = () => {\n      // Handle resize\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    // \u2705 Clean up on unmount\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return <input />;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pattern-2-timers-not-cleared",children:"Pattern 2: Timers Not Cleared"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": setInterval/setTimeout continues after unmount"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function LiveClock() {\n  const [time, setTime] = useState(new Date());\n\n  useEffect(() => {\n    // Start interval\n    setInterval(() => {\n      setTime(new Date());\n    }, 1000);\n\n    // \u274c Interval never cleared\n  }, []);\n\n  return <div>{time.toLocaleTimeString()}</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it leaks"}),": Interval continues forever, calling ",(0,t.jsx)(n.code,{children:"setTime"})," on unmounted component"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function LiveClock() {\n  const [time, setTime] = useState(new Date());\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setTime(new Date());\n    }, 1000);\n\n    // \u2705 Clear interval on unmount\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, []);\n\n  return <div>{time.toLocaleTimeString()}</div>;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pattern-3-subscriptions-not-unsubscribed",children:"Pattern 3: Subscriptions Not Unsubscribed"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": WebSocket/EventEmitter/Observable subscription persists"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function ChatRoom({ roomId }) {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() => {\n    const socket = io(`/rooms/${roomId}`);\n\n    socket.on('message', (msg) => {\n      setMessages(prev => [...prev, msg]);\n    });\n\n    // \u274c Socket never disconnected\n  }, [roomId]);\n\n  return <MessageList messages={messages} />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function ChatRoom({ roomId }) {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() => {\n    const socket = io(`/rooms/${roomId}`);\n\n    socket.on('message', (msg) => {\n      setMessages(prev => [...prev, msg]);\n    });\n\n    // \u2705 Disconnect and clean up\n    return () => {\n      socket.disconnect();\n    };\n  }, [roomId]);\n\n  return <MessageList messages={messages} />;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pattern-4-state-updates-on-unmounted-components",children:"Pattern 4: State Updates on Unmounted Components"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Async operation completes after unmount, tries to update state"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetchUser(userId).then(data => {\n      setUser(data);  // \u274c Might run after unmount\n    });\n  }, [userId]);\n\n  return <div>{user?.name}</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Warning in console"}),': "Can\'t perform a React state update on an unmounted component"']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code (Option 1: Cleanup flag)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true;\n\n    fetchUser(userId).then(data => {\n      if (isMounted) {\n        setUser(data);\n      }\n    });\n\n    return () => {\n      isMounted = false;\n    };\n  }, [userId]);\n\n  return <div>{user?.name}</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code (Option 2: AbortController)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    const controller = new AbortController();\n\n    fetchUser(userId, { signal: controller.signal })\n      .then(data => setUser(data))\n      .catch(err => {\n        if (err.name !== 'AbortError') {\n          console.error(err);\n        }\n      });\n\n    return () => {\n      controller.abort();\n    };\n  }, [userId]);\n\n  return <div>{user?.name}</div>;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pattern-5-closures-capturing-large-objects",children:"Pattern 5: Closures Capturing Large Objects"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Callback holds reference to large data structure"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function DataGrid({ data }) {  // data is 10MB array\n  const [selected, setSelected] = useState(null);\n\n  const handleClick = useCallback((id) => {\n    // \u274c Closure captures entire 'data' array\n    const item = data.find(d => d.id === id);\n    setSelected(item);\n  }, [data]);  // data is in dependency array\n\n  return <Table data={data} onRowClick={handleClick} />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it leaks"}),": Every re-render creates new function capturing 10MB data"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function DataGrid({ data }) {\n  const [selected, setSelected] = useState(null);\n\n  // Create lookup map (smaller memory footprint)\n  const dataMap = useMemo(() => {\n    return new Map(data.map(d => [d.id, d]));\n  }, [data]);\n\n  const handleClick = useCallback((id) => {\n    // \u2705 Closure only captures Map reference\n    const item = dataMap.get(id);\n    setSelected(item);\n  }, [dataMap]);\n\n  return <Table data={data} onRowClick={handleClick} />;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pattern-6-dom-references-not-cleared",children:"Pattern 6: DOM References Not Cleared"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Ref holds reference to detached DOM node"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function ImageGallery() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const imageRefs = useRef<HTMLImageElement[]>([]);\n\n  useEffect(() => {\n    // Store refs to all images\n    imageRefs.current = Array.from(\n      containerRef.current?.querySelectorAll('img') || []\n    );\n\n    // \u274c Image refs never cleared\n  }, []);\n\n  return (\n    <div ref={containerRef}>\n      {/* Images render here */}\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function ImageGallery() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const imageRefs = useRef<HTMLImageElement[]>([]);\n\n  useEffect(() => {\n    imageRefs.current = Array.from(\n      containerRef.current?.querySelectorAll('img') || []\n    );\n\n    // \u2705 Clear refs on unmount\n    return () => {\n      imageRefs.current = [];\n    };\n  }, []);\n\n  return (\n    <div ref={containerRef}>\n      {/* Images render here */}\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pattern-7-global-state-not-cleaned",children:"Pattern 7: Global State Not Cleaned"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Component adds data to global store but never removes it"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function UserSession({ userId }) {\n  useEffect(() => {\n    // Add user to global cache\n    globalCache.set(userId, fetchUser(userId));\n\n    // \u274c Never removed from cache\n  }, [userId]);\n\n  return <div>Session active</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it leaks"}),": Cache grows indefinitely as users navigate"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function UserSession({ userId }) {\n  useEffect(() => {\n    globalCache.set(userId, fetchUser(userId));\n\n    // \u2705 Clean up on unmount\n    return () => {\n      globalCache.delete(userId);\n    };\n  }, [userId]);\n\n  return <div>Session active</div>;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"pattern-8-third-party-library-instances",children:"Pattern 8: Third-Party Library Instances"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Library instance not destroyed"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u274c Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import mapboxgl from 'mapbox-gl';\n\nfunction MapView() {\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n\n  useEffect(() => {\n    mapRef.current = new mapboxgl.Map({\n      container: 'map',\n      style: 'mapbox://styles/mapbox/streets-v11'\n    });\n\n    // \u274c Map instance never destroyed\n  }, []);\n\n  return <div id=\"map\" />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\u2705 Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import mapboxgl from 'mapbox-gl';\n\nfunction MapView() {\n  const mapRef = useRef<mapboxgl.Map | null>(null);\n\n  useEffect(() => {\n    mapRef.current = new mapboxgl.Map({\n      container: 'map',\n      style: 'mapbox://styles/mapbox/streets-v11'\n    });\n\n    // \u2705 Destroy map on unmount\n    return () => {\n      mapRef.current?.remove();\n      mapRef.current = null;\n    };\n  }, []);\n\n  return <div id=\"map\" />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Common libraries that need cleanup"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Mapbox GL: ",(0,t.jsx)(n.code,{children:"map.remove()"})]}),"\n",(0,t.jsxs)(n.li,{children:["Chart.js: ",(0,t.jsx)(n.code,{children:"chart.destroy()"})]}),"\n",(0,t.jsxs)(n.li,{children:["Monaco Editor: ",(0,t.jsx)(n.code,{children:"editor.dispose()"})]}),"\n",(0,t.jsxs)(n.li,{children:["Three.js: ",(0,t.jsx)(n.code,{children:"renderer.dispose()"}),", ",(0,t.jsx)(n.code,{children:"geometry.dispose()"})]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-debugging",children:"Advanced Debugging"}),"\n",(0,t.jsx)(n.h3,{id:"using-chrome-devtools-memory-allocation-timeline",children:"Using Chrome DevTools Memory Allocation Timeline"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'1. DevTools \u2192 Performance tab\n2. Check "Memory" checkbox\n3. Click record\n4. Interact with app (open/close modal 10 times)\n5. Stop recording\n6. Look at heap size graph\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Healthy pattern"}),": Sawtooth (allocate, GC, allocate, GC)\n",(0,t.jsx)(n.strong,{children:"Leak pattern"}),": Steady increase (allocate, allocate, allocate)"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"heap-snapshot-comparison",children:"Heap Snapshot Comparison"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"1. Take snapshot A\n2. Open modal\n3. Take snapshot B\n4. Close modal\n5. Force GC (DevTools \u2192 Memory \u2192 Collect garbage icon)\n6. Take snapshot C\n7. Compare B and C\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What to look for"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Objects from modal still in snapshot C"}),"\n",(0,t.jsx)(n.li,{children:"Event listeners still attached"}),"\n",(0,t.jsx)(n.li,{children:"Timers still running"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Filter by"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Constructor name (e.g., "Timer", "Listener")'}),"\n",(0,t.jsx)(n.li,{children:"Retained size (objects holding most memory)"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"react-devtools-profiler",children:"React DevTools Profiler"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'1. React DevTools \u2192 Profiler\n2. Enable "Record why each component rendered"\n3. Navigate to page\n4. Navigate away\n5. Force GC\n6. Check if components still in memory\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"testing-for-memory-leaks",children:"Testing for Memory Leaks"}),"\n",(0,t.jsx)(n.h3,{id:"automated-test-jest--puppeteer",children:"Automated Test (Jest + Puppeteer)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import puppeteer from 'puppeteer';\n\ntest('Modal does not leak memory', async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n\n  await page.goto('http://localhost:3000');\n\n  // Take baseline heap size\n  const baseline = await page.evaluate(() => {\n    return (performance as any).memory.usedJSHeapSize;\n  });\n\n  // Open/close modal 20 times\n  for (let i = 0; i < 20; i++) {\n    await page.click('[data-testid=\"open-modal\"]');\n    await page.waitForSelector('[data-testid=\"modal\"]');\n    await page.click('[data-testid=\"close-modal\"]');\n    await page.waitForSelector('[data-testid=\"modal\"]', { hidden: true });\n  }\n\n  // Force garbage collection\n  await page.evaluate(() => {\n    if ((window as any).gc) {\n      (window as any).gc();\n    }\n  });\n\n  // Check final heap size\n  const final = await page.evaluate(() => {\n    return (performance as any).memory.usedJSHeapSize;\n  });\n\n  // Memory should not increase by more than 10MB\n  const increase = final - baseline;\n  expect(increase).toBeLessThan(10 * 1024 * 1024);\n\n  await browser.close();\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Run with"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"node --expose-gc node_modules/.bin/jest memory.test.ts\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"prevention-checklist",children:"Prevention Checklist"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u25a1 All event listeners cleaned up in useEffect return\n\u25a1 All timers (setTimeout/setInterval) cleared\n\u25a1 All subscriptions (WebSocket, EventEmitter) closed\n\u25a1 AbortController used for fetch requests\n\u25a1 Third-party library instances destroyed (.remove(), .destroy(), .dispose())\n\u25a1 Global state cleaned up on unmount\n\u25a1 Large objects not captured in closures\n\u25a1 DOM refs cleared on unmount\n\u25a1 Tested with heap snapshots (no growth after actions)\n\u25a1 Automated memory leak test in CI\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-libraries-and-cleanup",children:"Common Libraries and Cleanup"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Library"}),(0,t.jsx)(n.th,{children:"Cleanup Method"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Socket.IO"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"socket.disconnect()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"RxJS"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"subscription.unsubscribe()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Chart.js"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"chart.destroy()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Mapbox GL"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"map.remove()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Monaco Editor"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"editor.dispose()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Three.js"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"renderer.dispose()"}),", ",(0,t.jsx)(n.code,{children:"geometry.dispose()"}),", ",(0,t.jsx)(n.code,{children:"material.dispose()"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Video.js"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"player.dispose()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Swiper"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"swiper.destroy()"})})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"real-world-example",children:"Real-World Example"}),"\n",(0,t.jsx)(n.h3,{id:"problem-dashboard-leaking-50mb-per-navigation",children:"Problem: Dashboard Leaking 50MB per Navigation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptoms"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Page slow after 5-10 navigation cycles"}),"\n",(0,t.jsx)(n.li,{children:"Chrome DevTools shows heap growing from 50MB \u2192 500MB"}),"\n",(0,t.jsx)(n.li,{children:"Tab crashes after 15 minutes"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Investigation"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Heap snapshot comparison revealed:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"1000+ event listeners still attached"}),"\n",(0,t.jsx)(n.li,{children:"Chart.js instances not destroyed"}),"\n",(0,t.jsx)(n.li,{children:"WebSocket connections not closed"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Leaking Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function Dashboard() {\n  const chartRef = useRef<Chart | null>(null);\n\n  useEffect(() => {\n    // Create chart\n    chartRef.current = new Chart(ctx, config);\n\n    // Subscribe to updates\n    socket.on('data', updateChart);\n\n    // Add resize listener\n    window.addEventListener('resize', handleResize);\n\n    // \u274c Nothing cleaned up\n  }, []);\n\n  return <canvas ref={canvasRef} />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fixed Code"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function Dashboard() {\n  const chartRef = useRef<Chart | null>(null);\n\n  useEffect(() => {\n    chartRef.current = new Chart(ctx, config);\n    socket.on('data', updateChart);\n    window.addEventListener('resize', handleResize);\n\n    // \u2705 Clean up everything\n    return () => {\n      chartRef.current?.destroy();\n      socket.off('data', updateChart);\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return <canvas ref={canvasRef} />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Result"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Memory stable at ~50MB regardless of navigation"}),"\n",(0,t.jsx)(n.li,{children:"No crashes after extended use"}),"\n",(0,t.jsx)(n.li,{children:"Page remains fast"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://developer.chrome.com/docs/devtools/memory-problems/",children:"Chrome DevTools Memory Profiling"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development",children:"React useEffect Cleanup"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management",children:"JavaScript Memory Management"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);