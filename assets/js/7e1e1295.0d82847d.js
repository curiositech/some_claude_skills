"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[36686],{625:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"skills/test_automation_expert/references/coverage-patterns","title":"Coverage Optimization Patterns","description":"Strategies for meaningful test coverage that catches bugs without slowing development.","source":"@site/docs/skills/test_automation_expert/references/coverage-patterns.md","sourceDirName":"skills/test_automation_expert/references","slug":"/skills/test_automation_expert/references/coverage-patterns","permalink":"/docs/skills/test_automation_expert/references/coverage-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Coverage Optimization Patterns","sidebar_label":"Coverage Optimization Patterns","sidebar_position":2}}');var s=t(74848),i=t(28453);const a={title:"Coverage Optimization Patterns",sidebar_label:"Coverage Optimization Patterns",sidebar_position:2},c="Coverage Optimization Patterns",o={},l=[{value:"Understanding Coverage Metrics",id:"understanding-coverage-metrics",level:2},{value:"Types of Coverage",id:"types-of-coverage",level:3},{value:"Why Branch Coverage Matters Most",id:"why-branch-coverage-matters-most",level:3},{value:"Coverage Configuration",id:"coverage-configuration",level:2},{value:"Vitest",id:"vitest",level:3},{value:"Jest",id:"jest",level:3},{value:"pytest",id:"pytest",level:3},{value:"Finding Coverage Gaps",id:"finding-coverage-gaps",level:2},{value:"Command Line Analysis",id:"command-line-analysis",level:3},{value:"HTML Report Navigation",id:"html-report-navigation",level:3},{value:"Identifying Critical Gaps",id:"identifying-critical-gaps",level:3},{value:"Coverage Anti-Patterns",id:"coverage-anti-patterns",level:2},{value:"Anti-Pattern: Coverage Without Assertions",id:"anti-pattern-coverage-without-assertions",level:3},{value:"Anti-Pattern: Testing Private Internals",id:"anti-pattern-testing-private-internals",level:3},{value:"Anti-Pattern: Excessive Mocking",id:"anti-pattern-excessive-mocking",level:3},{value:"Effective Coverage Strategies",id:"effective-coverage-strategies",level:2},{value:"Strategy 1: Test Behaviors, Not Lines",id:"strategy-1-test-behaviors-not-lines",level:3},{value:"Strategy 2: Boundary Value Testing",id:"strategy-2-boundary-value-testing",level:3},{value:"Strategy 3: Error Path Testing",id:"strategy-3-error-path-testing",level:3},{value:"Strategy 4: Parameterized Tests",id:"strategy-4-parameterized-tests",level:3},{value:"Strategy 5: Coverage-Driven Refactoring",id:"strategy-5-coverage-driven-refactoring",level:3},{value:"Coverage in CI/CD",id:"coverage-in-cicd",level:2},{value:"GitHub Actions",id:"github-actions",level:3},{value:"Coverage Diff on PRs",id:"coverage-diff-on-prs",level:3},{value:"Coverage Reporting Tools",id:"coverage-reporting-tools",level:2},{value:"Realistic Targets",id:"realistic-targets",level:2},{value:"By Project Type",id:"by-project-type",level:3},{value:"Incremental Improvement",id:"incremental-improvement",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"coverage-optimization-patterns",children:"Coverage Optimization Patterns"})}),"\n",(0,s.jsx)(n.p,{children:"Strategies for meaningful test coverage that catches bugs without slowing development."}),"\n",(0,s.jsx)(n.h2,{id:"understanding-coverage-metrics",children:"Understanding Coverage Metrics"}),"\n",(0,s.jsx)(n.h3,{id:"types-of-coverage",children:"Types of Coverage"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric"}),(0,s.jsx)(n.th,{children:"What It Measures"}),(0,s.jsx)(n.th,{children:"Target"}),(0,s.jsx)(n.th,{children:"Priority"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Line"})}),(0,s.jsx)(n.td,{children:"Executed lines"}),(0,s.jsx)(n.td,{children:"80%"}),(0,s.jsx)(n.td,{children:"Medium"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Branch"})}),(0,s.jsx)(n.td,{children:"Decision paths (if/else)"}),(0,s.jsx)(n.td,{children:"75%"}),(0,s.jsx)(n.td,{children:"High"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Function"})}),(0,s.jsx)(n.td,{children:"Called functions"}),(0,s.jsx)(n.td,{children:"90%"}),(0,s.jsx)(n.td,{children:"Medium"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Statement"})}),(0,s.jsx)(n.td,{children:"Executed statements"}),(0,s.jsx)(n.td,{children:"80%"}),(0,s.jsx)(n.td,{children:"Low"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Condition"})}),(0,s.jsx)(n.td,{children:"Boolean sub-expressions"}),(0,s.jsx)(n.td,{children:"70%"}),(0,s.jsx)(n.td,{children:"High"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Path"})}),(0,s.jsx)(n.td,{children:"Unique execution paths"}),(0,s.jsx)(n.td,{children:"60%"}),(0,s.jsx)(n.td,{children:"Low"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"why-branch-coverage-matters-most",children:"Why Branch Coverage Matters Most"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function processOrder(order) {\n  if (order.isPriority && order.total > 100) {  // 4 branches!\n    applyDiscount(order);\n  }\n  return order;\n}\n\n// Line coverage: 100% with just one test\n// Branch coverage: Only 25% - missing 3 combinations!\n\n// Need tests for:\n// 1. isPriority=true, total&gt;100 (discount applied)\n// 2. isPriority=true, total<=100 (no discount)\n// 3. isPriority=false, total&gt;100 (no discount)\n// 4. isPriority=false, total<=100 (no discount)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"coverage-configuration",children:"Coverage Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"vitest",children:"Vitest"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// vitest.config.ts\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'v8', // or 'istanbul'\n      reporter: ['text', 'json', 'html', 'lcov'],\n      reportsDirectory: './coverage',\n\n      // What to include\n      include: ['src/**/*.{ts,tsx}'],\n\n      // What to exclude\n      exclude: [\n        'node_modules/',\n        'src/**/*.d.ts',\n        'src/**/*.test.{ts,tsx}',\n        'src/**/*.spec.{ts,tsx}',\n        'src/**/*.stories.{ts,tsx}',\n        'src/**/index.ts',      // Barrel files\n        'src/**/types.ts',      // Type definitions\n        'src/**/*.config.*',    // Config files\n        'src/mocks/**',         // Test mocks\n        'src/__fixtures__/**',  // Test fixtures\n      ],\n\n      // Thresholds\n      thresholds: {\n        global: {\n          branches: 75,\n          functions: 80,\n          lines: 80,\n          statements: 80,\n        },\n        // Per-file thresholds\n        'src/utils/**': {\n          branches: 90,\n          functions: 95,\n        },\n        'src/components/**': {\n          branches: 70,\n          lines: 75,\n        },\n      },\n\n      // Fail if coverage drops\n      watermarks: {\n        lines: [70, 80],\n        functions: [70, 80],\n        branches: [70, 75],\n        statements: [70, 80],\n      },\n    },\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"jest",children:"Jest"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// jest.config.js\nmodule.exports = {\n  collectCoverage: true,\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n\n  collectCoverageFrom: [\n    'src/**/*.{js,jsx,ts,tsx}',\n    '!src/**/*.d.ts',\n    '!src/**/*.stories.*',\n    '!src/**/*.test.*',\n    '!src/**/index.{js,ts}',\n  ],\n\n  coverageThreshold: {\n    global: {\n      branches: 75,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n    './src/utils/': {\n      branches: 90,\n      functions: 95,\n    },\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"pytest",children:"pytest"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'# pyproject.toml\n[tool.coverage.run]\nbranch = true\nsource = ["src"]\nomit = [\n    "tests/*",\n    "**/__init__.py",\n    "**/conftest.py",\n    "**/*_test.py",\n]\nparallel = true\n\n[tool.coverage.report]\nfail_under = 80\nshow_missing = true\nskip_covered = false\nexclude_lines = [\n    "pragma: no cover",\n    "def __repr__",\n    "raise NotImplementedError",\n    "if TYPE_CHECKING:",\n    "if __name__ == .__main__.:",\n    "@abstractmethod",\n]\n\n[tool.coverage.html]\ndirectory = "coverage_html"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"finding-coverage-gaps",children:"Finding Coverage Gaps"}),"\n",(0,s.jsx)(n.h3,{id:"command-line-analysis",children:"Command Line Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Vitest - show uncovered lines\nnpx vitest run --coverage\n\n# Jest - detailed report\nnpx jest --coverage --coverageReporters=text-summary\n\n# Find files with low coverage\nnpx vitest run --coverage --reporter=json | \\\n  jq '.coverageMap | to_entries |\n      map(select(.value.s | values | map(select(. == 0)) | length > 0)) |\n      .[].key'\n\n# pytest - show missing lines\npytest --cov=src --cov-report=term-missing\n"})}),"\n",(0,s.jsx)(n.h3,{id:"html-report-navigation",children:"HTML Report Navigation"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Generate HTML report: ",(0,s.jsx)(n.code,{children:"npx vitest run --coverage"})]}),"\n",(0,s.jsxs)(n.li,{children:["Open ",(0,s.jsx)(n.code,{children:"coverage/index.html"})]}),"\n",(0,s.jsx)(n.li,{children:'Sort by "Branches" or "Lines" (ascending)'}),"\n",(0,s.jsx)(n.li,{children:"Click into files with low coverage"}),"\n",(0,s.jsx)(n.li,{children:"Red highlights = uncovered code"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"identifying-critical-gaps",children:"Identifying Critical Gaps"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Priority order for fixing gaps:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error handling paths"})," - Often untested but critical"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"try {\n  await api.call();\n} catch (error) {\n  // This branch often untested!\n  logger.error(error);\n  throw new AppError('API failed');\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Edge cases in conditionals"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"if (value === null || value === undefined) {\n  // Null/undefined often missed\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Async error paths"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"promise.catch(error => {\n  // Rejection handlers often untested\n});\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Default switch cases"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"switch (status) {\n  case 'active': return 'green';\n  case 'pending': return 'yellow';\n  default: return 'gray'; // Often untested\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"coverage-anti-patterns",children:"Coverage Anti-Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"anti-pattern-coverage-without-assertions",children:"Anti-Pattern: Coverage Without Assertions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u274c Bad: Executes code but tests nothing\nit('covers the function', () => {\n  processOrder({ id: 1 });\n  // No expect()!\n});\n\n// \u2705 Good: Meaningful assertions\nit('processes valid order', () => {\n  const result = processOrder({ id: 1, items: [{ price: 10 }] });\n  expect(result.total).toBe(10);\n  expect(result.status).toBe('processed');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"anti-pattern-testing-private-internals",children:"Anti-Pattern: Testing Private Internals"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u274c Bad: Testing implementation detail\nit('sets internal flag', () => {\n  const service = new UserService();\n  service._processUser(user);\n  expect(service._isProcessed).toBe(true);\n});\n\n// \u2705 Good: Test observable behavior\nit('marks user as active after processing', () => {\n  const service = new UserService();\n  const result = service.processUser(user);\n  expect(result.status).toBe('active');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"anti-pattern-excessive-mocking",children:"Anti-Pattern: Excessive Mocking"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u274c Bad: Everything mocked, testing nothing real\njest.mock('./database');\njest.mock('./logger');\njest.mock('./validator');\njest.mock('./formatter');\n\nit('processes data', () => {\n  // All real code is mocked out!\n});\n\n// \u2705 Good: Mock only boundaries\njest.mock('./database'); // External system\n\nit('validates and saves data', () => {\n  // Real validation, real formatting\n  // Only DB is mocked\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"effective-coverage-strategies",children:"Effective Coverage Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"strategy-1-test-behaviors-not-lines",children:"Strategy 1: Test Behaviors, Not Lines"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Instead of testing each line...\ndescribe('OrderCalculator', () => {\n  // Test the behaviors users care about\n  it('calculates subtotal from items', () => {});\n  it('applies percentage discount', () => {});\n  it('applies fixed discount', () => {});\n  it('calculates tax after discounts', () => {});\n  it('rounds total to 2 decimal places', () => {});\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"strategy-2-boundary-value-testing",children:"Strategy 2: Boundary Value Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Test at boundaries, not random values\ndescribe('validateAge', () => {\n  it('rejects age below minimum (17)', () => {\n    expect(validateAge(17)).toBe(false);\n  });\n\n  it('accepts age at minimum (18)', () => {\n    expect(validateAge(18)).toBe(true);\n  });\n\n  it('accepts age at maximum (120)', () => {\n    expect(validateAge(120)).toBe(true);\n  });\n\n  it('rejects age above maximum (121)', () => {\n    expect(validateAge(121)).toBe(false);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"strategy-3-error-path-testing",children:"Strategy 3: Error Path Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"describe('fetchUser', () => {\n  it('returns user on success', async () => {\n    mockApi.get.mockResolvedValue({ data: { id: 1 } });\n    const user = await fetchUser(1);\n    expect(user.id).toBe(1);\n  });\n\n  // Explicitly test each error case\n  it('throws NotFoundError for 404', async () => {\n    mockApi.get.mockRejectedValue({ status: 404 });\n    await expect(fetchUser(999)).rejects.toThrow(NotFoundError);\n  });\n\n  it('throws NetworkError for timeout', async () => {\n    mockApi.get.mockRejectedValue({ code: 'ETIMEDOUT' });\n    await expect(fetchUser(1)).rejects.toThrow(NetworkError);\n  });\n\n  it('retries on 503 before failing', async () => {\n    mockApi.get\n      .mockRejectedValueOnce({ status: 503 })\n      .mockRejectedValueOnce({ status: 503 })\n      .mockResolvedValue({ data: { id: 1 } });\n\n    const user = await fetchUser(1);\n    expect(mockApi.get).toHaveBeenCalledTimes(3);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"strategy-4-parameterized-tests",children:"Strategy 4: Parameterized Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Test multiple cases efficiently\ndescribe.each([\n  ['valid@email.com', true],\n  ['user+tag@domain.co', true],\n  ['name@subdomain.domain.org', true],\n  ['invalid', false],\n  ['@missing.com', false],\n  ['spaces @domain.com', false],\n  ['', false],\n  [null, false],\n])('validateEmail(%s)', (email, expected) => {\n  it(`returns ${expected}`, () => {\n    expect(validateEmail(email)).toBe(expected);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"strategy-5-coverage-driven-refactoring",children:"Strategy 5: Coverage-Driven Refactoring"}),"\n",(0,s.jsx)(n.p,{children:"When you find untestable code, refactor it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u274c Hard to test: side effects mixed with logic\nfunction processOrder(order) {\n  const discount = order.customer.tier === 'gold' ? 0.1 : 0;\n  const total = order.items.reduce((sum, i) => sum + i.price, 0);\n  const finalTotal = total * (1 - discount);\n\n  database.save({ ...order, total: finalTotal }); // Side effect!\n  emailService.send(order.customer.email, finalTotal); // Side effect!\n\n  return finalTotal;\n}\n\n// \u2705 Testable: Pure calculation, separate side effects\nfunction calculateOrderTotal(order) {\n  const discount = getCustomerDiscount(order.customer);\n  const subtotal = calculateSubtotal(order.items);\n  return applyDiscount(subtotal, discount);\n}\n\nfunction processOrder(order) {\n  const total = calculateOrderTotal(order);\n  await saveOrder({ ...order, total });\n  await notifyCustomer(order.customer, total);\n  return total;\n}\n\n// Now you can unit test calculateOrderTotal with 100% coverage\n// And integration test processOrder separately\n"})}),"\n",(0,s.jsx)(n.h2,{id:"coverage-in-cicd",children:"Coverage in CI/CD"}),"\n",(0,s.jsx)(n.h3,{id:"github-actions",children:"GitHub Actions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'- name: Run tests with coverage\n  run: npm test -- --coverage --coverageReporters=json-summary\n\n- name: Check coverage thresholds\n  run: |\n    COVERAGE=$(cat coverage/coverage-summary.json | jq \'.total.lines.pct\')\n    if (( $(echo "$COVERAGE < 80" | bc -l) )); then\n      echo "Coverage $COVERAGE% is below 80%"\n      exit 1\n    fi\n\n- name: Upload coverage to Codecov\n  uses: codecov/codecov-action@v4\n  with:\n    files: ./coverage/lcov.info\n    fail_ci_if_error: true\n'})}),"\n",(0,s.jsx)(n.h3,{id:"coverage-diff-on-prs",children:"Coverage Diff on PRs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"- name: Coverage diff\n  uses: ArtiomTr/jest-coverage-report-action@v2\n  with:\n    threshold: 80\n    annotations: coverage\n"})}),"\n",(0,s.jsx)(n.h2,{id:"coverage-reporting-tools",children:"Coverage Reporting Tools"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Tool"}),(0,s.jsx)(n.th,{children:"Features"}),(0,s.jsx)(n.th,{children:"Best For"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Codecov"}),(0,s.jsx)(n.td,{children:"Diff, history, PR comments"}),(0,s.jsx)(n.td,{children:"Open source, teams"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Coveralls"}),(0,s.jsx)(n.td,{children:"Simple, badges"}),(0,s.jsx)(n.td,{children:"Small projects"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SonarQube"}),(0,s.jsx)(n.td,{children:"Quality gates, security"}),(0,s.jsx)(n.td,{children:"Enterprise"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Code Climate"}),(0,s.jsx)(n.td,{children:"Maintainability metrics"}),(0,s.jsx)(n.td,{children:"Full analysis"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"realistic-targets",children:"Realistic Targets"}),"\n",(0,s.jsx)(n.h3,{id:"by-project-type",children:"By Project Type"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Line"}),(0,s.jsx)(n.th,{children:"Branch"}),(0,s.jsx)(n.th,{children:"Rationale"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Library/SDK"}),(0,s.jsx)(n.td,{children:"90%"}),(0,s.jsx)(n.td,{children:"85%"}),(0,s.jsx)(n.td,{children:"High reuse, stable"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"API Service"}),(0,s.jsx)(n.td,{children:"80%"}),(0,s.jsx)(n.td,{children:"75%"}),(0,s.jsx)(n.td,{children:"Core paths critical"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Web App"}),(0,s.jsx)(n.td,{children:"75%"}),(0,s.jsx)(n.td,{children:"70%"}),(0,s.jsx)(n.td,{children:"UI harder to test"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CLI Tool"}),(0,s.jsx)(n.td,{children:"85%"}),(0,s.jsx)(n.td,{children:"80%"}),(0,s.jsx)(n.td,{children:"Fewer UI concerns"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Legacy Migration"}),(0,s.jsx)(n.td,{children:"60%"}),(0,s.jsx)(n.td,{children:"50%"}),(0,s.jsx)(n.td,{children:"Start somewhere"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"incremental-improvement",children:"Incremental Improvement"}),"\n",(0,s.jsx)(n.p,{children:"Week 1: Establish baseline, add CI check\nWeek 2: Target +5% on lowest files\nWeek 4: Hit 60% if starting low\nWeek 8: Hit 70% overall\nWeek 12: Hit 80% stable target"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);