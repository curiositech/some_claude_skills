"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[13900],{28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>c});var i=t(96540);const a={},s=i.createContext(a);function r(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),i.createElement(s.Provider,{value:e},n.children)}},42978:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"skills/dag_semantic_matcher/index","title":"\ud83d\udce6 Dag Semantic Matcher","description":"Matches natural language task descriptions to appropriate skills using semantic similarity. Handles fuzzy matching, intent extraction, and capability alignment. Activate on \'find skill\', \'match task\', \'semantic search\', \'skill lookup\', \'what skill for\'. NOT for ranking matches (use dag-capability-ranker) or skill catalog (use dag-skill-registry).","source":"@site/docs/skills/dag_semantic_matcher/index.md","sourceDirName":"skills/dag_semantic_matcher","slug":"/skills/dag_semantic_matcher/","permalink":"/docs/skills/dag_semantic_matcher/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Semantic Matcher","sidebar_position":1}}');var a=t(74848),s=t(28453);const r={sidebar_label:"Dag Semantic Matcher",sidebar_position:1},c="\ud83d\udce6 Dag Semantic Matcher",l={},o=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Intent Extraction",id:"1-intent-extraction",level:3},{value:"2. Semantic Matching",id:"2-semantic-matching",level:3},{value:"3. Candidate Generation",id:"3-candidate-generation",level:3},{value:"4. Match Explanation",id:"4-match-explanation",level:3},{value:"Matching Algorithm",id:"matching-algorithm",level:2},{value:"Intent Extraction",id:"intent-extraction",level:2},{value:"Semantic Similarity",id:"semantic-similarity",level:2},{value:"Match Scoring",id:"match-scoring",level:2},{value:"Match Explanation",id:"match-explanation",level:2},{value:"Query Expansion",id:"query-expansion",level:2},{value:"Output Format",id:"output-format",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"-dag-semantic-matcher",children:"\ud83d\udce6 Dag Semantic Matcher"})}),"\n",(0,a.jsx)(e.p,{children:"Matches natural language task descriptions to appropriate skills using semantic similarity. Handles fuzzy matching, intent extraction, and capability alignment. Activate on 'find skill', 'match task', 'semantic search', 'skill lookup', 'what skill for'. NOT for ranking matches (use dag-capability-ranker) or skill catalog (use dag-skill-registry)."}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,a.jsx)(e.h2,{id:"tags",children:"Tags"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"dag"})," ",(0,a.jsx)(e.code,{children:"registry"})," ",(0,a.jsx)(e.code,{children:"semantic-matching"})," ",(0,a.jsx)(e.code,{children:"nlp"})," ",(0,a.jsx)(e.code,{children:"discovery"})]}),"\n",(0,a.jsx)(e.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/docs/skills/dag_skill_registry",children:"Dag Skill Registry"})}),": Searches the skill catalog"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/docs/skills/dag_capability_ranker",children:"Dag Capability Ranker"})}),": Ranks semantic matches"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/docs/skills/dag_graph_builder",children:"Dag Graph Builder"})}),": Provides skills for node assignment"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"You are a DAG Semantic Matcher, an expert at finding the right skills for natural language task descriptions. You use semantic understanding to match task requirements with skill capabilities, extracting intent and aligning capabilities even when descriptions don't use exact terminology."}),"\n",(0,a.jsx)(e.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,a.jsx)(e.h3,{id:"1-intent-extraction",children:"1. Intent Extraction"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Parse natural language task descriptions"}),"\n",(0,a.jsx)(e.li,{children:"Identify required capabilities and constraints"}),"\n",(0,a.jsx)(e.li,{children:"Extract implicit requirements and preferences"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"2-semantic-matching",children:"2. Semantic Matching"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Compare task requirements to skill capabilities"}),"\n",(0,a.jsx)(e.li,{children:"Handle synonyms, related terms, and concepts"}),"\n",(0,a.jsx)(e.li,{children:"Score matches based on semantic similarity"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"3-candidate-generation",children:"3. Candidate Generation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Generate initial candidate skill list"}),"\n",(0,a.jsx)(e.li,{children:"Apply filters based on constraints"}),"\n",(0,a.jsx)(e.li,{children:"Expand search when needed"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"4-match-explanation",children:"4. Match Explanation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Explain why skills match or don't match"}),"\n",(0,a.jsx)(e.li,{children:"Identify capability gaps"}),"\n",(0,a.jsx)(e.li,{children:"Suggest alternatives for partial matches"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"matching-algorithm",children:"Matching Algorithm"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface TaskDescription {\n  raw: string;              // Original natural language\n  intent: Intent;           // Extracted intent\n  capabilities: string[];   // Required capabilities\n  constraints: Constraint[];\n  context: TaskContext;\n}\n\ninterface Intent {\n  primary: string;          // Main action/goal\n  secondary: string[];      // Supporting actions\n  domain: string;           // Problem domain\n}\n\ninterface MatchResult {\n  skillId: string;\n  score: number;            // 0-1 overall match score\n  breakdown: {\n    intentMatch: number;\n    capabilityMatch: number;\n    constraintMatch: number;\n  };\n  explanation: string;\n  gaps: string[];           // Missing capabilities\n}\n\nasync function matchTaskToSkills(\n  task: TaskDescription,\n  registry: SkillRegistry\n): Promise<MatchResult[]> {\n  // Extract intent from raw description\n  const intent = await extractIntent(task.raw);\n  task.intent = intent;\n\n  // Generate candidates based on capabilities\n  const candidates = generateCandidates(task, registry);\n\n  // Score each candidate\n  const scored = await Promise.all(\n    candidates.map(skill => scoreMatch(task, skill))\n  );\n\n  // Sort by score descending\n  return scored.sort((a, b) => b.score - a.score);\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"intent-extraction",children:"Intent Extraction"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface IntentExtraction {\n  action: string;           // What to do\n  object: string;           // What to do it to\n  modifiers: string[];      // How to do it\n  domain: string;           // Problem area\n}\n\nasync function extractIntent(\n  description: string\n): Promise<Intent> {\n  // Common action patterns\n  const actionPatterns = {\n    create: ['build', 'create', 'make', 'generate', 'write'],\n    analyze: ['analyze', 'examine', 'review', 'inspect', 'check'],\n    modify: ['update', 'change', 'edit', 'fix', 'refactor'],\n    validate: ['validate', 'verify', 'test', 'ensure', 'confirm'],\n    transform: ['convert', 'transform', 'translate', 'migrate'],\n  };\n\n  // Domain patterns\n  const domainPatterns = {\n    code: ['code', 'function', 'class', 'module', 'api'],\n    data: ['data', 'database', 'schema', 'query', 'model'],\n    docs: ['documentation', 'readme', 'guide', 'tutorial'],\n    test: ['test', 'spec', 'coverage', 'assertion'],\n    security: ['security', 'vulnerability', 'auth', 'permission'],\n  };\n\n  const normalizedDesc = description.toLowerCase();\n\n  // Find primary action\n  let primaryAction = 'unknown';\n  for (const [action, patterns] of Object.entries(actionPatterns)) {\n    if (patterns.some(p => normalizedDesc.includes(p))) {\n      primaryAction = action;\n      break;\n    }\n  }\n\n  // Find domain\n  let domain = 'general';\n  for (const [d, patterns] of Object.entries(domainPatterns)) {\n    if (patterns.some(p => normalizedDesc.includes(p))) {\n      domain = d;\n      break;\n    }\n  }\n\n  return {\n    primary: primaryAction,\n    secondary: [],\n    domain,\n  };\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"semantic-similarity",children:"Semantic Similarity"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Capability synonyms and related terms\nconst capabilitySynonyms: Map<string, string[]> = new Map([\n  ['code-review', ['review code', 'check code', 'code analysis', 'code quality']],\n  ['testing', ['test', 'spec', 'unit test', 'integration test', 'qa']],\n  ['documentation', ['docs', 'readme', 'guide', 'tutorial', 'api docs']],\n  ['refactoring', ['refactor', 'clean up', 'improve', 'restructure']],\n  ['security', ['security audit', 'vulnerability scan', 'pen test']],\n]);\n\nfunction semanticSimilarity(\n  term1: string,\n  term2: string\n): number {\n  // Exact match\n  if (term1 === term2) return 1.0;\n\n  // Check synonyms\n  for (const [canonical, synonyms] of capabilitySynonyms) {\n    const allTerms = [canonical, ...synonyms];\n    if (allTerms.includes(term1) && allTerms.includes(term2)) {\n      return 0.9;\n    }\n  }\n\n  // Substring match\n  if (term1.includes(term2) || term2.includes(term1)) {\n    return 0.7;\n  }\n\n  // Word overlap\n  const words1 = new Set(term1.split(/\\s+/));\n  const words2 = new Set(term2.split(/\\s+/));\n  const intersection = new Set([...words1].filter(x => words2.has(x)));\n  const union = new Set([...words1, ...words2]);\n  const jaccard = intersection.size / union.size;\n\n  return jaccard * 0.6;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"match-scoring",children:"Match Scoring"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"function scoreMatch(\n  task: TaskDescription,\n  skill: SkillMetadata\n): MatchResult {\n  // Intent match\n  const intentScore = scoreIntentMatch(task.intent, skill);\n\n  // Capability match\n  const capScore = scoreCapabilityMatch(\n    task.capabilities,\n    skill.capabilities\n  );\n\n  // Constraint match\n  const constraintScore = scoreConstraintMatch(\n    task.constraints,\n    skill\n  );\n\n  // Combined score (weighted)\n  const score = (\n    intentScore * 0.3 +\n    capScore * 0.5 +\n    constraintScore * 0.2\n  );\n\n  // Find capability gaps\n  const gaps = findCapabilityGaps(task.capabilities, skill.capabilities);\n\n  return {\n    skillId: skill.id,\n    score,\n    breakdown: {\n      intentMatch: intentScore,\n      capabilityMatch: capScore,\n      constraintMatch: constraintScore,\n    },\n    explanation: generateExplanation(task, skill, score),\n    gaps,\n  };\n}\n\nfunction scoreCapabilityMatch(\n  required: string[],\n  available: Capability[]\n): number {\n  if (required.length === 0) return 0.5;\n\n  let totalScore = 0;\n  for (const req of required) {\n    let bestMatch = 0;\n    for (const cap of available) {\n      const similarity = semanticSimilarity(req, cap.name);\n      const adjustedScore = similarity * cap.confidence;\n      bestMatch = Math.max(bestMatch, adjustedScore);\n    }\n    totalScore += bestMatch;\n  }\n\n  return totalScore / required.length;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"match-explanation",children:"Match Explanation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"function generateExplanation(\n  task: TaskDescription,\n  skill: SkillMetadata,\n  score: number\n): string {\n  const parts: string[] = [];\n\n  if (score >= 0.8) {\n    parts.push(`Strong match for \"${task.intent.primary}\" tasks.`);\n  } else if (score >= 0.6) {\n    parts.push(`Good match with some capability alignment.`);\n  } else if (score >= 0.4) {\n    parts.push(`Partial match - may need supplementary skills.`);\n  } else {\n    parts.push(`Weak match - consider alternatives.`);\n  }\n\n  // Explain what matched\n  const matchedCaps = skill.capabilities\n    .filter(cap =>\n      task.capabilities.some(req =>\n        semanticSimilarity(req, cap.name) > 0.6\n      )\n    )\n    .map(cap => cap.name);\n\n  if (matchedCaps.length > 0) {\n    parts.push(`Matches: ${matchedCaps.join(', ')}`);\n  }\n\n  return parts.join(' ');\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"query-expansion",children:"Query Expansion"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"function expandQuery(\n  task: TaskDescription\n): TaskDescription {\n  const expanded = { ...task };\n  const additionalCaps: string[] = [];\n\n  // Add synonyms for required capabilities\n  for (const cap of task.capabilities) {\n    for (const [canonical, synonyms] of capabilitySynonyms) {\n      if (cap === canonical || synonyms.includes(cap)) {\n        additionalCaps.push(canonical, ...synonyms);\n      }\n    }\n  }\n\n  expanded.capabilities = [\n    ...new Set([...task.capabilities, ...additionalCaps]),\n  ];\n\n  return expanded;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"output-format",children:"Output Format"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'matchResults:\n  query: "Review this TypeScript code for bugs and security issues"\n\n  extractedIntent:\n    primary: analyze\n    secondary: [validate]\n    domain: code\n\n  requiredCapabilities:\n    - code-review\n    - bug-detection\n    - security-analysis\n\n  matches:\n    - skillId: code-reviewer\n      score: 0.92\n      breakdown:\n        intentMatch: 0.95\n        capabilityMatch: 0.90\n        constraintMatch: 0.90\n      explanation: "Strong match for \'analyze\' tasks. Matches: code-review, bug-detection"\n      gaps: []\n\n    - skillId: security-auditor\n      score: 0.78\n      breakdown:\n        intentMatch: 0.80\n        capabilityMatch: 0.85\n        constraintMatch: 0.70\n      explanation: "Good match with security focus. Matches: security-analysis"\n      gaps: [bug-detection]\n\n    - skillId: typescript-expert\n      score: 0.65\n      breakdown:\n        intentMatch: 0.70\n        capabilityMatch: 0.60\n        constraintMatch: 0.65\n      explanation: "Partial match - specialized in TypeScript but general purpose"\n      gaps: [security-analysis]\n'})}),"\n",(0,a.jsx)(e.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Registry"}),": Queries ",(0,a.jsx)(e.code,{children:"dag-skill-registry"})," for skill catalog"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Ranking"}),": Passes candidates to ",(0,a.jsx)(e.code,{children:"dag-capability-ranker"})]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Consumers"}),": ",(0,a.jsx)(e.code,{children:"dag-graph-builder"})," for node skill assignment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Feedback"}),": Performance data from ",(0,a.jsx)(e.code,{children:"dag-pattern-learner"})]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Expand Queries"}),": Use synonyms to improve recall"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Weight Capabilities"}),": Not all matches are equal"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Explain Matches"}),": Transparency builds trust"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Track Performance"}),": Learn from successful matches"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Handle Ambiguity"}),": Ask for clarification when unsure"]}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.p,{children:"Natural language in. Perfect skills out. Semantic understanding."})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);