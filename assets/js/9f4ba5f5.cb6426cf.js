"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[67597],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(96540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},88721:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"skills/real_time_collaboration_engine/index","title":"Real-Time Collaboration Engine","description":"Build real-time collaborative editing with WebSockets, OT/CRDT conflict resolution, and presence awareness. Implements cursor tracking, optimistic updates, and offline sync. Use for collaborative editors, whiteboards, video editing. Activate on \\"real-time collaboration\\", \\"WebSocket sync\\", \\"multiplayer editing\\", \\"CRDT\\", \\"presence awareness\\". NOT for simple chat, request-response APIs, or single-user apps.","source":"@site/docs/skills/real_time_collaboration_engine/index.md","sourceDirName":"skills/real_time_collaboration_engine","slug":"/skills/real_time_collaboration_engine","permalink":"/docs/skills/real_time_collaboration_engine","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"name":"real-time-collaboration-engine","description":"Build real-time collaborative editing with WebSockets, OT/CRDT conflict resolution, and presence awareness. Implements cursor tracking, optimistic updates, and offline sync. Use for collaborative editors, whiteboards, video editing. Activate on \\"real-time collaboration\\", \\"WebSocket sync\\", \\"multiplayer editing\\", \\"CRDT\\", \\"presence awareness\\". NOT for simple chat, request-response APIs, or single-user apps.","allowed-tools":"Read,Write,Edit,Bash(npm:*,websocket:*)","slug":"/skills/real_time_collaboration_engine"}}');var r=t(74848),i=t(28453);const o={name:"real-time-collaboration-engine",description:'Build real-time collaborative editing with WebSockets, OT/CRDT conflict resolution, and presence awareness. Implements cursor tracking, optimistic updates, and offline sync. Use for collaborative editors, whiteboards, video editing. Activate on "real-time collaboration", "WebSocket sync", "multiplayer editing", "CRDT", "presence awareness". NOT for simple chat, request-response APIs, or single-user apps.',"allowed-tools":"Read,Write,Edit,Bash(npm:*,websocket:*)",slug:"/skills/real_time_collaboration_engine"},c="Real-Time Collaboration Engine",a={},l=[{value:"When to Use",id:"when-to-use",level:2},{value:"Quick Decision Tree",id:"quick-decision-tree",level:2},{value:"Technology Selection",id:"technology-selection",level:2},{value:"Conflict Resolution Strategies (2024)",id:"conflict-resolution-strategies-2024",level:3},{value:"Common Anti-Patterns",id:"common-anti-patterns",level:2},{value:"Anti-Pattern 1: Broadcasting Every Keystroke",id:"anti-pattern-1-broadcasting-every-keystroke",level:3},{value:"Anti-Pattern 2: No Conflict Resolution Strategy",id:"anti-pattern-2-no-conflict-resolution-strategy",level:3},{value:"Anti-Pattern 3: Not Handling Disconnections",id:"anti-pattern-3-not-handling-disconnections",level:3},{value:"Anti-Pattern 4: Client-Only State Sync",id:"anti-pattern-4-client-only-state-sync",level:3},{value:"Anti-Pattern 5: No Presence Awareness",id:"anti-pattern-5-no-presence-awareness",level:3},{value:"Implementation Patterns",id:"implementation-patterns",level:2},{value:"Pattern 1: WebSocket Setup with Reconnection",id:"pattern-1-websocket-setup-with-reconnection",level:3},{value:"Pattern 2: Operational Transform (Text)",id:"pattern-2-operational-transform-text",level:3},{value:"Pattern 3: CRDT with Yjs",id:"pattern-3-crdt-with-yjs",level:3},{value:"Pattern 4: Presence Awareness",id:"pattern-4-presence-awareness",level:3},{value:"Pattern 5: Optimistic Updates with Rollback",id:"pattern-5-optimistic-updates-with-rollback",level:3},{value:"Production Checklist",id:"production-checklist",level:2},{value:"When to Use vs Avoid",id:"when-to-use-vs-avoid",level:2},{value:"References",id:"references",level:2},{value:"Scripts",id:"scripts",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"real-time-collaboration-engine",children:"Real-Time Collaboration Engine"})}),"\n",(0,r.jsx)(n.p,{children:"Expert in building Google Docs-style collaborative editing with WebSockets, conflict resolution, and presence awareness."}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Use for"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Collaborative text/code editors"}),"\n",(0,r.jsx)(n.li,{children:"Shared whiteboards and design tools"}),"\n",(0,r.jsx)(n.li,{children:"Multi-user video editing timelines"}),"\n",(0,r.jsx)(n.li,{children:"Real-time data dashboards"}),"\n",(0,r.jsx)(n.li,{children:"Multiplayer game state sync"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"NOT for"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple chat applications (use basic WebSocket)"}),"\n",(0,r.jsx)(n.li,{children:"Request-response APIs (use REST/GraphQL)"}),"\n",(0,r.jsx)(n.li,{children:"Single-user applications"}),"\n",(0,r.jsx)(n.li,{children:"Read-only data streaming (use Server-Sent Events)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quick-decision-tree",children:"Quick Decision Tree"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Need real-time collaboration?\n\u251c\u2500\u2500 Text editing? \u2192 Operational Transform (OT)\n\u251c\u2500\u2500 JSON data structures? \u2192 CRDTs\n\u251c\u2500\u2500 Cursor tracking only? \u2192 Simple WebSocket + presence\n\u251c\u2500\u2500 Offline-first? \u2192 CRDTs (better offline merge)\n\u2514\u2500\u2500 No conflicts possible? \u2192 Basic broadcast\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"technology-selection",children:"Technology Selection"}),"\n",(0,r.jsx)(n.h3,{id:"conflict-resolution-strategies-2024",children:"Conflict Resolution Strategies (2024)"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Strategy"}),(0,r.jsx)(n.th,{children:"Best For"}),(0,r.jsx)(n.th,{children:"Complexity"}),(0,r.jsx)(n.th,{children:"Offline Support"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Operational Transform (OT)"}),(0,r.jsx)(n.td,{children:"Text, ordered sequences"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Limited"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"CRDTs"}),(0,r.jsx)(n.td,{children:"JSON objects, sets"}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"Excellent"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Last-Write-Wins"}),(0,r.jsx)(n.td,{children:"Simple state"}),(0,r.jsx)(n.td,{children:"Low"}),(0,r.jsx)(n.td,{children:"Basic"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Three-Way Merge"}),(0,r.jsx)(n.td,{children:"Git-style editing"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Good"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Timeline"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"2010: Google Wave uses OT"}),"\n",(0,r.jsx)(n.li,{children:"2014: Figma adopts CRDTs"}),"\n",(0,r.jsx)(n.li,{children:"2019: Yjs (CRDT library) released"}),"\n",(0,r.jsx)(n.li,{children:"2022: Automerge 2.0 (CRDT library) released"}),"\n",(0,r.jsx)(n.li,{children:"2024: PartyKit simplifies real-time infrastructure"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"common-anti-patterns",children:"Common Anti-Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"anti-pattern-1-broadcasting-every-keystroke",children:"Anti-Pattern 1: Broadcasting Every Keystroke"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Novice thinking"}),': "Send every change immediately for real-time feel"']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Network floods with tiny messages, poor performance."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Wrong approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274c Sends message on every keystroke\nfunction Editor() {\n  const handleChange = (text: string) => {\n    socket.emit('text-change', { text });  // Every keystroke!\n  };\n\n  return <textarea onChange={(e) => handleChange(e.target.value)} />;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why wrong"}),": 100 WPM typing = 500 messages/minute = network congestion."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Correct approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Batches changes every 200ms\nfunction Editor() {\n  const [pendingChanges, setPendingChanges] = useState<Change[]>([]);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (pendingChanges.length > 0) {\n        socket.emit('text-batch', { changes: pendingChanges });\n        setPendingChanges([]);\n      }\n    }, 200);\n\n    return () => clearInterval(interval);\n  }, [pendingChanges]);\n\n  const handleChange = (change: Change) => {\n    setPendingChanges(prev => [...prev, change]);\n  };\n\n  return <textarea onChange={handleChange} />;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Impact"}),": 500 messages/minute \u2192 5 messages/second (90% reduction)."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"anti-pattern-2-no-conflict-resolution-strategy",children:"Anti-Pattern 2: No Conflict Resolution Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Concurrent edits cause data loss or corruption."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Symptom"}),": Users see their changes disappear, documents become inconsistent."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Wrong approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274c Last write wins, overwrites concurrent changes\nsocket.on('text-change', ({ userId, text }) => {\n  setDocument(text);  // Loses concurrent edits!\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why wrong"}),": If User A and B edit simultaneously, one change is lost."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Correct approach (OT)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Operational Transform for text\nimport { TextOperation } from 'ot.js';\n\nsocket.on('operation', ({ userId, operation, revision }) => {\n  const transformed = transformOperation(\n    operation,\n    pendingOperations,\n    revision\n  );\n\n  applyOperation(transformed);\n  incrementRevision();\n});\n\nfunction transformOperation(\n  incoming: Operation,\n  pending: Operation[],\n  baseRevision: number\n): Operation {\n  // Transform incoming against pending operations\n  let transformed = incoming;\n  for (const op of pending) {\n    transformed = TextOperation.transform(transformed, op)[0];\n  }\n  return transformed;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Correct approach (CRDT)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 CRDT for JSON objects\nimport * as Y from 'yjs';\n\nconst ydoc = new Y.Doc();\nconst ytext = ydoc.getText('document');\n\n// Automatically handles conflicts\nytext.insert(0, 'Hello');\n\n// Sync with peers\nconst provider = new WebsocketProvider('ws://localhost:1234', 'room', ydoc);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Impact"}),": Concurrent edits merge correctly, no data loss."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"anti-pattern-3-not-handling-disconnections",children:"Anti-Pattern 3: Not Handling Disconnections"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": User goes offline, loses work or sees stale state."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Wrong approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274c No offline handling\nsocket.on('disconnect', () => {\n  console.log('Disconnected');  // That's it?!\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why wrong"}),": Pending changes lost, no reconnection strategy, bad UX."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Correct approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Queue changes offline, sync on reconnect\nconst [isOnline, setIsOnline] = useState(true);\nconst [offlineQueue, setOfflineQueue] = useState<Change[]>([]);\n\nsocket.on('disconnect', () => {\n  setIsOnline(false);\n  showToast('Offline - changes will sync when reconnected');\n});\n\nsocket.on('connect', () => {\n  setIsOnline(true);\n\n  // Send queued changes\n  if (offlineQueue.length > 0) {\n    socket.emit('sync-offline-changes', { changes: offlineQueue });\n    setOfflineQueue([]);\n  }\n});\n\nconst handleChange = (change: Change) => {\n  if (isOnline) {\n    socket.emit('change', change);\n  } else {\n    setOfflineQueue(prev => [...prev, change]);\n  }\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Timeline context"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"2015: Offline-first apps rare"}),"\n",(0,r.jsx)(n.li,{children:"2020: PWAs make offline UX standard"}),"\n",(0,r.jsx)(n.li,{children:"2024: Users expect seamless offline editing"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"anti-pattern-4-client-only-state-sync",children:"Anti-Pattern 4: Client-Only State Sync"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": No server authority, clients get out of sync."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Wrong approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274c Clients broadcast to each other directly\nsocket.on('peer-change', ({ userId, change }) => {\n  applyChange(change);  // No validation, no server state\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why wrong"}),": Malicious client can send invalid data, no recovery from desync."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Correct approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Server is source of truth\n// Client\nsocket.emit('operation', { operation, clientRevision });\n\nsocket.on('ack', ({ serverRevision }) => {\n  if (serverRevision !== expectedRevision) {\n    // Desync detected, request full state\n    socket.emit('request-full-state');\n  }\n});\n\n// Server\nio.on('connection', (socket) => {\n  socket.on('operation', ({ operation, clientRevision }) => {\n    // Validate operation\n    if (!isValid(operation)) {\n      socket.emit('error', { message: 'Invalid operation' });\n      return;\n    }\n\n    // Apply to server state\n    const serverRevision = applyOperation(operation);\n\n    // Broadcast to all clients\n    io.emit('operation', { operation, serverRevision });\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Impact"}),": Data integrity guaranteed, can recover from client bugs."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"anti-pattern-5-no-presence-awareness",children:"Anti-Pattern 5: No Presence Awareness"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Users can't see who's editing what, causing edit conflicts."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Symptom"}),": Two people editing same section unknowingly."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Wrong approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274c No awareness of other users\nfunction Editor() {\n  return <textarea />;  // Flying blind!\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Correct approach"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Show active users and cursors\nimport { usePresence } from './usePresence';\n\nfunction Editor() {\n  const { users, updateCursor } = usePresence();\n\n  const handleCursorMove = (position: number) => {\n    socket.emit('cursor-move', { userId: myId, position });\n  };\n\n  return (\n    <div>\n      {/* Show who's online */}\n      <UserList users={users} />\n\n      {/* Show remote cursors */}\n      <EditorWithCursors\n        content={content}\n        cursors={users.map(u => u.cursor)}\n        onCursorMove={handleCursorMove}\n      />\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Active user list with avatars"}),"\n",(0,r.jsx)(n.li,{children:"Cursor positions color-coded by user"}),"\n",(0,r.jsx)(n.li,{children:"Selection ranges highlighted"}),"\n",(0,r.jsx)(n.li,{children:'"User X is typing..." indicators'}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"implementation-patterns",children:"Implementation Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"pattern-1-websocket-setup-with-reconnection",children:"Pattern 1: WebSocket Setup with Reconnection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { io } from 'socket.io-client';\n\nconst socket = io('ws://localhost:3000', {\n  reconnection: true,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  reconnectionAttempts: Infinity,\n  transports: ['websocket', 'polling']  // Fallback\n});\n\nsocket.on('connect', () => {\n  console.log('Connected:', socket.id);\n});\n\nsocket.on('disconnect', (reason) => {\n  if (reason === 'io server disconnect') {\n    // Server disconnected, manually reconnect\n    socket.connect();\n  }\n});\n\nsocket.on('connect_error', (error) => {\n  console.error('Connection error:', error);\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-2-operational-transform-text",children:"Pattern 2: Operational Transform (Text)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { TextOperation } from 'ot.js';\n\nclass OTEditor {\n  private revision = 0;\n  private pendingOperations: TextOperation[] = [];\n\n  applyLocalOperation(op: TextOperation): void {\n    // Apply immediately (optimistic update)\n    this.applyToEditor(op);\n\n    // Send to server\n    this.sendOperation(op);\n\n    // Store as pending\n    this.pendingOperations.push(op);\n  }\n\n  receiveRemoteOperation(op: TextOperation, serverRevision: number): void {\n    // Transform against pending operations\n    let transformed = op;\n    for (const pending of this.pendingOperations) {\n      [transformed, pending] = TextOperation.transform(transformed, pending);\n    }\n\n    // Apply transformed operation\n    this.applyToEditor(transformed);\n    this.revision = serverRevision;\n  }\n\n  acknowledgeOperation(serverRevision: number): void {\n    // Remove acknowledged operation from pending\n    this.pendingOperations.shift();\n    this.revision = serverRevision;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-3-crdt-with-yjs",children:"Pattern 3: CRDT with Yjs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\n\n// Create shared document\nconst ydoc = new Y.Doc();\n\n// Define shared types\nconst ytext = ydoc.getText('content');\nconst ymap = ydoc.getMap('metadata');\nconst yarray = ydoc.getArray('users');\n\n// Connect to sync server\nconst provider = new WebsocketProvider(\n  'ws://localhost:1234',\n  'room-name',\n  ydoc\n);\n\n// Listen to changes\nytext.observe(event => {\n  console.log('Text changed:', event.changes);\n});\n\n// Make changes (automatically synced)\nytext.insert(0, 'Hello ');\nytext.insert(6, 'World!');\n\n// Undo/redo support\nconst undoManager = new Y.UndoManager(ytext);\nundoManager.undo();\nundoManager.redo();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-4-presence-awareness",children:"Pattern 4: Presence Awareness"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Awareness } from 'y-protocols/awareness';\n\nconst awareness = provider.awareness;\n\n// Set local state\nawareness.setLocalState({\n  user: {\n    name: 'Alice',\n    color: '#ff0000',\n    cursor: { line: 10, ch: 5 }\n  }\n});\n\n// Listen to changes\nawareness.on('change', ({ added, updated, removed }) => {\n  // Update UI with user cursors/selections\n  const states = awareness.getStates();\n  states.forEach((state, clientId) => {\n    if (clientId !== awareness.clientID) {\n      renderCursor(state.user.cursor, state.user.color);\n    }\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-5-optimistic-updates-with-rollback",children:"Pattern 5: Optimistic Updates with Rollback"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class OptimisticEditor {\n  private optimisticChanges = new Map<string, Change>();\n\n  async applyChange(change: Change): Promise<void> {\n    const changeId = generateId();\n\n    // Apply immediately (optimistic)\n    this.applyToUI(change);\n    this.optimisticChanges.set(changeId, change);\n\n    try {\n      // Send to server\n      const result = await this.sendToServer(change);\n\n      // Success - remove from optimistic\n      this.optimisticChanges.delete(changeId);\n\n    } catch (error) {\n      // Failed - rollback\n      this.rollback(changeId);\n      this.showError('Could not apply change');\n    }\n  }\n\n  private rollback(changeId: string): void {\n    const change = this.optimisticChanges.get(changeId);\n    if (change) {\n      this.revertInUI(change);\n      this.optimisticChanges.delete(changeId);\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"production-checklist",children:"Production Checklist"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u25a1 WebSocket connection with auto-reconnect\n\u25a1 Offline queue for pending changes\n\u25a1 Conflict resolution strategy (OT or CRDT)\n\u25a1 Server authority (clients can't desync)\n\u25a1 Presence awareness (cursors, active users)\n\u25a1 Optimistic updates with rollback\n\u25a1 Change batching (not per-keystroke)\n\u25a1 Message compression for large payloads\n\u25a1 Authentication and authorization\n\u25a1 Rate limiting (prevent spam)\n\u25a1 Heartbeat/ping-pong to detect dead connections\n\u25a1 Graceful degradation (falls back to polling if WebSocket fails)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-vs-avoid",children:"When to Use vs Avoid"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Scenario"}),(0,r.jsx)(n.th,{children:"Strategy"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Text editing (Google Docs)"}),(0,r.jsx)(n.td,{children:"\u2705 Operational Transform"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"JSON objects (Figma)"}),(0,r.jsx)(n.td,{children:"\u2705 CRDTs (Yjs, Automerge)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Simple cursor sharing"}),(0,r.jsx)(n.td,{children:"\u2705 Basic WebSocket + presence"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Chat messages"}),(0,r.jsx)(n.td,{children:"\u2705 Simple append-only (no OT/CRDT)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Video timeline editing"}),(0,r.jsx)(n.td,{children:"\u2705 CRDTs for timeline, OT for text"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read-only dashboards"}),(0,r.jsx)(n.td,{children:"\u274c Use Server-Sent Events instead"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"/references/ot-vs-crdt.md"})," - Deep comparison of conflict resolution strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"/references/websocket-scaling.md"})," - Scaling to millions of concurrent connections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"/references/presence-patterns.md"})," - Cursor tracking, user awareness, activity indicators"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"scripts",children:"Scripts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scripts/collaboration_tester.ts"})," - Simulate concurrent edits, test conflict resolution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scripts/latency_simulator.ts"})," - Test behavior under high latency/packet loss"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"This skill guides"}),": Real-time collaboration | WebSocket architecture | Operational Transform | CRDTs | Presence awareness | Conflict resolution"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);