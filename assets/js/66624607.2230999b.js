"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[82558],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(96540);const i={},a=r.createContext(i);function o(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:n},e.children)}},38492:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"skills/dag_convergence_monitor/index","title":"\ud83d\udce6 Dag Convergence Monitor","description":"Tracks iteration progress toward task completion goals. Monitors quality trends, detects plateauing, and recommends when to stop iterating. Activate on \'convergence tracking\', \'iteration progress\', \'quality trend\', \'stop iterating\', \'progress monitoring\'. NOT for iteration detection (use dag-iteration-detector) or feedback synthesis (use dag-feedback-synthesizer).","source":"@site/docs/skills/dag_convergence_monitor/index.md","sourceDirName":"skills/dag_convergence_monitor","slug":"/skills/dag_convergence_monitor/","permalink":"/docs/skills/dag_convergence_monitor/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Convergence Monitor","sidebar_position":1}}');var i=t(74848),a=t(28453);const o={sidebar_label:"Dag Convergence Monitor",sidebar_position:1},s="\ud83d\udce6 Dag Convergence Monitor",c={},l=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Progress Tracking",id:"1-progress-tracking",level:3},{value:"2. Trend Analysis",id:"2-trend-analysis",level:3},{value:"3. Stopping Criteria",id:"3-stopping-criteria",level:3},{value:"4. Goal Achievement Assessment",id:"4-goal-achievement-assessment",level:3},{value:"Convergence Architecture",id:"convergence-architecture",level:2},{value:"Progress Tracking",id:"progress-tracking",level:2},{value:"Trend Analysis",id:"trend-analysis",level:2},{value:"Convergence Assessment",id:"convergence-assessment",level:2},{value:"Stopping Recommendations",id:"stopping-recommendations",level:2},{value:"Convergence Report",id:"convergence-report",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"-dag-convergence-monitor",children:"\ud83d\udce6 Dag Convergence Monitor"})}),"\n",(0,i.jsx)(n.p,{children:"Tracks iteration progress toward task completion goals. Monitors quality trends, detects plateauing, and recommends when to stop iterating. Activate on 'convergence tracking', 'iteration progress', 'quality trend', 'stop iterating', 'progress monitoring'. NOT for iteration detection (use dag-iteration-detector) or feedback synthesis (use dag-feedback-synthesizer)."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"dag"})," ",(0,i.jsx)(n.code,{children:"feedback"})," ",(0,i.jsx)(n.code,{children:"convergence"})," ",(0,i.jsx)(n.code,{children:"monitoring"})," ",(0,i.jsx)(n.code,{children:"quality-trends"})]}),"\n",(0,i.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/skills/dag_iteration_detector",children:"Dag Iteration Detector"})}),": Uses iteration decisions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/skills/dag_feedback_synthesizer",children:"Dag Feedback Synthesizer"})}),": Receives feedback metrics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/skills/dag_dynamic_replanner",children:"Dag Dynamic Replanner"})}),": Informs replanning decisions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/skills/dag_pattern_learner",children:"Dag Pattern Learner"})}),": Provides convergence patterns"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"You are a DAG Convergence Monitor, an expert at tracking iteration progress toward task completion. You analyze quality trends, detect plateauing, predict convergence, and make informed recommendations about when to continue iterating versus accepting results or escalating."}),"\n",(0,i.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,i.jsx)(n.h3,{id:"1-progress-tracking",children:"1. Progress Tracking"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Monitor quality scores over iterations"}),"\n",(0,i.jsx)(n.li,{children:"Track improvement rates"}),"\n",(0,i.jsx)(n.li,{children:"Measure goal proximity"}),"\n",(0,i.jsx)(n.li,{children:"Record iteration history"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-trend-analysis",children:"2. Trend Analysis"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Detect improvement trajectories"}),"\n",(0,i.jsx)(n.li,{children:"Identify plateauing patterns"}),"\n",(0,i.jsx)(n.li,{children:"Predict future convergence"}),"\n",(0,i.jsx)(n.li,{children:"Calculate confidence in predictions"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-stopping-criteria",children:"3. Stopping Criteria"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Apply convergence thresholds"}),"\n",(0,i.jsx)(n.li,{children:"Detect diminishing returns"}),"\n",(0,i.jsx)(n.li,{children:"Enforce budget limits"}),"\n",(0,i.jsx)(n.li,{children:"Recommend optimal stopping points"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-goal-achievement-assessment",children:"4. Goal Achievement Assessment"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compare current state to goals"}),"\n",(0,i.jsx)(n.li,{children:"Identify remaining gaps"}),"\n",(0,i.jsx)(n.li,{children:"Estimate completion likelihood"}),"\n",(0,i.jsx)(n.li,{children:"Report achievement status"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"convergence-architecture",children:"Convergence Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface ConvergenceStatus {\n  taskId: string;\n  currentIteration: number;\n  analyzedAt: Date;\n  qualityHistory: QualityPoint[];\n  trend: TrendAnalysis;\n  convergence: ConvergenceAssessment;\n  recommendation: ConvergenceRecommendation;\n}\n\ninterface QualityPoint {\n  iteration: number;\n  timestamp: Date;\n  qualityScore: number;\n  confidenceScore: number;\n  validationScore: number;\n  improvementsResolved: number;\n  improvementsRemaining: number;\n}\n\ninterface TrendAnalysis {\n  direction: 'improving' | 'stable' | 'declining';\n  slope: number;           // Rate of change\n  acceleration: number;    // Change in rate\n  isPlateauing: boolean;\n  plateauStartIteration?: number;\n  predictedConvergenceIteration?: number;\n}\n\ninterface ConvergenceAssessment {\n  isConverged: boolean;\n  convergenceScore: number;  // 0-1, how close to goal\n  confidenceInConvergence: number;\n  estimatedIterationsToGoal: number;\n  goalAchievable: boolean;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"progress-tracking",children:"Progress Tracking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface ProgressTracker {\n  taskId: string;\n  goal: ConvergenceGoal;\n  history: QualityPoint[];\n  budgetUsed: IterationBudget;\n}\n\ninterface ConvergenceGoal {\n  targetQuality: number;      // Target quality score\n  acceptableQuality: number;  // Minimum acceptable\n  maxIterations: number;\n  requiredImprovements: string[];  // Must-fix items\n}\n\nfunction trackProgress(\n  tracker: ProgressTracker,\n  iterationResult: IterationResult\n): QualityPoint {\n  const point: QualityPoint = {\n    iteration: tracker.history.length + 1,\n    timestamp: new Date(),\n    qualityScore: iterationResult.qualityScore,\n    confidenceScore: iterationResult.confidence,\n    validationScore: iterationResult.validationPassed ? 1 : 0,\n    improvementsResolved: countResolved(\n      tracker.history[tracker.history.length - 1]?.improvementsRemaining ?? 0,\n      iterationResult.improvements\n    ),\n    improvementsRemaining: iterationResult.improvements.filter(\n      i => i.priority === 'critical' || i.priority === 'high'\n    ).length,\n  };\n\n  tracker.history.push(point);\n  return point;\n}\n\nfunction calculateGoalProximity(\n  current: QualityPoint,\n  goal: ConvergenceGoal\n): number {\n  const qualityProgress = current.qualityScore / goal.targetQuality;\n  const improvementProgress = 1 - (\n    current.improvementsRemaining /\n    Math.max(1, current.improvementsRemaining + current.improvementsResolved)\n  );\n\n  return Math.min(1, (qualityProgress * 0.7 + improvementProgress * 0.3));\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"trend-analysis",children:"Trend Analysis"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function analyzeTrend(history: QualityPoint[]): TrendAnalysis {\n  if (history.length < 2) {\n    return {\n      direction: 'stable',\n      slope: 0,\n      acceleration: 0,\n      isPlateauing: false,\n    };\n  }\n\n  // Calculate slope using linear regression\n  const scores = history.map(p => p.qualityScore);\n  const slope = calculateSlope(scores);\n\n  // Calculate acceleration (change in slope)\n  const recentScores = scores.slice(-3);\n  const olderScores = scores.slice(-6, -3);\n  const recentSlope = calculateSlope(recentScores);\n  const olderSlope = calculateSlope(olderScores);\n  const acceleration = recentSlope - olderSlope;\n\n  // Detect plateauing\n  const { isPlateauing, plateauStart } = detectPlateau(history);\n\n  // Predict convergence\n  const predictedIteration = predictConvergence(history, slope);\n\n  return {\n    direction: slope > 0.02 ? 'improving' :\n               slope < -0.02 ? 'declining' : 'stable',\n    slope,\n    acceleration,\n    isPlateauing,\n    plateauStartIteration: plateauStart,\n    predictedConvergenceIteration: predictedIteration,\n  };\n}\n\nfunction calculateSlope(values: number[]): number {\n  if (values.length < 2) return 0;\n\n  const n = values.length;\n  const sumX = (n * (n - 1)) / 2;\n  const sumY = values.reduce((a, b) => a + b, 0);\n  const sumXY = values.reduce((sum, y, x) => sum + x * y, 0);\n  const sumXX = (n * (n - 1) * (2 * n - 1)) / 6;\n\n  return (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n}\n\nfunction detectPlateau(history: QualityPoint[]): {\n  isPlateauing: boolean;\n  plateauStart?: number;\n} {\n  if (history.length < 3) {\n    return { isPlateauing: false };\n  }\n\n  // Check last 3 iterations for plateau\n  const recent = history.slice(-3);\n  const scores = recent.map(p => p.qualityScore);\n  const variance = calculateVariance(scores);\n\n  // Plateau if variance is very low\n  if (variance < 0.01) {\n    return {\n      isPlateauing: true,\n      plateauStart: history.length - 3,\n    };\n  }\n\n  return { isPlateauing: false };\n}\n\nfunction calculateVariance(values: number[]): number {\n  const mean = values.reduce((a, b) => a + b, 0) / values.length;\n  const squaredDiffs = values.map(v => Math.pow(v - mean, 2));\n  return squaredDiffs.reduce((a, b) => a + b, 0) / values.length;\n}\n\nfunction predictConvergence(\n  history: QualityPoint[],\n  currentSlope: number\n): number | undefined {\n  if (history.length < 2 || currentSlope <= 0) {\n    return undefined;\n  }\n\n  const currentScore = history[history.length - 1].qualityScore;\n  const targetScore = 0.85; // Acceptable threshold\n\n  if (currentScore >= targetScore) {\n    return history.length; // Already converged\n  }\n\n  const iterationsNeeded = (targetScore - currentScore) / currentSlope;\n\n  if (iterationsNeeded > 20) {\n    return undefined; // Too far to predict\n  }\n\n  return Math.ceil(history.length + iterationsNeeded);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"convergence-assessment",children:"Convergence Assessment"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function assessConvergence(\n  tracker: ProgressTracker,\n  trend: TrendAnalysis\n): ConvergenceAssessment {\n  const current = tracker.history[tracker.history.length - 1];\n  const goal = tracker.goal;\n\n  // Check if we've reached the goal\n  const meetsTarget = current.qualityScore >= goal.targetQuality;\n  const meetsAcceptable = current.qualityScore >= goal.acceptableQuality;\n  const noBlockingIssues = current.improvementsRemaining === 0;\n\n  const isConverged = meetsTarget && noBlockingIssues;\n\n  // Calculate convergence score\n  const convergenceScore = calculateGoalProximity(current, goal);\n\n  // Estimate iterations to goal\n  const estimatedIterations = trend.predictedConvergenceIteration\n    ? trend.predictedConvergenceIteration - tracker.history.length\n    : Infinity;\n\n  // Assess if goal is achievable\n  const budgetRemaining = goal.maxIterations - tracker.history.length;\n  const goalAchievable =\n    !trend.isPlateauing &&\n    trend.direction !== 'declining' &&\n    (isConverged || estimatedIterations <= budgetRemaining);\n\n  // Calculate confidence in assessment\n  const confidence = calculateConfidence(tracker.history, trend);\n\n  return {\n    isConverged,\n    convergenceScore,\n    confidenceInConvergence: confidence,\n    estimatedIterationsToGoal: estimatedIterations,\n    goalAchievable,\n  };\n}\n\nfunction calculateConfidence(\n  history: QualityPoint[],\n  trend: TrendAnalysis\n): number {\n  let confidence = 0.5; // Base confidence\n\n  // More history = more confidence\n  if (history.length >= 3) confidence += 0.1;\n  if (history.length >= 5) confidence += 0.1;\n\n  // Consistent improvement = more confidence\n  if (trend.direction === 'improving' && trend.acceleration >= 0) {\n    confidence += 0.15;\n  }\n\n  // Low variance = more confidence\n  const recentVariance = calculateVariance(\n    history.slice(-3).map(p => p.qualityScore)\n  );\n  if (recentVariance < 0.05) confidence += 0.1;\n\n  // Plateau reduces confidence in further improvement\n  if (trend.isPlateauing) confidence -= 0.2;\n\n  return Math.max(0, Math.min(1, confidence));\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"stopping-recommendations",children:"Stopping Recommendations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"type ConvergenceRecommendation =\n  | { action: 'continue'; reason: string; priority: string }\n  | { action: 'accept'; reason: string; qualityLevel: string }\n  | { action: 'escalate'; reason: string; blockers: string[] }\n  | { action: 'abort'; reason: string };\n\nfunction recommendAction(\n  tracker: ProgressTracker,\n  trend: TrendAnalysis,\n  convergence: ConvergenceAssessment\n): ConvergenceRecommendation {\n  const current = tracker.history[tracker.history.length - 1];\n  const budgetRemaining = tracker.goal.maxIterations - tracker.history.length;\n\n  // Case 1: Goal achieved\n  if (convergence.isConverged) {\n    return {\n      action: 'accept',\n      reason: 'Target quality achieved with no blocking issues',\n      qualityLevel: 'target',\n    };\n  }\n\n  // Case 2: Acceptable quality, close to budget limit\n  if (\n    current.qualityScore >= tracker.goal.acceptableQuality &&\n    budgetRemaining <= 1\n  ) {\n    return {\n      action: 'accept',\n      reason: 'Acceptable quality reached, iteration budget nearly exhausted',\n      qualityLevel: 'acceptable',\n    };\n  }\n\n  // Case 3: No budget remaining\n  if (budgetRemaining <= 0) {\n    if (current.qualityScore >= tracker.goal.acceptableQuality) {\n      return {\n        action: 'accept',\n        reason: 'Budget exhausted, quality is acceptable',\n        qualityLevel: 'acceptable',\n      };\n    }\n    return {\n      action: 'escalate',\n      reason: 'Budget exhausted without reaching acceptable quality',\n      blockers: extractBlockers(tracker),\n    };\n  }\n\n  // Case 4: Plateaued below acceptable\n  if (\n    trend.isPlateauing &&\n    current.qualityScore < tracker.goal.acceptableQuality\n  ) {\n    return {\n      action: 'escalate',\n      reason: 'Quality plateaued below acceptable threshold',\n      blockers: extractBlockers(tracker),\n    };\n  }\n\n  // Case 5: Declining quality\n  if (trend.direction === 'declining' && tracker.history.length >= 3) {\n    return {\n      action: 'escalate',\n      reason: 'Quality declining over multiple iterations',\n      blockers: ['Iterations making things worse, not better'],\n    };\n  }\n\n  // Case 6: Goal not achievable within budget\n  if (!convergence.goalAchievable) {\n    return {\n      action: 'escalate',\n      reason: 'Target quality unlikely to be achieved within remaining budget',\n      blockers: extractBlockers(tracker),\n    };\n  }\n\n  // Case 7: Continue improving\n  return {\n    action: 'continue',\n    reason: 'Progress being made, goal achievable within budget',\n    priority: current.improvementsRemaining > 0 ? 'high' : 'medium',\n  };\n}\n\nfunction extractBlockers(tracker: ProgressTracker): string[] {\n  const current = tracker.history[tracker.history.length - 1];\n  const blockers: string[] = [];\n\n  if (current.qualityScore < tracker.goal.acceptableQuality) {\n    blockers.push(`Quality score ${(current.qualityScore * 100).toFixed(0)}% below acceptable ${(tracker.goal.acceptableQuality * 100).toFixed(0)}%`);\n  }\n\n  if (current.improvementsRemaining > 0) {\n    blockers.push(`${current.improvementsRemaining} critical/high improvements unresolved`);\n  }\n\n  if (current.validationScore < 1) {\n    blockers.push('Validation still failing');\n  }\n\n  return blockers;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"convergence-report",children:"Convergence Report"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'convergenceReport:\n  taskId: code-review-task\n  currentIteration: 4\n  analyzedAt: "2024-01-15T10:45:00Z"\n\n  goal:\n    targetQuality: 0.85\n    acceptableQuality: 0.70\n    maxIterations: 5\n    requiredImprovements:\n      - "Security analysis section"\n      - "Performance metrics"\n\n  qualityHistory:\n    - iteration: 1\n      qualityScore: 0.52\n      confidenceScore: 0.55\n      improvementsRemaining: 5\n\n    - iteration: 2\n      qualityScore: 0.58\n      confidenceScore: 0.62\n      improvementsRemaining: 4\n\n    - iteration: 3\n      qualityScore: 0.68\n      confidenceScore: 0.70\n      improvementsRemaining: 2\n\n    - iteration: 4\n      qualityScore: 0.75\n      confidenceScore: 0.73\n      improvementsRemaining: 1\n\n  trend:\n    direction: improving\n    slope: 0.077\n    acceleration: 0.02\n    isPlateauing: false\n    predictedConvergenceIteration: 5\n\n  convergence:\n    isConverged: false\n    convergenceScore: 0.88\n    confidenceInConvergence: 0.72\n    estimatedIterationsToGoal: 1\n    goalAchievable: true\n\n  recommendation:\n    action: continue\n    reason: "Progress being made, target quality likely achievable in next iteration"\n    priority: high\n\n  progressVisualization: |\n    Iteration  Quality  Target\n    1          \u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591  52%\n    2          \u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591  58%\n    3          \u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591  68%\n    4          \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591  75%  \u2190 Current\n    5 (est)    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  85%  \u2190 Target\n\n  nextIterationFocus:\n    - "Resolve remaining high-priority improvement"\n    - "Improve confidence through better sourcing"\n    - "Verify all validation criteria pass"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": Iteration results from ",(0,i.jsx)(n.code,{children:"dag-iteration-detector"})," and ",(0,i.jsx)(n.code,{children:"dag-feedback-synthesizer"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": Recommendations to ",(0,i.jsx)(n.code,{children:"dag-dynamic-replanner"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"History"}),": Stores patterns for ",(0,i.jsx)(n.code,{children:"dag-pattern-learner"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Metrics"}),": Reports to ",(0,i.jsx)(n.code,{children:"dag-performance-profiler"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sufficient History"}),": Wait for 3+ iterations before trend analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Budget Awareness"}),": Always consider remaining iterations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Early Detection"}),": Catch plateaus before wasting iterations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clear Thresholds"}),": Define target and acceptable levels upfront"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Confidence Calibration"}),": Trust predictions more with more data"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Track progress. Detect plateaus. Know when to stop."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);