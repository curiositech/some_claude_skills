"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[95869],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(96540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},81178:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"skills/dag_feedback_synthesizer/index","title":"\ud83d\udce6 Dag Feedback Synthesizer","description":"Synthesizes actionable feedback from validation results, confidence scores, and iteration triggers. Creates structured improvement guidance for re-execution. Activate on \'synthesize feedback\', \'improvement suggestions\', \'actionable feedback\', \'iteration guidance\', \'feedback generation\'. NOT for iteration detection (use dag-iteration-detector) or convergence tracking (use dag-convergence-monitor).","source":"@site/docs/skills/dag_feedback_synthesizer/index.md","sourceDirName":"skills/dag_feedback_synthesizer","slug":"/skills/dag_feedback_synthesizer/","permalink":"/docs/skills/dag_feedback_synthesizer/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Feedback Synthesizer","sidebar_position":1}}');var r=i(74848),s=i(28453);const o={sidebar_label:"Dag Feedback Synthesizer",sidebar_position:1},a="\ud83d\udce6 Dag Feedback Synthesizer",c={},d=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Feedback Aggregation",id:"1-feedback-aggregation",level:3},{value:"2. Prioritization",id:"2-prioritization",level:3},{value:"3. Actionable Guidance",id:"3-actionable-guidance",level:3},{value:"4. Context Preservation",id:"4-context-preservation",level:3},{value:"Feedback Architecture",id:"feedback-architecture",level:2},{value:"Signal Collection",id:"signal-collection",level:2},{value:"Improvement Extraction",id:"improvement-extraction",level:2},{value:"Prioritization Algorithm",id:"prioritization-algorithm",level:2},{value:"Context Building",id:"context-building",level:2},{value:"Guidance Generation",id:"guidance-generation",level:2},{value:"Feedback Report",id:"feedback-report",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"-dag-feedback-synthesizer",children:"\ud83d\udce6 Dag Feedback Synthesizer"})}),"\n",(0,r.jsx)(n.p,{children:"Synthesizes actionable feedback from validation results, confidence scores, and iteration triggers. Creates structured improvement guidance for re-execution. Activate on 'synthesize feedback', 'improvement suggestions', 'actionable feedback', 'iteration guidance', 'feedback generation'. NOT for iteration detection (use dag-iteration-detector) or convergence tracking (use dag-convergence-monitor)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"dag"})," ",(0,r.jsx)(n.code,{children:"feedback"})," ",(0,r.jsx)(n.code,{children:"iteration"})," ",(0,r.jsx)(n.code,{children:"guidance"})," ",(0,r.jsx)(n.code,{children:"improvement"})]}),"\n",(0,r.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_iteration_detector",children:"Dag Iteration Detector"})}),": Receives iteration triggers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_convergence_monitor",children:"Dag Convergence Monitor"})}),": Sends feedback for tracking"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_output_validator",children:"Dag Output Validator"})}),": Uses validation results"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_confidence_scorer",children:"Dag Confidence Scorer"})}),": Uses confidence breakdown"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You are a DAG Feedback Synthesizer, an expert at creating actionable improvement guidance from quality signals. You analyze validation results, confidence breakdowns, and iteration triggers to generate structured feedback that maximizes the likelihood of successful re-execution."}),"\n",(0,r.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,r.jsx)(n.h3,{id:"1-feedback-aggregation",children:"1. Feedback Aggregation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Collect signals from validators"}),"\n",(0,r.jsx)(n.li,{children:"Gather confidence breakdowns"}),"\n",(0,r.jsx)(n.li,{children:"Process iteration triggers"}),"\n",(0,r.jsx)(n.li,{children:"Integrate user feedback"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-prioritization",children:"2. Prioritization"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rank issues by impact"}),"\n",(0,r.jsx)(n.li,{children:"Identify quick wins"}),"\n",(0,r.jsx)(n.li,{children:"Separate critical from nice-to-have"}),"\n",(0,r.jsx)(n.li,{children:"Sequence improvements logically"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-actionable-guidance",children:"3. Actionable Guidance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create specific, actionable items"}),"\n",(0,r.jsx)(n.li,{children:"Provide examples when helpful"}),"\n",(0,r.jsx)(n.li,{children:"Include success criteria"}),"\n",(0,r.jsx)(n.li,{children:"Avoid vague suggestions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-context-preservation",children:"4. Context Preservation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maintain relevant context"}),"\n",(0,r.jsx)(n.li,{children:"Track what was tried"}),"\n",(0,r.jsx)(n.li,{children:"Preserve working elements"}),"\n",(0,r.jsx)(n.li,{children:"Guide incremental improvement"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"feedback-architecture",children:"Feedback Architecture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface SynthesizedFeedback {\n  taskId: string;\n  iterationNumber: number;\n  synthesizedAt: Date;\n  summary: FeedbackSummary;\n  improvements: Improvement[];\n  context: FeedbackContext;\n  guidance: ExecutionGuidance;\n}\n\ninterface FeedbackSummary {\n  overallAssessment: 'poor' | 'needs_work' | 'close' | 'acceptable';\n  mainIssues: string[];\n  strengths: string[];\n  estimatedEffort: 'minor' | 'moderate' | 'significant';\n}\n\ninterface Improvement {\n  id: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  category: ImprovementCategory;\n  issue: string;\n  suggestion: string;\n  example?: string;\n  successCriteria: string;\n  estimatedImpact: number;  // 0-1\n}\n\ntype ImprovementCategory =\n  | 'missing_content'\n  | 'incorrect_content'\n  | 'structural'\n  | 'quality'\n  | 'formatting'\n  | 'completeness'\n  | 'accuracy'\n  | 'clarity';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"signal-collection",children:"Signal Collection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface QualitySignals {\n  validation: ValidationResult;\n  confidence: ConfidenceScore;\n  hallucination: HallucinationReport;\n  iteration: IterationDecision;\n  userFeedback?: UserFeedback;\n}\n\nfunction collectSignals(\n  taskId: string,\n  sources: SignalSources\n): QualitySignals {\n  return {\n    validation: sources.validator.getResult(taskId),\n    confidence: sources.confidenceScorer.getScore(taskId),\n    hallucination: sources.hallucinationDetector.getReport(taskId),\n    iteration: sources.iterationDetector.getDecision(taskId),\n    userFeedback: sources.userFeedback?.get(taskId),\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"improvement-extraction",children:"Improvement Extraction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function extractImprovements(signals: QualitySignals): Improvement[] {\n  const improvements: Improvement[] = [];\n\n  // From validation errors\n  for (const error of signals.validation.errors) {\n    improvements.push({\n      id: `val-${error.code}`,\n      priority: error.severity === 'critical' ? 'critical' : 'high',\n      category: categorizeValidationError(error),\n      issue: error.message,\n      suggestion: generateValidationFix(error),\n      example: generateValidationExample(error),\n      successCriteria: `Validation passes for ${error.path}`,\n      estimatedImpact: error.severity === 'critical' ? 0.9 : 0.6,\n    });\n  }\n\n  // From confidence breakdown\n  const weakFactors = Object.entries(signals.confidence.factors)\n    .filter(([_, score]) => score < 0.6)\n    .sort((a, b) => a[1] - b[1]);\n\n  for (const [factor, score] of weakFactors) {\n    improvements.push({\n      id: `conf-${factor}`,\n      priority: score < 0.4 ? 'high' : 'medium',\n      category: mapConfidenceToCategory(factor),\n      issue: `Low ${factor} score: ${(score * 100).toFixed(0)}%`,\n      suggestion: getConfidenceImprovement(factor as keyof ConfidenceFactors),\n      successCriteria: `${factor} score above 70%`,\n      estimatedImpact: 0.5,\n    });\n  }\n\n  // From hallucination findings\n  for (const finding of signals.hallucination.findings) {\n    if (finding.severity !== 'warning') {\n      improvements.push({\n        id: `hall-${finding.type}`,\n        priority: finding.severity === 'confirmed' ? 'critical' : 'high',\n        category: 'accuracy',\n        issue: `${finding.type}: \"${finding.claim}\"`,\n        suggestion: `Remove or verify: ${finding.suggestedAction}`,\n        successCriteria: 'No hallucinations detected in this area',\n        estimatedImpact: 0.8,\n      });\n    }\n  }\n\n  // From iteration triggers\n  for (const trigger of signals.iteration.triggers) {\n    if (!isDuplicateImprovement(improvements, trigger)) {\n      improvements.push({\n        id: `iter-${trigger.type}`,\n        priority: trigger.severity > 0.8 ? 'high' : 'medium',\n        category: mapTriggerToCategory(trigger.type),\n        issue: trigger.details,\n        suggestion: generateTriggerFix(trigger),\n        successCriteria: `${trigger.type} trigger resolved`,\n        estimatedImpact: trigger.severity,\n      });\n    }\n  }\n\n  // From user feedback\n  if (signals.userFeedback) {\n    improvements.push({\n      id: 'user-feedback',\n      priority: 'high',\n      category: 'quality',\n      issue: signals.userFeedback.message,\n      suggestion: parseUserFeedbackToAction(signals.userFeedback),\n      successCriteria: 'User feedback addressed',\n      estimatedImpact: 0.9,\n    });\n  }\n\n  return improvements;\n}\n\nfunction getConfidenceImprovement(factor: keyof ConfidenceFactors): string {\n  const suggestions: Record<keyof ConfidenceFactors, string> = {\n    reasoning: 'Add step-by-step reasoning, explain the logic, consider alternatives',\n    sources: 'Add citations, reference documentation, link to trusted sources',\n    consistency: 'Check for contradictions, use consistent terminology throughout',\n    completeness: 'Cover all required topics, add conclusion, meet word count',\n    uncertainty: 'Add confidence qualifiers, acknowledge limitations, note edge cases',\n  };\n  return suggestions[factor];\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"prioritization-algorithm",children:"Prioritization Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function prioritizeImprovements(\n  improvements: Improvement[],\n  budget: IterationBudget\n): Improvement[] {\n  // Score each improvement\n  const scored = improvements.map(imp => ({\n    ...imp,\n    priorityScore: calculatePriorityScore(imp),\n  }));\n\n  // Sort by priority score\n  scored.sort((a, b) => b.priorityScore - a.priorityScore);\n\n  // Apply budget constraints\n  const budgeted = applyBudgetConstraints(scored, budget);\n\n  // Ensure dependencies are respected\n  return orderByDependencies(budgeted);\n}\n\nfunction calculatePriorityScore(improvement: Improvement): number {\n  const priorityWeights: Record<Improvement['priority'], number> = {\n    critical: 1.0,\n    high: 0.75,\n    medium: 0.5,\n    low: 0.25,\n  };\n\n  const categoryWeights: Record<ImprovementCategory, number> = {\n    incorrect_content: 0.95,   // Wrong is worse than missing\n    missing_content: 0.9,\n    accuracy: 0.85,\n    structural: 0.7,\n    completeness: 0.65,\n    quality: 0.5,\n    clarity: 0.4,\n    formatting: 0.3,\n  };\n\n  return (\n    priorityWeights[improvement.priority] * 0.4 +\n    categoryWeights[improvement.category] * 0.3 +\n    improvement.estimatedImpact * 0.3\n  );\n}\n\nfunction applyBudgetConstraints(\n  improvements: Array<Improvement & { priorityScore: number }>,\n  budget: IterationBudget\n): Improvement[] {\n  // If budget is low, focus on critical only\n  if (budget.remainingIterations <= 1) {\n    return improvements.filter(i => i.priority === 'critical');\n  }\n\n  // If budget is moderate, include high priority\n  if (budget.remainingIterations <= 2) {\n    return improvements.filter(i =>\n      i.priority === 'critical' || i.priority === 'high'\n    );\n  }\n\n  // Otherwise, include based on estimated effort\n  let tokenBudget = budget.remainingTokens * 0.5; // Reserve half for execution\n  const selected: Improvement[] = [];\n\n  for (const imp of improvements) {\n    const estimatedTokens = estimateImprovementTokens(imp);\n    if (tokenBudget >= estimatedTokens) {\n      selected.push(imp);\n      tokenBudget -= estimatedTokens;\n    }\n  }\n\n  return selected;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"context-building",children:"Context Building"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FeedbackContext {\n  preserveElements: string[];     // What worked well\n  avoidElements: string[];        // What failed\n  previousAttempts: AttemptSummary[];\n  relevantExamples: string[];\n}\n\nfunction buildFeedbackContext(\n  output: TaskOutput,\n  signals: QualitySignals,\n  history: IterationHistory\n): FeedbackContext {\n  return {\n    preserveElements: identifyStrengths(output, signals),\n    avoidElements: identifyFailures(output, signals),\n    previousAttempts: summarizeHistory(history),\n    relevantExamples: findRelevantExamples(signals),\n  };\n}\n\nfunction identifyStrengths(\n  output: TaskOutput,\n  signals: QualitySignals\n): string[] {\n  const strengths: string[] = [];\n\n  // High-scoring confidence factors\n  for (const [factor, score] of Object.entries(signals.confidence.factors)) {\n    if (score >= 0.8) {\n      strengths.push(`Strong ${factor} (${(score * 100).toFixed(0)}%)`);\n    }\n  }\n\n  // Passed validations\n  if (signals.validation.valid) {\n    strengths.push('Schema validation passed');\n  }\n\n  // Specific positive aspects\n  if (signals.hallucination.overallRisk === 'low') {\n    strengths.push('Content appears factually grounded');\n  }\n\n  return strengths;\n}\n\nfunction identifyFailures(\n  output: TaskOutput,\n  signals: QualitySignals\n): string[] {\n  const failures: string[] = [];\n\n  // Validation failures\n  for (const error of signals.validation.errors) {\n    failures.push(`Failed: ${error.path} - ${error.code}`);\n  }\n\n  // Hallucinations\n  for (const finding of signals.hallucination.findings) {\n    if (finding.severity === 'confirmed') {\n      failures.push(`Hallucination: ${finding.claim}`);\n    }\n  }\n\n  return failures;\n}\n\nfunction summarizeHistory(history: IterationHistory): AttemptSummary[] {\n  return history.iterations.map(iter => ({\n    iteration: iter.number,\n    approach: iter.strategyUsed,\n    outcome: iter.succeeded ? 'improved' : 'no_improvement',\n    qualityScore: iter.qualityScore,\n    keyChanges: iter.changesApplied,\n  }));\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"guidance-generation",children:"Guidance Generation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface ExecutionGuidance {\n  systemPromptAdditions: string[];\n  focusAreas: string[];\n  avoidPatterns: string[];\n  exampleOutputs?: string[];\n  successMetrics: SuccessMetric[];\n}\n\nfunction generateExecutionGuidance(\n  improvements: Improvement[],\n  context: FeedbackContext\n): ExecutionGuidance {\n  return {\n    systemPromptAdditions: generatePromptAdditions(improvements),\n    focusAreas: extractFocusAreas(improvements),\n    avoidPatterns: [...context.avoidElements, ...extractAntiPatterns(improvements)],\n    exampleOutputs: context.relevantExamples,\n    successMetrics: improvements.map(i => ({\n      metric: i.successCriteria,\n      weight: i.estimatedImpact,\n    })),\n  };\n}\n\nfunction generatePromptAdditions(improvements: Improvement[]): string[] {\n  const additions: string[] = [];\n\n  // Group by category\n  const byCategory = groupBy(improvements, 'category');\n\n  for (const [category, items] of Object.entries(byCategory)) {\n    const categoryGuidance = generateCategoryGuidance(category, items);\n    additions.push(categoryGuidance);\n  }\n\n  return additions;\n}\n\nfunction generateCategoryGuidance(\n  category: ImprovementCategory,\n  improvements: Improvement[]\n): string {\n  const templates: Record<ImprovementCategory, (items: Improvement[]) => string> = {\n    missing_content: (items) =>\n      `MUST INCLUDE: ${items.map(i => i.suggestion).join(', ')}`,\n    incorrect_content: (items) =>\n      `FIX THESE ERRORS: ${items.map(i => `${i.issue} \u2192 ${i.suggestion}`).join('; ')}`,\n    structural: (items) =>\n      `STRUCTURE REQUIREMENTS: ${items.map(i => i.suggestion).join(', ')}`,\n    quality: (items) =>\n      `QUALITY IMPROVEMENTS: ${items.map(i => i.suggestion).join(', ')}`,\n    formatting: (items) =>\n      `FORMATTING: ${items.map(i => i.suggestion).join(', ')}`,\n    completeness: (items) =>\n      `COMPLETE THESE: ${items.map(i => i.suggestion).join(', ')}`,\n    accuracy: (items) =>\n      `VERIFY ACCURACY: ${items.map(i => i.suggestion).join(', ')}`,\n    clarity: (items) =>\n      `CLARIFY: ${items.map(i => i.suggestion).join(', ')}`,\n  };\n\n  return templates[category](improvements);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"feedback-report",children:"Feedback Report"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'feedbackReport:\n  taskId: code-review-task\n  iterationNumber: 2\n  synthesizedAt: "2024-01-15T10:30:00Z"\n\n  summary:\n    overallAssessment: needs_work\n    mainIssues:\n      - "Missing security analysis section"\n      - "Low source citation score"\n      - "Incomplete performance coverage"\n    strengths:\n      - "Good reasoning structure"\n      - "Consistent terminology"\n    estimatedEffort: moderate\n\n  improvements:\n    - id: val-REQUIRED_FIELD_MISSING\n      priority: critical\n      category: missing_content\n      issue: "Required field \'security\' is missing"\n      suggestion: "Add a security analysis section covering authentication, authorization, and data validation"\n      example: |\n        ## Security Analysis\n        - **Authentication**: JWT-based, properly validated\n        - **Authorization**: Role-based access control\n        - **Data Validation**: Input sanitization on all endpoints\n      successCriteria: "Validation passes for $.analysis.security"\n      estimatedImpact: 0.9\n\n    - id: conf-sources\n      priority: high\n      category: accuracy\n      issue: "Low sources score: 45%"\n      suggestion: "Add citations, reference documentation, link to trusted sources"\n      successCriteria: "Sources score above 70%"\n      estimatedImpact: 0.5\n\n    - id: iter-requirement_unmet\n      priority: high\n      category: completeness\n      issue: "Requirement not met: Must include performance analysis"\n      suggestion: "Add performance metrics including time complexity and space complexity"\n      successCriteria: "Performance analysis requirement satisfied"\n      estimatedImpact: 0.6\n\n  context:\n    preserveElements:\n      - "Strong reasoning (78%)"\n      - "Good consistency (85%)"\n    avoidElements:\n      - "Generic security advice without specifics"\n      - "Performance claims without metrics"\n    previousAttempts:\n      - iteration: 1\n        approach: retry\n        outcome: no_improvement\n        qualityScore: 0.58\n\n  guidance:\n    systemPromptAdditions:\n      - "MUST INCLUDE: security analysis section, performance metrics"\n      - "VERIFY ACCURACY: All claims should have supporting evidence"\n    focusAreas:\n      - "Security analysis with specific findings"\n      - "Performance metrics with complexity analysis"\n      - "Citation of sources for all claims"\n    avoidPatterns:\n      - "Generic security advice without specifics"\n      - "Unsupported performance claims"\n    successMetrics:\n      - metric: "Validation passes for $.analysis.security"\n        weight: 0.9\n      - metric: "Sources score above 70%"\n        weight: 0.5\n      - metric: "Performance analysis requirement satisfied"\n        weight: 0.6\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input"}),": Signals from ",(0,r.jsx)(n.code,{children:"dag-output-validator"}),", ",(0,r.jsx)(n.code,{children:"dag-confidence-scorer"}),", ",(0,r.jsx)(n.code,{children:"dag-hallucination-detector"}),", ",(0,r.jsx)(n.code,{children:"dag-iteration-detector"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output"}),": Synthesized feedback to ",(0,r.jsx)(n.code,{children:"dag-dynamic-replanner"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tracking"}),": Progress metrics to ",(0,r.jsx)(n.code,{children:"dag-convergence-monitor"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learning"}),": Patterns to ",(0,r.jsx)(n.code,{children:"dag-pattern-learner"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Be Specific"}),": Vague feedback doesn't help"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prioritize Ruthlessly"}),": Focus on high-impact fixes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Preserve Success"}),": Don't break what's working"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learn from History"}),": Avoid repeating failed approaches"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set Clear Criteria"}),": Define what success looks like"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Actionable feedback. Prioritized improvements. Clear path forward."})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);