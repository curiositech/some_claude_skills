"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[12958],{28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(96540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},97321:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"skills/dag_scope_enforcer/index","title":"\ud83d\udce6 Dag Scope Enforcer","description":"Runtime enforcement of file system boundaries and tool access restrictions. Blocks unauthorized operations and logs violations. Activate on \'enforce scope\', \'access control\', \'boundary enforcement\', \'tool restrictions\', \'runtime security\'. NOT for validation (use dag-permission-validator) or isolation management (use dag-isolation-manager).","source":"@site/docs/skills/dag_scope_enforcer/index.md","sourceDirName":"skills/dag_scope_enforcer","slug":"/skills/dag_scope_enforcer/","permalink":"/docs/skills/dag_scope_enforcer/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Scope Enforcer","sidebar_position":1}}');var r=o(74848),i=o(28453);const s={sidebar_label:"Dag Scope Enforcer",sidebar_position:1},a="\ud83d\udce6 Dag Scope Enforcer",l={},c=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Tool Access Control",id:"1-tool-access-control",level:3},{value:"2. File System Enforcement",id:"2-file-system-enforcement",level:3},{value:"3. Network Enforcement",id:"3-network-enforcement",level:3},{value:"4. Violation Handling",id:"4-violation-handling",level:3},{value:"Enforcement Architecture",id:"enforcement-architecture",level:2},{value:"Tool Enforcement",id:"tool-enforcement",level:2},{value:"File System Enforcement",id:"file-system-enforcement",level:2},{value:"Bash Enforcement",id:"bash-enforcement",level:2},{value:"Network Enforcement",id:"network-enforcement",level:2},{value:"Violation Handling",id:"violation-handling",level:2},{value:"Enforcement Middleware",id:"enforcement-middleware",level:2},{value:"Enforcement Report",id:"enforcement-report",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"-dag-scope-enforcer",children:"\ud83d\udce6 Dag Scope Enforcer"})}),"\n",(0,r.jsx)(n.p,{children:"Runtime enforcement of file system boundaries and tool access restrictions. Blocks unauthorized operations and logs violations. Activate on 'enforce scope', 'access control', 'boundary enforcement', 'tool restrictions', 'runtime security'. NOT for validation (use dag-permission-validator) or isolation management (use dag-isolation-manager)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"dag"})," ",(0,r.jsx)(n.code,{children:"permissions"})," ",(0,r.jsx)(n.code,{children:"enforcement"})," ",(0,r.jsx)(n.code,{children:"security"})," ",(0,r.jsx)(n.code,{children:"runtime"})]}),"\n",(0,r.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_permission_validator",children:"Dag Permission Validator"})}),": Enforces validated permissions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_isolation_manager",children:"Dag Isolation Manager"})}),": Works with isolation boundaries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_execution_tracer",children:"Dag Execution Tracer"})}),": Reports violations for tracing"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You are a DAG Scope Enforcer, responsible for runtime enforcement of permission boundaries. You intercept tool calls and file operations, verify they comply with the agent's permission matrix, block unauthorized operations, and log all access attempts."}),"\n",(0,r.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,r.jsx)(n.h3,{id:"1-tool-access-control",children:"1. Tool Access Control"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Intercept tool invocations"}),"\n",(0,r.jsx)(n.li,{children:"Verify tool is in allowed list"}),"\n",(0,r.jsx)(n.li,{children:"Block unauthorized tool usage"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-file-system-enforcement",children:"2. File System Enforcement"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check file paths against patterns"}),"\n",(0,r.jsx)(n.li,{children:"Enforce read/write boundaries"}),"\n",(0,r.jsx)(n.li,{children:"Block access to denied paths"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-network-enforcement",children:"3. Network Enforcement"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verify domain access permissions"}),"\n",(0,r.jsx)(n.li,{children:"Block unauthorized network requests"}),"\n",(0,r.jsx)(n.li,{children:"Enforce protocol restrictions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-violation-handling",children:"4. Violation Handling"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Log all violation attempts"}),"\n",(0,r.jsx)(n.li,{children:"Block unauthorized operations"}),"\n",(0,r.jsx)(n.li,{children:"Report violations to tracer"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"enforcement-architecture",children:"Enforcement Architecture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface EnforcementContext {\n  agentId: string;\n  permissions: PermissionMatrix;\n  violations: ViolationRecord[];\n  enforceMode: 'strict' | 'permissive' | 'audit';\n}\n\ninterface ViolationRecord {\n  timestamp: Date;\n  agentId: string;\n  category: 'tool' | 'file' | 'bash' | 'network' | 'mcp';\n  operation: string;\n  target: string;\n  blocked: boolean;\n  message: string;\n}\n\ninterface EnforcementResult {\n  allowed: boolean;\n  violation?: ViolationRecord;\n  reason?: string;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tool-enforcement",children:"Tool Enforcement"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function enforceToolAccess(\n  tool: string,\n  context: EnforcementContext\n): EnforcementResult {\n  const { permissions, enforceMode } = context;\n\n  // Check core tools\n  if (tool in permissions.coreTools) {\n    const allowed = permissions.coreTools[tool as keyof typeof permissions.coreTools];\n    if (!allowed) {\n      return createViolation(context, 'tool', 'invoke', tool, `Tool '${tool}' not permitted`);\n    }\n    return { allowed: true };\n  }\n\n  // Check MCP tools\n  if (tool.includes(':')) {\n    return enforceMcpTool(tool, context);\n  }\n\n  // Unknown tool - block in strict mode\n  if (enforceMode === 'strict') {\n    return createViolation(context, 'tool', 'invoke', tool, `Unknown tool '${tool}'`);\n  }\n\n  return { allowed: true };\n}\n\nfunction enforceMcpTool(\n  tool: string,\n  context: EnforcementContext\n): EnforcementResult {\n  const { permissions } = context;\n  const [server, toolName] = tool.split(':');\n\n  // Check denied list first (takes precedence)\n  if (permissions.mcpTools.denied.includes(tool) ||\n      permissions.mcpTools.denied.includes(`${server}:*`)) {\n    return createViolation(context, 'mcp', 'invoke', tool, `MCP tool '${tool}' is denied`);\n  }\n\n  // Check allowed list\n  if (permissions.mcpTools.allowed.includes(tool) ||\n      permissions.mcpTools.allowed.includes(`${server}:*`) ||\n      permissions.mcpTools.allowed.includes('*:*')) {\n    return { allowed: true };\n  }\n\n  return createViolation(context, 'mcp', 'invoke', tool, `MCP tool '${tool}' not in allowed list`);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"file-system-enforcement",children:"File System Enforcement"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function enforceFileAccess(\n  operation: 'read' | 'write' | 'delete',\n  path: string,\n  context: EnforcementContext\n): EnforcementResult {\n  const { permissions } = context;\n  const normalizedPath = normalizePath(path);\n\n  // Check deny patterns first (always takes precedence)\n  for (const pattern of permissions.fileSystem.denyPatterns) {\n    if (matchesGlob(normalizedPath, pattern)) {\n      return createViolation(\n        context,\n        'file',\n        operation,\n        path,\n        `Path '${path}' matches deny pattern '${pattern}'`\n      );\n    }\n  }\n\n  // Check operation-specific patterns\n  const patterns = operation === 'read'\n    ? permissions.fileSystem.readPatterns\n    : permissions.fileSystem.writePatterns;\n\n  for (const pattern of patterns) {\n    if (matchesGlob(normalizedPath, pattern)) {\n      return { allowed: true };\n    }\n  }\n\n  return createViolation(\n    context,\n    'file',\n    operation,\n    path,\n    `Path '${path}' not covered by any ${operation} pattern`\n  );\n}\n\nfunction matchesGlob(path: string, pattern: string): boolean {\n  // Convert glob to regex\n  const regexPattern = pattern\n    .replace(/\\*\\*/g, '<<<DOUBLESTAR>>>')\n    .replace(/\\*/g, '[^/]*')\n    .replace(/<<<DOUBLESTAR>>>/g, '.*')\n    .replace(/\\?/g, '.');\n\n  const regex = new RegExp(`^${regexPattern}$`);\n  return regex.test(path);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"bash-enforcement",children:"Bash Enforcement"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function enforceBashCommand(\n  command: string,\n  context: EnforcementContext\n): EnforcementResult {\n  const { permissions } = context;\n\n  // Check if bash is enabled\n  if (!permissions.bash.enabled) {\n    return createViolation(context, 'bash', 'execute', command, 'Bash access not permitted');\n  }\n\n  // Check denied patterns first\n  for (const pattern of permissions.bash.deniedPatterns) {\n    if (new RegExp(pattern).test(command)) {\n      return createViolation(\n        context,\n        'bash',\n        'execute',\n        command,\n        `Command matches denied pattern '${pattern}'`\n      );\n    }\n  }\n\n  // Check allowed patterns\n  const matchesAllowed = permissions.bash.allowedPatterns.some(pattern =>\n    new RegExp(pattern).test(command)\n  );\n\n  if (!matchesAllowed) {\n    return createViolation(\n      context,\n      'bash',\n      'execute',\n      command,\n      'Command not covered by any allowed pattern'\n    );\n  }\n\n  return { allowed: true };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"network-enforcement",children:"Network Enforcement"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function enforceNetworkAccess(\n  url: string,\n  context: EnforcementContext\n): EnforcementResult {\n  const { permissions } = context;\n\n  if (!permissions.network.enabled) {\n    return createViolation(context, 'network', 'fetch', url, 'Network access not permitted');\n  }\n\n  const domain = extractDomain(url);\n\n  // Check denied domains\n  if (permissions.network.denyDomains.some(d => domainMatches(domain, d))) {\n    return createViolation(context, 'network', 'fetch', url, `Domain '${domain}' is denied`);\n  }\n\n  // Check allowed domains\n  const allowed = permissions.network.allowedDomains.some(d =>\n    d === '*' || domainMatches(domain, d)\n  );\n\n  if (!allowed) {\n    return createViolation(\n      context,\n      'network',\n      'fetch',\n      url,\n      `Domain '${domain}' not in allowed list`\n    );\n  }\n\n  return { allowed: true };\n}\n\nfunction domainMatches(domain: string, pattern: string): boolean {\n  if (pattern === domain) return true;\n  if (pattern.startsWith('*.')) {\n    const baseDomain = pattern.slice(2);\n    return domain === baseDomain || domain.endsWith(`.${baseDomain}`);\n  }\n  return false;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"violation-handling",children:"Violation Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function createViolation(\n  context: EnforcementContext,\n  category: ViolationRecord['category'],\n  operation: string,\n  target: string,\n  message: string\n): EnforcementResult {\n  const violation: ViolationRecord = {\n    timestamp: new Date(),\n    agentId: context.agentId,\n    category,\n    operation,\n    target,\n    blocked: context.enforceMode !== 'audit',\n    message,\n  };\n\n  // Record violation\n  context.violations.push(violation);\n\n  // Log to execution tracer\n  logViolation(violation);\n\n  // In audit mode, allow but flag\n  if (context.enforceMode === 'audit') {\n    return {\n      allowed: true,\n      violation,\n      reason: `[AUDIT] ${message}`,\n    };\n  }\n\n  return {\n    allowed: false,\n    violation,\n    reason: message,\n  };\n}\n\nfunction logViolation(violation: ViolationRecord): void {\n  const severity = violation.blocked ? 'ERROR' : 'WARN';\n  console.log(\n    `[${severity}] Scope Violation: ${violation.category}/${violation.operation} ` +\n    `on '${violation.target}' by ${violation.agentId}: ${violation.message}`\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"enforcement-middleware",children:"Enforcement Middleware"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface EnforcementMiddleware {\n  beforeTool(tool: string, args: unknown): EnforcementResult;\n  beforeFileRead(path: string): EnforcementResult;\n  beforeFileWrite(path: string): EnforcementResult;\n  beforeBash(command: string): EnforcementResult;\n  beforeNetwork(url: string): EnforcementResult;\n}\n\nfunction createEnforcementMiddleware(\n  context: EnforcementContext\n): EnforcementMiddleware {\n  return {\n    beforeTool: (tool) => enforceToolAccess(tool, context),\n    beforeFileRead: (path) => enforceFileAccess('read', path, context),\n    beforeFileWrite: (path) => enforceFileAccess('write', path, context),\n    beforeBash: (command) => enforceBashCommand(command, context),\n    beforeNetwork: (url) => enforceNetworkAccess(url, context),\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"enforcement-report",children:"Enforcement Report"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'enforcementReport:\n  agentId: web-researcher\n  sessionStart: "2024-01-15T10:00:00Z"\n  sessionEnd: "2024-01-15T10:05:00Z"\n  enforceMode: strict\n\n  summary:\n    totalOperations: 45\n    allowedOperations: 42\n    blockedOperations: 3\n\n  violations:\n    - timestamp: "2024-01-15T10:02:15Z"\n      category: file\n      operation: write\n      target: "/etc/passwd"\n      blocked: true\n      message: "Path \'/etc/passwd\' matches deny pattern \'/etc/**\'"\n\n    - timestamp: "2024-01-15T10:03:22Z"\n      category: network\n      operation: fetch\n      target: "https://malicious-site.com/api"\n      blocked: true\n      message: "Domain \'malicious-site.com\' not in allowed list"\n\n    - timestamp: "2024-01-15T10:04:01Z"\n      category: bash\n      operation: execute\n      target: "rm -rf /"\n      blocked: true\n      message: "Command matches denied pattern \'rm\\\\s+-rf\'"\n\n  accessLog:\n    - timestamp: "2024-01-15T10:01:00Z"\n      category: file\n      operation: read\n      target: "/project/src/main.ts"\n      allowed: true\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input"}),": Permission matrix from ",(0,r.jsx)(n.code,{children:"dag-permission-validator"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output"}),": Violations to ",(0,r.jsx)(n.code,{children:"dag-execution-tracer"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Coordination"}),": With ",(0,r.jsx)(n.code,{children:"dag-isolation-manager"})," for isolation levels"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logging"}),": All operations logged for auditing"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fail Closed"}),": Block by default, allow explicitly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check Early"}),": Enforce before operation executes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Log Everything"}),": Audit trail for all access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deny First"}),": Check deny lists before allow lists"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Normalize Paths"}),": Prevent bypass via path tricks"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Runtime protection. Every operation checked. No unauthorized access."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);