"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[35107],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(96540);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}},43378:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"skills/color_theory_palette_harmony_expert/references/temperature-classification","title":"Warm/Cool Temperature Classification","description":"Problem","source":"@site/docs/skills/color_theory_palette_harmony_expert/references/temperature-classification.md","sourceDirName":"skills/color_theory_palette_harmony_expert/references","slug":"/skills/color_theory_palette_harmony_expert/references/temperature-classification","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/temperature-classification","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Warm/Cool Temperature Classification","sidebar_label":"Warm/Cool Temperature Class...","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Perceptual Color Spaces","permalink":"/docs/skills/color_theory_palette_harmony_expert/references/perceptual-color-spaces"},"next":{"title":"Drone Cv Expert","permalink":"/docs/skills/drone_cv_expert/"}}');var r=n(74848),s=n(28453);const a={title:"Warm/Cool Temperature Classification",sidebar_label:"Warm/Cool Temperature Class...",sidebar_position:6},i="Warm/Cool Temperature Classification",l={},h=[{value:"Problem",id:"problem",level:2},{value:"LCH Hue Angle Approach",id:"lch-hue-angle-approach",level:2},{value:"LAB b-axis Approach",id:"lab-b-axis-approach",level:2},{value:"Hue-Sorted Photo Sequences",id:"hue-sorted-photo-sequences",level:2},{value:"Algorithm",id:"algorithm",level:3},{value:"Circular Hue Handling",id:"circular-hue-handling",level:3},{value:"Warm/Cool Alternation Pattern",id:"warmcool-alternation-pattern",level:2},{value:"Algorithm",id:"algorithm-1",level:3},{value:"Gradual Temperature Progression",id:"gradual-temperature-progression",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Issue: Warm/cool classification fails for sunset photos",id:"issue-warmcool-classification-fails-for-sunset-photos",level:3},{value:"Issue: Hue-sorted sequence has jarring transitions",id:"issue-hue-sorted-sequence-has-jarring-transitions",level:3}];function p(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"warmcool-temperature-classification",children:"Warm/Cool Temperature Classification"})}),"\n",(0,r.jsx)(t.h2,{id:"problem",children:"Problem"}),"\n",(0,r.jsx)(t.p,{children:"Given a photo, classify its dominant temperature as warm, cool, or neutral."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lch-hue-angle-approach",children:"LCH Hue Angle Approach"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def classify_temperature(palette_LCH):\n    """\n    Classify palette as warm, cool, or neutral.\n\n    Args:\n        palette_LCH: List of (L, C, H, weight) tuples\n\n    Returns:\n        str: "warm", "cool", or "neutral"\n        float: Temperature score (-1 = cool, +1 = warm)\n    """\n    warm_score = 0.0\n    cool_score = 0.0\n\n    for L, C, H, weight in palette_LCH:\n        # Chroma weighting: More saturated colors contribute more\n        chroma_weight = C / 100.0\n        effective_weight = weight * chroma_weight\n\n        # Warm hues: Red (0-30\xb0), Orange (30-60\xb0), Yellow (60-90\xb0)\n        if 0 <= H < 90:\n            warm_score += effective_weight\n\n        # Cool hues: Green (120-180\xb0), Cyan (180-210\xb0), Blue (210-270\xb0)\n        elif 120 <= H < 270:\n            cool_score += effective_weight\n\n        # Transitional: Yellow-Green (90-120\xb0), Purple (270-330\xb0)\n        # Count as half warm, half cool\n        elif 90 <= H < 120:\n            warm_score += effective_weight * 0.3\n            cool_score += effective_weight * 0.7\n        elif 270 <= H < 330:\n            warm_score += effective_weight * 0.5\n            cool_score += effective_weight * 0.5\n\n        # Magenta (330-360\xb0): Warm\n        else:\n            warm_score += effective_weight\n\n    # Normalize\n    total = warm_score + cool_score\n    if total < 0.1:\n        return "neutral", 0.0\n\n    temperature = (warm_score - cool_score) / total\n\n    if temperature > 0.3:\n        return "warm", temperature\n    elif temperature < -0.3:\n        return "cool", temperature\n    else:\n        return "neutral", temperature\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lab-b-axis-approach",children:"LAB b-axis Approach"}),"\n",(0,r.jsx)(t.p,{children:"Use LAB b-axis as temperature proxy (more robust for low-chroma colors):"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"b > 20: Warm (yellow-biased)\nb < -20: Cool (blue-biased)\n-20 \u2264 b \u2264 20: Neutral\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Weighted Temperature Score:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def temperature_score_LAB(palette_LAB):\n    """\n    Compute temperature using LAB b-axis.\n\n    More robust than hue-based for low-chroma colors.\n    """\n    total_weight = sum(w for c, w in palette_LAB)\n    weighted_b = sum(c[2] * w for c, w in palette_LAB) / total_weight\n\n    # Normalize to [-1, 1]\n    # Typical b range: [-128, 128]\n    return np.clip(weighted_b / 64, -1.0, 1.0)\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"hue-sorted-photo-sequences",children:"Hue-Sorted Photo Sequences"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Goal:"})," Arrange photos in hue order to create rainbow gradients or smooth color transitions."]}),"\n",(0,r.jsx)(t.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def sort_photos_by_hue(photos_with_palettes):\n    """\n    Sort photos by dominant hue for rainbow effect.\n\n    Args:\n        photos_with_palettes: [(photo_id, palette_LCH), ...]\n\n    Returns:\n        List of photo_ids in hue-sorted order\n    """\n    def dominant_hue(palette_LCH):\n        # Weight by chroma * weight (ignore low-saturation colors)\n        weighted_hues = []\n        for L, C, H, weight in palette_LCH:\n            if C > 10:  # Ignore near-neutral colors\n                weighted_hues.append((H, C * weight))\n\n        if not weighted_hues:\n            return 0.0  # Default for neutral images\n\n        # Circular mean of hue (handles 359\xb0 + 1\xb0 = 0\xb0 correctly)\n        sin_sum = sum(w * np.sin(np.radians(h)) for h, w in weighted_hues)\n        cos_sum = sum(w * np.cos(np.radians(h)) for h, w in weighted_hues)\n\n        mean_hue = np.degrees(np.arctan2(sin_sum, cos_sum)) % 360\n        return mean_hue\n\n    # Compute dominant hue for each photo\n    photo_hues = [(photo_id, dominant_hue(palette))\n                  for photo_id, palette in photos_with_palettes]\n\n    # Sort by hue\n    photo_hues.sort(key=lambda x: x[1])\n\n    return [photo_id for photo_id, hue in photo_hues]\n'})}),"\n",(0,r.jsx)(t.h3,{id:"circular-hue-handling",children:"Circular Hue Handling"}),"\n",(0,r.jsx)(t.p,{children:"Hue is circular (0\xb0 = 360\xb0 = red). Sorting na\xefvely by angle breaks at the red boundary."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Solution:"})," Choose rotation that minimizes total angular difference:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def optimize_hue_rotation(hues):\n    """\n    Find rotation that minimizes sum of adjacent hue differences.\n\n    This ensures smooth transitions across the red boundary.\n    """\n    best_rotation = 0\n    min_total_diff = float(\'inf\')\n\n    # Try 36 rotations (every 10 degrees)\n    for rotation in range(0, 360, 10):\n        rotated_hues = [(h + rotation) % 360 for h in hues]\n        rotated_hues.sort()\n\n        # Compute total adjacent difference\n        total_diff = sum(abs(rotated_hues[i+1] - rotated_hues[i])\n                        for i in range(len(rotated_hues) - 1))\n\n        # Add wrap-around difference\n        total_diff += min(\n            abs(rotated_hues[0] - rotated_hues[-1]),\n            360 - abs(rotated_hues[0] - rotated_hues[-1])\n        )\n\n        if total_diff < min_total_diff:\n            min_total_diff = total_diff\n            best_rotation = rotation\n\n    # Apply best rotation\n    return [(h + best_rotation) % 360 for h in hues]\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"warmcool-alternation-pattern",children:"Warm/Cool Alternation Pattern"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Design Pattern:"})," Alternate warm and cool photos for visual rhythm and contrast."]}),"\n",(0,r.jsx)(t.h3,{id:"algorithm-1",children:"Algorithm"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def arrange_warm_cool_alternation(photos_with_palettes):\n    """\n    Arrange photos in alternating warm/cool pattern.\n\n    Creates visual rhythm and prevents color monotony.\n\n    Args:\n        photos_with_palettes: [(photo_id, palette_LAB), ...]\n\n    Returns:\n        List of photo_ids in alternating order\n    """\n    # Classify each photo\n    photos_classified = []\n    for photo_id, palette in photos_with_palettes:\n        temp_type, temp_score = classify_temperature(palette)\n        photos_classified.append((photo_id, temp_type, temp_score))\n\n    # Separate into warm, cool, neutral\n    warm_photos = [(pid, score) for pid, t, score in photos_classified if t == "warm"]\n    cool_photos = [(pid, score) for pid, t, score in photos_classified if t == "cool"]\n    neutral_photos = [(pid, score) for pid, t, score in photos_classified if t == "neutral"]\n\n    # Sort by temperature intensity (most extreme first)\n    warm_photos.sort(key=lambda x: -x[1])  # Descending\n    cool_photos.sort(key=lambda x: x[1])   # Ascending (most negative first)\n\n    # Alternate warm and cool\n    result = []\n    while warm_photos or cool_photos:\n        if warm_photos:\n            result.append(warm_photos.pop(0)[0])\n        if cool_photos:\n            result.append(cool_photos.pop(0)[0])\n\n    # Intersperse neutrals evenly\n    if neutral_photos:\n        step = len(result) / (len(neutral_photos) + 1)\n        for i, (pid, _) in enumerate(neutral_photos):\n            insert_pos = int((i + 1) * step)\n            result.insert(insert_pos, pid)\n\n    return result\n'})}),"\n",(0,r.jsx)(t.h3,{id:"gradual-temperature-progression",children:"Gradual Temperature Progression"}),"\n",(0,r.jsx)(t.p,{children:"Instead of strict alternation, create smooth warm \u2192 cool \u2192 warm waves:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def temperature_wave_pattern(photos, wave_length=5):\n    """\n    Arrange photos in sinusoidal warm/cool pattern.\n\n    Args:\n        photos: [(photo_id, temperature_score), ...]\n        wave_length: Period of temperature oscillation\n\n    Returns:\n        List of photo_ids\n    """\n    # Sort by temperature\n    photos.sort(key=lambda x: x[1])\n\n    # Assign target temperature based on sine wave\n    n = len(photos)\n    target_temps = [np.sin(2 * np.pi * i / wave_length) for i in range(n)]\n\n    # Match photos to target temperatures (greedy assignment)\n    result = []\n    used = set()\n\n    for target in target_temps:\n        # Find unused photo closest to target\n        best_photo = None\n        best_diff = float(\'inf\')\n\n        for photo_id, temp_score in photos:\n            if photo_id not in used:\n                diff = abs(temp_score - target)\n                if diff < best_diff:\n                    best_diff = diff\n                    best_photo = photo_id\n\n        if best_photo:\n            result.append(best_photo)\n            used.add(best_photo)\n\n    return result\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(t.h3,{id:"issue-warmcool-classification-fails-for-sunset-photos",children:"Issue: Warm/cool classification fails for sunset photos"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Solution:"})," Use both hue angle and LAB b-axis, combine:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"temp_score = 0.5 * hue_based_temp(palette) + 0.5 * b_axis_temp(palette)\n"})}),"\n",(0,r.jsx)(t.h3,{id:"issue-hue-sorted-sequence-has-jarring-transitions",children:"Issue: Hue-sorted sequence has jarring transitions"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Solution:"})," Apply hue rotation optimization to minimize angular jumps."]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);