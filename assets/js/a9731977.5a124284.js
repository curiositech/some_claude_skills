"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[85451],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(96540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},47099:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"skills/bot_developer/references/platform-templates","title":"Platform Templates","description":"Production templates for Discord and Telegram bots.","source":"@site/docs/skills/bot_developer/references/platform-templates.md","sourceDirName":"skills/bot_developer/references","slug":"/skills/bot_developer/references/platform-templates","permalink":"/docs/skills/bot_developer/references/platform-templates","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Platform Templates","sidebar_label":"Platform Templates","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Moderation System","permalink":"/docs/skills/bot_developer/references/moderation-system"},"next":{"title":"Rate Limiting (Production-G...","permalink":"/docs/skills/bot_developer/references/rate-limiting"}}');var o=t(74848),r=t(28453);const i={title:"Platform Templates",sidebar_label:"Platform Templates",sidebar_position:3},a="Platform Templates",l={},d=[{value:"Discord.py Production Template",id:"discordpy-production-template",level:2},{value:"Telegram Bot with Webhooks",id:"telegram-bot-with-webhooks",level:2},{value:"Security Checklist",id:"security-checklist",level:2},{value:"Platform Comparison",id:"platform-comparison",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"platform-templates",children:"Platform Templates"})}),"\n",(0,o.jsx)(n.p,{children:"Production templates for Discord and Telegram bots."}),"\n",(0,o.jsx)(n.h2,{id:"discordpy-production-template",children:"Discord.py Production Template"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import discord\nfrom discord import app_commands\nfrom discord.ext import commands, tasks\nimport asyncpg\nimport redis.asyncio as redis\nimport logging\nimport sys\nfrom typing import Optional\n\n# Proper logging setup\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\'%(asctime)s | %(levelname)s | %(name)s | %(message)s\',\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        logging.FileHandler(\'bot.log\')\n    ]\n)\nlogger = logging.getLogger(\'bot\')\n\nclass ProductionBot(commands.Bot):\n    """Production-ready Discord bot with proper resource management."""\n\n    def __init__(self):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        intents.members = True\n\n        super().__init__(\n            command_prefix=commands.when_mentioned_or(\'!\'),\n            intents=intents,\n            activity=discord.Activity(\n                type=discord.ActivityType.watching,\n                name="for /help"\n            )\n        )\n\n        self.db: Optional[asyncpg.Pool] = None\n        self.redis: Optional[redis.Redis] = None\n\n    async def setup_hook(self) -> None:\n        """Called when bot is starting up."""\n        # Database connection pool\n        self.db = await asyncpg.create_pool(\n            \'postgresql://user:pass@localhost/botdb\',\n            min_size=5,\n            max_size=20,\n            command_timeout=60\n        )\n        logger.info("Database pool created")\n\n        # Redis connection\n        self.redis = redis.Redis.from_url(\n            \'redis://localhost:6379\',\n            decode_responses=True\n        )\n        logger.info("Redis connected")\n\n        # Load cogs\n        for cog in [\'moderation\', \'economy\', \'fun\', \'admin\']:\n            try:\n                await self.load_extension(f\'cogs.{cog}\')\n                logger.info(f"Loaded cog: {cog}")\n            except Exception as e:\n                logger.error(f"Failed to load cog {cog}: {e}")\n\n        # Sync commands\n        await self.tree.sync()\n        logger.info("Commands synced")\n\n        # Start background tasks\n        self.cleanup_task.start()\n\n    async def close(self) -> None:\n        """Cleanup on shutdown."""\n        logger.info("Shutting down...")\n\n        self.cleanup_task.cancel()\n\n        if self.db:\n            await self.db.close()\n        if self.redis:\n            await self.redis.close()\n\n        await super().close()\n\n    @tasks.loop(hours=1)\n    async def cleanup_task(self):\n        """Periodic cleanup of expired data."""\n        async with self.db.acquire() as conn:\n            await conn.execute("DELETE FROM mutes WHERE expires_at < NOW()")\n            await conn.execute("DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL \'90 days\'")\n\n    async def on_error(self, event: str, *args, **kwargs):\n        """Global error handler."""\n        logger.exception(f"Error in {event}")\n        if self.redis:\n            await self.redis.publish(\'bot_errors\', f"Error in {event}")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"telegram-bot-with-webhooks",children:"Telegram Bot with Webhooks"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from fastapi import FastAPI, Request\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters\n\napp = FastAPI()\n\n# Telegram app (don\'t use polling in production!)\ntelegram_app = Application.builder().token(BOT_TOKEN).build()\n\n@app.post("/webhook/{token}")\nasync def telegram_webhook(token: str, request: Request):\n    """Receive Telegram updates via webhook."""\n\n    # Verify token matches (simple security)\n    if token != WEBHOOK_TOKEN:\n        return {"error": "Invalid token"}\n\n    # Verify Telegram signature if using secret_token\n    secret_token = request.headers.get("X-Telegram-Bot-Api-Secret-Token")\n    if secret_token != TELEGRAM_SECRET:\n        return {"error": "Invalid signature"}\n\n    data = await request.json()\n    update = Update.de_json(data, telegram_app.bot)\n\n    await telegram_app.process_update(update)\n\n    return {"ok": True}\n\n# Set webhook on startup\n@app.on_event("startup")\nasync def setup_webhook():\n    await telegram_app.bot.set_webhook(\n        url=f"https://mybot.com/webhook/{WEBHOOK_TOKEN}",\n        secret_token=TELEGRAM_SECRET,\n        allowed_updates=["message", "callback_query"],\n        drop_pending_updates=True\n    )\n'})}),"\n",(0,o.jsx)(n.h2,{id:"security-checklist",children:"Security Checklist"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"TOKEN SECURITY\n\u251c\u2500\u2500 Never commit tokens to git\n\u251c\u2500\u2500 Use environment variables or secret manager\n\u251c\u2500\u2500 Rotate tokens if exposed\n\u2514\u2500\u2500 Use separate tokens for dev/staging/prod\n\nPERMISSION CHECKS\n\u251c\u2500\u2500 Always verify user has permission before action\n\u251c\u2500\u2500 Use Discord's permission system, don't roll your own\n\u251c\u2500\u2500 Check bot's permissions before attempting actions\n\u2514\u2500\u2500 Fail safely if permissions missing\n\nINPUT VALIDATION\n\u251c\u2500\u2500 Sanitize all user input\n\u251c\u2500\u2500 Validate command arguments\n\u251c\u2500\u2500 Use parameterized queries (no SQL injection)\n\u2514\u2500\u2500 Rate limit user-triggered actions\n\nAUDIT LOGGING\n\u251c\u2500\u2500 Log all moderation actions\n\u251c\u2500\u2500 Log permission changes\n\u251c\u2500\u2500 Log configuration changes\n\u2514\u2500\u2500 Retain logs for compliance period\n"})}),"\n",(0,o.jsx)(n.h2,{id:"platform-comparison",children:"Platform Comparison"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Feature"}),(0,o.jsx)(n.th,{children:"Discord"}),(0,o.jsx)(n.th,{children:"Telegram"}),(0,o.jsx)(n.th,{children:"Slack"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Connection"})}),(0,o.jsx)(n.td,{children:"Gateway (WebSocket)"}),(0,o.jsx)(n.td,{children:"Webhook or Polling"}),(0,o.jsx)(n.td,{children:"Socket Mode or Webhook"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Rate Limits"})}),(0,o.jsx)(n.td,{children:"Complex per-bucket"}),(0,o.jsx)(n.td,{children:"Simple global"}),(0,o.jsx)(n.td,{children:"Per-method"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Rich Messages"})}),(0,o.jsx)(n.td,{children:"Embeds"}),(0,o.jsx)(n.td,{children:"Markdown + Inline buttons"}),(0,o.jsx)(n.td,{children:"Blocks"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Slash Commands"})}),(0,o.jsx)(n.td,{children:"Built-in"}),(0,o.jsx)(n.td,{children:"BotFather menu"}),(0,o.jsx)(n.td,{children:"Manifest"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Media"})}),(0,o.jsx)(n.td,{children:"Attachments, CDN"}),(0,o.jsx)(n.td,{children:"Inline file ID"}),(0,o.jsx)(n.td,{children:"Files API"})]})]})]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);