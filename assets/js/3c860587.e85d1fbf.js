"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[80557],{28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var i=t(96540);const a={},r=i.createContext(a);function s(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(r.Provider,{value:e},n.children)}},47372:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"skills/dag_output_validator/index","title":"\ud83d\udce6 Dag Output Validator","description":"Validates agent outputs against expected schemas and quality criteria. Ensures outputs meet structural requirements and content standards. Activate on \'validate output\', \'output validation\', \'schema validation\', \'check output\', \'output quality\'. NOT for confidence scoring (use dag-confidence-scorer) or hallucination detection (use dag-hallucination-detector).","source":"@site/docs/skills/dag_output_validator/index.md","sourceDirName":"skills/dag_output_validator","slug":"/skills/dag_output_validator/","permalink":"/docs/skills/dag_output_validator/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Output Validator","sidebar_position":1}}');var a=t(74848),r=t(28453);const s={sidebar_label:"Dag Output Validator",sidebar_position:1},o="\ud83d\udce6 Dag Output Validator",l={},c=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Schema Validation",id:"1-schema-validation",level:3},{value:"2. Content Validation",id:"2-content-validation",level:3},{value:"3. Quality Assessment",id:"3-quality-assessment",level:3},{value:"4. Error Reporting",id:"4-error-reporting",level:3},{value:"Validation Architecture",id:"validation-architecture",level:2},{value:"Schema Validation",id:"schema-validation",level:2},{value:"Content Quality Validation",id:"content-quality-validation",level:2},{value:"Composite Validation",id:"composite-validation",level:2},{value:"Validation Report",id:"validation-report",level:2},{value:"Common Validation Schemas",id:"common-validation-schemas",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"-dag-output-validator",children:"\ud83d\udce6 Dag Output Validator"})}),"\n",(0,a.jsx)(e.p,{children:"Validates agent outputs against expected schemas and quality criteria. Ensures outputs meet structural requirements and content standards. Activate on 'validate output', 'output validation', 'schema validation', 'check output', 'output quality'. NOT for confidence scoring (use dag-confidence-scorer) or hallucination detection (use dag-hallucination-detector)."}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,a.jsx)(e.h2,{id:"tags",children:"Tags"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"dag"})," ",(0,a.jsx)(e.code,{children:"quality"})," ",(0,a.jsx)(e.code,{children:"validation"})," ",(0,a.jsx)(e.code,{children:"schemas"})," ",(0,a.jsx)(e.code,{children:"outputs"})]}),"\n",(0,a.jsx)(e.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/docs/skills/dag_confidence_scorer",children:"Dag Confidence Scorer"})}),": Provides validated output for scoring"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/docs/skills/dag_hallucination_detector",children:"Dag Hallucination Detector"})}),": Works together on quality checks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/docs/skills/dag_result_aggregator",children:"Dag Result Aggregator"})}),": Validates before aggregation"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"You are a DAG Output Validator, an expert at validating agent outputs against expected schemas and quality criteria. You ensure outputs meet structural requirements, contain required fields, and satisfy quality thresholds before being passed to downstream nodes."}),"\n",(0,a.jsx)(e.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,a.jsx)(e.h3,{id:"1-schema-validation",children:"1. Schema Validation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Validate output structure against JSON schemas"}),"\n",(0,a.jsx)(e.li,{children:"Check required fields and types"}),"\n",(0,a.jsx)(e.li,{children:"Validate nested structures"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"2-content-validation",children:"2. Content Validation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Check content length and format"}),"\n",(0,a.jsx)(e.li,{children:"Validate data ranges and constraints"}),"\n",(0,a.jsx)(e.li,{children:"Ensure completeness of outputs"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"3-quality-assessment",children:"3. Quality Assessment"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Apply quality scoring rules"}),"\n",(0,a.jsx)(e.li,{children:"Check against minimum thresholds"}),"\n",(0,a.jsx)(e.li,{children:"Flag outputs needing review"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"4-error-reporting",children:"4. Error Reporting"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Generate detailed validation reports"}),"\n",(0,a.jsx)(e.li,{children:"Provide specific error locations"}),"\n",(0,a.jsx)(e.li,{children:"Suggest corrections"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"validation-architecture",children:"Validation Architecture"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface OutputSchema {\n  type: 'object' | 'array' | 'string' | 'number' | 'boolean';\n  properties?: Record<string, OutputSchema>;\n  items?: OutputSchema;\n  required?: string[];\n  minLength?: number;\n  maxLength?: number;\n  minimum?: number;\n  maximum?: number;\n  pattern?: string;\n  enum?: unknown[];\n  format?: 'date' | 'uri' | 'email' | 'markdown' | 'code';\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  score: number;  // 0-1 quality score\n  errors: ValidationError[];\n  warnings: ValidationWarning[];\n  metadata: ValidationMetadata;\n}\n\ninterface ValidationError {\n  path: string;           // JSON path to error location\n  code: string;           // Error code\n  message: string;        // Human-readable message\n  expected: unknown;      // What was expected\n  actual: unknown;        // What was received\n  severity: 'error' | 'critical';\n}\n\ninterface ValidationWarning {\n  path: string;\n  code: string;\n  message: string;\n  suggestion?: string;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"schema-validation",children:"Schema Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"function validateAgainstSchema(\n  output: unknown,\n  schema: OutputSchema,\n  path: string = '$'\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n\n  // Type validation\n  const actualType = getType(output);\n  if (actualType !== schema.type) {\n    errors.push({\n      path,\n      code: 'TYPE_MISMATCH',\n      message: `Expected ${schema.type}, got ${actualType}`,\n      expected: schema.type,\n      actual: actualType,\n      severity: 'error',\n    });\n    return errors; // Can't continue if type is wrong\n  }\n\n  // Object validation\n  if (schema.type === 'object' && schema.properties) {\n    const obj = output as Record<string, unknown>;\n\n    // Required fields\n    for (const field of schema.required ?? []) {\n      if (!(field in obj)) {\n        errors.push({\n          path: `${path}.${field}`,\n          code: 'REQUIRED_FIELD_MISSING',\n          message: `Required field '${field}' is missing`,\n          expected: 'present',\n          actual: 'missing',\n          severity: 'critical',\n        });\n      }\n    }\n\n    // Validate each property\n    for (const [key, propSchema] of Object.entries(schema.properties)) {\n      if (key in obj) {\n        errors.push(...validateAgainstSchema(\n          obj[key],\n          propSchema,\n          `${path}.${key}`\n        ));\n      }\n    }\n  }\n\n  // Array validation\n  if (schema.type === 'array' && schema.items) {\n    const arr = output as unknown[];\n\n    if (schema.minLength && arr.length < schema.minLength) {\n      errors.push({\n        path,\n        code: 'ARRAY_TOO_SHORT',\n        message: `Array must have at least ${schema.minLength} items`,\n        expected: schema.minLength,\n        actual: arr.length,\n        severity: 'error',\n      });\n    }\n\n    // Validate each item\n    arr.forEach((item, index) => {\n      errors.push(...validateAgainstSchema(\n        item,\n        schema.items!,\n        `${path}[${index}]`\n      ));\n    });\n  }\n\n  // String validation\n  if (schema.type === 'string') {\n    const str = output as string;\n\n    if (schema.minLength && str.length < schema.minLength) {\n      errors.push({\n        path,\n        code: 'STRING_TOO_SHORT',\n        message: `String must be at least ${schema.minLength} characters`,\n        expected: schema.minLength,\n        actual: str.length,\n        severity: 'error',\n      });\n    }\n\n    if (schema.pattern) {\n      const regex = new RegExp(schema.pattern);\n      if (!regex.test(str)) {\n        errors.push({\n          path,\n          code: 'PATTERN_MISMATCH',\n          message: `String does not match pattern: ${schema.pattern}`,\n          expected: schema.pattern,\n          actual: str,\n          severity: 'error',\n        });\n      }\n    }\n  }\n\n  // Number validation\n  if (schema.type === 'number') {\n    const num = output as number;\n\n    if (schema.minimum !== undefined && num < schema.minimum) {\n      errors.push({\n        path,\n        code: 'NUMBER_TOO_SMALL',\n        message: `Number must be at least ${schema.minimum}`,\n        expected: schema.minimum,\n        actual: num,\n        severity: 'error',\n      });\n    }\n\n    if (schema.maximum !== undefined && num > schema.maximum) {\n      errors.push({\n        path,\n        code: 'NUMBER_TOO_LARGE',\n        message: `Number must be at most ${schema.maximum}`,\n        expected: schema.maximum,\n        actual: num,\n        severity: 'error',\n      });\n    }\n  }\n\n  return errors;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"content-quality-validation",children:"Content Quality Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface ContentRules {\n  minWordCount?: number;\n  maxWordCount?: number;\n  requiredSections?: string[];\n  prohibitedPatterns?: string[];\n  codeBlockRequired?: boolean;\n  linksRequired?: boolean;\n}\n\nfunction validateContentQuality(\n  content: string,\n  rules: ContentRules\n): ValidationResult {\n  const errors: ValidationError[] = [];\n  const warnings: ValidationWarning[] = [];\n  let qualityScore = 1.0;\n\n  // Word count\n  const words = content.split(/\\s+/).filter(w => w.length > 0);\n\n  if (rules.minWordCount && words.length < rules.minWordCount) {\n    errors.push({\n      path: '$.content',\n      code: 'CONTENT_TOO_SHORT',\n      message: `Content has ${words.length} words, minimum is ${rules.minWordCount}`,\n      expected: rules.minWordCount,\n      actual: words.length,\n      severity: 'error',\n    });\n    qualityScore -= 0.3;\n  }\n\n  if (rules.maxWordCount && words.length > rules.maxWordCount) {\n    warnings.push({\n      path: '$.content',\n      code: 'CONTENT_TOO_LONG',\n      message: `Content has ${words.length} words, maximum is ${rules.maxWordCount}`,\n      suggestion: 'Consider summarizing or splitting content',\n    });\n    qualityScore -= 0.1;\n  }\n\n  // Required sections\n  if (rules.requiredSections) {\n    for (const section of rules.requiredSections) {\n      const sectionPattern = new RegExp(`##?\\\\s*${section}`, 'i');\n      if (!sectionPattern.test(content)) {\n        errors.push({\n          path: '$.content',\n          code: 'MISSING_SECTION',\n          message: `Required section '${section}' not found`,\n          expected: section,\n          actual: 'missing',\n          severity: 'error',\n        });\n        qualityScore -= 0.2;\n      }\n    }\n  }\n\n  // Prohibited patterns\n  if (rules.prohibitedPatterns) {\n    for (const pattern of rules.prohibitedPatterns) {\n      const regex = new RegExp(pattern, 'gi');\n      const matches = content.match(regex);\n      if (matches) {\n        errors.push({\n          path: '$.content',\n          code: 'PROHIBITED_CONTENT',\n          message: `Found prohibited pattern: ${pattern}`,\n          expected: 'none',\n          actual: matches.slice(0, 3).join(', '),\n          severity: 'error',\n        });\n        qualityScore -= 0.3;\n      }\n    }\n  }\n\n  // Code block check\n  if (rules.codeBlockRequired) {\n    const codeBlockPattern = /```[\\s\\S]*?```/;\n    if (!codeBlockPattern.test(content)) {\n      warnings.push({\n        path: '$.content',\n        code: 'NO_CODE_BLOCKS',\n        message: 'Content does not contain any code blocks',\n        suggestion: 'Add code examples to illustrate concepts',\n      });\n      qualityScore -= 0.1;\n    }\n  }\n\n  return {\n    valid: errors.filter(e => e.severity === 'critical').length === 0,\n    score: Math.max(0, qualityScore),\n    errors,\n    warnings,\n    metadata: {\n      wordCount: words.length,\n      validatedAt: new Date(),\n      rulesApplied: Object.keys(rules),\n    },\n  };\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"composite-validation",children:"Composite Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface ValidationConfig {\n  schema?: OutputSchema;\n  contentRules?: ContentRules;\n  customValidators?: CustomValidator[];\n  strictMode?: boolean;  // Fail on warnings\n}\n\ninterface CustomValidator {\n  name: string;\n  validate: (output: unknown) => ValidationError[];\n}\n\nasync function validateOutput(\n  output: unknown,\n  config: ValidationConfig\n): Promise<ValidationResult> {\n  const allErrors: ValidationError[] = [];\n  const allWarnings: ValidationWarning[] = [];\n  let totalScore = 1.0;\n\n  // Schema validation\n  if (config.schema) {\n    const schemaErrors = validateAgainstSchema(output, config.schema);\n    allErrors.push(...schemaErrors);\n    totalScore -= schemaErrors.length * 0.1;\n  }\n\n  // Content validation\n  if (config.contentRules && typeof output === 'string') {\n    const contentResult = validateContentQuality(output, config.contentRules);\n    allErrors.push(...contentResult.errors);\n    allWarnings.push(...contentResult.warnings);\n    totalScore = Math.min(totalScore, contentResult.score);\n  }\n\n  // Custom validators\n  if (config.customValidators) {\n    for (const validator of config.customValidators) {\n      try {\n        const customErrors = validator.validate(output);\n        allErrors.push(...customErrors);\n      } catch (error) {\n        allErrors.push({\n          path: '$',\n          code: 'VALIDATOR_FAILED',\n          message: `Custom validator '${validator.name}' failed: ${error}`,\n          expected: 'success',\n          actual: 'error',\n          severity: 'error',\n        });\n      }\n    }\n  }\n\n  // Strict mode\n  if (config.strictMode && allWarnings.length > 0) {\n    const criticalWarnings = allWarnings.map(w => ({\n      ...w,\n      severity: 'error' as const,\n      path: w.path,\n      code: w.code,\n      message: w.message,\n      expected: 'no warnings',\n      actual: w.message,\n    }));\n    allErrors.push(...criticalWarnings);\n  }\n\n  const hasCriticalErrors = allErrors.some(e => e.severity === 'critical');\n\n  return {\n    valid: !hasCriticalErrors && allErrors.length === 0,\n    score: Math.max(0, totalScore),\n    errors: allErrors,\n    warnings: allWarnings,\n    metadata: {\n      validatedAt: new Date(),\n      validatorsRun: [\n        config.schema ? 'schema' : null,\n        config.contentRules ? 'content' : null,\n        ...(config.customValidators?.map(v => v.name) ?? []),\n      ].filter(Boolean),\n      strictMode: config.strictMode ?? false,\n    },\n  };\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"validation-report",children:"Validation Report"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'validationReport:\n  nodeId: code-generator\n  outputType: code-analysis\n  validatedAt: "2024-01-15T10:30:00Z"\n\n  result:\n    valid: false\n    score: 0.65\n\n  schema:\n    type: object\n    validated: true\n    errors: 1\n\n  errors:\n    - path: $.analysis.security\n      code: REQUIRED_FIELD_MISSING\n      message: "Required field \'security\' is missing"\n      expected: present\n      actual: missing\n      severity: critical\n\n    - path: $.analysis.performance.score\n      code: NUMBER_TOO_SMALL\n      message: "Number must be at least 0"\n      expected: 0\n      actual: -0.5\n      severity: error\n\n  warnings:\n    - path: $.content\n      code: CONTENT_TOO_SHORT\n      message: "Content has 45 words, recommend at least 100"\n      suggestion: "Expand analysis with more details"\n\n  metadata:\n    wordCount: 45\n    validatorsRun: [schema, content, customSecurity]\n    strictMode: false\n\n  suggestions:\n    - "Add \'security\' field to analysis object"\n    - "Ensure performance.score is non-negative"\n    - "Expand content to provide more detail"\n'})}),"\n",(0,a.jsx)(e.h2,{id:"common-validation-schemas",children:"Common Validation Schemas"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Code analysis output schema\nconst CODE_ANALYSIS_SCHEMA: OutputSchema = {\n  type: 'object',\n  required: ['file', 'analysis', 'suggestions'],\n  properties: {\n    file: { type: 'string', minLength: 1 },\n    analysis: {\n      type: 'object',\n      required: ['complexity', 'quality'],\n      properties: {\n        complexity: { type: 'number', minimum: 0, maximum: 100 },\n        quality: { type: 'number', minimum: 0, maximum: 1 },\n        issues: {\n          type: 'array',\n          items: {\n            type: 'object',\n            required: ['line', 'message'],\n            properties: {\n              line: { type: 'number', minimum: 1 },\n              message: { type: 'string', minLength: 1 },\n            },\n          },\n        },\n      },\n    },\n    suggestions: {\n      type: 'array',\n      items: { type: 'string', minLength: 1 },\n    },\n  },\n};\n\n// Documentation output schema\nconst DOCUMENTATION_SCHEMA: OutputSchema = {\n  type: 'object',\n  required: ['title', 'content'],\n  properties: {\n    title: { type: 'string', minLength: 1, maxLength: 200 },\n    content: { type: 'string', minLength: 100 },\n    sections: {\n      type: 'array',\n      items: {\n        type: 'object',\n        required: ['heading', 'body'],\n        properties: {\n          heading: { type: 'string' },\n          body: { type: 'string' },\n        },\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsx)(e.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Input"}),": Outputs from any DAG node execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Downstream"}),": ",(0,a.jsx)(e.code,{children:"dag-confidence-scorer"})," for scoring"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Quality Gate"}),": ",(0,a.jsx)(e.code,{children:"dag-result-aggregator"})," pre-aggregation check"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Feedback"}),": ",(0,a.jsx)(e.code,{children:"dag-feedback-synthesizer"})," for improvement hints"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Schema First"}),": Define schemas before execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fail Fast"}),": Catch critical errors immediately"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Detailed Errors"}),": Include path and expected values"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Graduated Severity"}),": Distinguish warnings from errors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Custom Rules"}),": Extend with domain-specific validators"]}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.p,{children:"Structured validation. Quality gates. No bad outputs pass."})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);