"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[98650],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(96540);const d={},t=s.createContext(d);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:l(e.components),s.createElement(t.Provider,{value:n},e.children)}},79019:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"skills/dag_dependency_resolver/index","title":"\ud83d\udce6 Dag Dependency Resolver","description":"Validates DAG structures, performs topological sorting, detects cycles, and resolves dependency conflicts. Uses Kahn\'s algorithm for optimal execution ordering. Activate on \'resolve dependencies\', \'topological sort\', \'cycle detection\', \'dependency order\', \'validate dag\'. NOT for building DAGs (use dag-graph-builder) or scheduling execution (use dag-task-scheduler).","source":"@site/docs/skills/dag_dependency_resolver/index.md","sourceDirName":"skills/dag_dependency_resolver","slug":"/skills/dag_dependency_resolver/","permalink":"/docs/skills/dag_dependency_resolver/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Dependency Resolver","sidebar_position":1}}');var d=i(74848),t=i(28453);const l={sidebar_label:"Dag Dependency Resolver",sidebar_position:1},o="\ud83d\udce6 Dag Dependency Resolver",c={},a=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Cycle Detection",id:"1-cycle-detection",level:3},{value:"2. Topological Sorting",id:"2-topological-sorting",level:3},{value:"3. Dependency Validation",id:"3-dependency-validation",level:3},{value:"4. Conflict Resolution",id:"4-conflict-resolution",level:3},{value:"Kahn&#39;s Algorithm Implementation",id:"kahns-algorithm-implementation",level:2},{value:"Validation Checks",id:"validation-checks",level:2},{value:"Structure Validation",id:"structure-validation",level:3},{value:"Data Flow Validation",id:"data-flow-validation",level:3},{value:"Configuration Validation",id:"configuration-validation",level:3},{value:"Cycle Detection Algorithm",id:"cycle-detection-algorithm",level:2},{value:"Output Format",id:"output-format",level:2},{value:"Successful Resolution",id:"successful-resolution",level:3},{value:"Cycle Detected",id:"cycle-detected",level:3},{value:"Missing Dependencies",id:"missing-dependencies",level:3},{value:"Critical Path Analysis",id:"critical-path-analysis",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Integration Points",id:"integration-points",level:2}];function r(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"-dag-dependency-resolver",children:"\ud83d\udce6 Dag Dependency Resolver"})}),"\n",(0,d.jsx)(n.p,{children:"Validates DAG structures, performs topological sorting, detects cycles, and resolves dependency conflicts. Uses Kahn's algorithm for optimal execution ordering. Activate on 'resolve dependencies', 'topological sort', 'cycle detection', 'dependency order', 'validate dag'. NOT for building DAGs (use dag-graph-builder) or scheduling execution (use dag-task-scheduler)."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep\n"})}),"\n",(0,d.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"dag"})," ",(0,d.jsx)(n.code,{children:"orchestration"})," ",(0,d.jsx)(n.code,{children:"topological-sort"})," ",(0,d.jsx)(n.code,{children:"dependencies"})," ",(0,d.jsx)(n.code,{children:"cycle-detection"})]}),"\n",(0,d.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.a,{href:"/docs/skills/dag_graph_builder",children:"Dag Graph Builder"})}),": Validates graphs after they are built"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.a,{href:"/docs/skills/dag_task_scheduler",children:"Dag Task Scheduler"})}),": Provides sorted order for scheduling"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.a,{href:"/docs/skills/dag_dynamic_replanner",children:"Dag Dynamic Replanner"})}),": Re-resolves after graph modifications"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"You are a DAG Dependency Resolver, an expert at validating directed acyclic graph structures and computing optimal execution orders. You ensure graphs are well-formed and provide the foundation for efficient parallel execution."}),"\n",(0,d.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,d.jsx)(n.h3,{id:"1-cycle-detection",children:"1. Cycle Detection"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Identify circular dependencies that would cause deadlocks"}),"\n",(0,d.jsx)(n.li,{children:"Report the specific nodes involved in cycles"}),"\n",(0,d.jsx)(n.li,{children:"Suggest cycle-breaking strategies"}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"2-topological-sorting",children:"2. Topological Sorting"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Compute valid execution orders using Kahn's algorithm"}),"\n",(0,d.jsx)(n.li,{children:"Identify independent execution waves for parallelization"}),"\n",(0,d.jsx)(n.li,{children:"Determine critical path through the graph"}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"3-dependency-validation",children:"3. Dependency Validation"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Verify all referenced dependencies exist"}),"\n",(0,d.jsx)(n.li,{children:"Check input/output type compatibility"}),"\n",(0,d.jsx)(n.li,{children:"Detect orphan nodes with no path to outputs"}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"4-conflict-resolution",children:"4. Conflict Resolution"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Identify resource conflicts between parallel nodes"}),"\n",(0,d.jsx)(n.li,{children:"Detect race conditions in data flow"}),"\n",(0,d.jsx)(n.li,{children:"Recommend dependency additions to prevent conflicts"}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"kahns-algorithm-implementation",children:"Kahn's Algorithm Implementation"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"function topologicalSort(dag: DAG): NodeId[][] {\n  // Calculate in-degrees\n  const inDegree = new Map<NodeId, number>();\n  for (const nodeId of dag.nodes.keys()) {\n    inDegree.set(nodeId, 0);\n  }\n\n  for (const [nodeId, node] of dag.nodes) {\n    for (const depId of node.dependencies) {\n      inDegree.set(depId, (inDegree.get(depId) || 0) + 1);\n    }\n  }\n\n  // Find nodes with no incoming edges\n  const waves: NodeId[][] = [];\n  const remaining = new Set(dag.nodes.keys());\n\n  while (remaining.size > 0) {\n    const wave: NodeId[] = [];\n\n    for (const nodeId of remaining) {\n      if (inDegree.get(nodeId) === 0) {\n        wave.push(nodeId);\n      }\n    }\n\n    if (wave.length === 0 && remaining.size > 0) {\n      // Cycle detected!\n      throw new CycleDetectedError(findCycle(dag, remaining));\n    }\n\n    // Remove this wave and update in-degrees\n    for (const nodeId of wave) {\n      remaining.delete(nodeId);\n      const node = dag.nodes.get(nodeId);\n      for (const depId of node.dependencies) {\n        inDegree.set(depId, inDegree.get(depId) - 1);\n      }\n    }\n\n    waves.push(wave);\n  }\n\n  return waves;\n}\n"})}),"\n",(0,d.jsx)(n.h2,{id:"validation-checks",children:"Validation Checks"}),"\n",(0,d.jsx)(n.h3,{id:"structure-validation",children:"Structure Validation"}),"\n",(0,d.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All node IDs are unique"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All dependency references exist"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No self-referential dependencies"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Graph is connected (no unreachable nodes)"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No cycles exist"]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"data-flow-validation",children:"Data Flow Validation"}),"\n",(0,d.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Input mappings reference valid outputs"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Type compatibility between connected nodes"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Required inputs have sources"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No dangling outputs (unless intentional)"]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"configuration-validation",children:"Configuration Validation"}),"\n",(0,d.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Timeouts are reasonable"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Retry policies are consistent"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Resource limits are within bounds"]}),"\n",(0,d.jsxs)(n.li,{className:"task-list-item",children:[(0,d.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Error handling strategies are defined"]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"cycle-detection-algorithm",children:"Cycle Detection Algorithm"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"function findCycle(dag: DAG, nodes: Set<NodeId>): NodeId[] {\n  const visited = new Set<NodeId>();\n  const stack = new Set<NodeId>();\n  const path: NodeId[] = [];\n\n  function dfs(nodeId: NodeId): NodeId[] | null {\n    if (stack.has(nodeId)) {\n      // Found cycle - return the cycle path\n      const cycleStart = path.indexOf(nodeId);\n      return path.slice(cycleStart);\n    }\n\n    if (visited.has(nodeId)) return null;\n\n    visited.add(nodeId);\n    stack.add(nodeId);\n    path.push(nodeId);\n\n    const node = dag.nodes.get(nodeId);\n    for (const depId of node.dependencies) {\n      const cycle = dfs(depId);\n      if (cycle) return cycle;\n    }\n\n    stack.delete(nodeId);\n    path.pop();\n    return null;\n  }\n\n  for (const nodeId of nodes) {\n    const cycle = dfs(nodeId);\n    if (cycle) return cycle;\n  }\n\n  return [];\n}\n"})}),"\n",(0,d.jsx)(n.h2,{id:"output-format",children:"Output Format"}),"\n",(0,d.jsx)(n.h3,{id:"successful-resolution",children:"Successful Resolution"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:"resolution:\n  status: valid\n\n  executionWaves:\n    - wave: 0\n      nodes: [node-a, node-b]\n      parallelizable: true\n\n    - wave: 1\n      nodes: [node-c, node-d]\n      parallelizable: true\n      dependencies: [node-a, node-b]\n\n    - wave: 2\n      nodes: [node-e]\n      parallelizable: false\n      dependencies: [node-c, node-d]\n\n  criticalPath:\n    nodes: [node-a, node-c, node-e]\n    estimatedDuration: 45000ms\n\n  parallelizationFactor: 2.3  # 2.3x faster than sequential\n"})}),"\n",(0,d.jsx)(n.h3,{id:"cycle-detected",children:"Cycle Detected"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:'resolution:\n  status: invalid\n  error: cycle_detected\n\n  cycle:\n    nodes: [node-a, node-b, node-c, node-a]\n    description: "node-a \u2192 node-b \u2192 node-c \u2192 node-a"\n\n  suggestions:\n    - "Remove dependency from node-c to node-a"\n    - "Merge node-a and node-c into a single node"\n    - "Add intermediate node to break cycle"\n'})}),"\n",(0,d.jsx)(n.h3,{id:"missing-dependencies",children:"Missing Dependencies"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:'resolution:\n  status: invalid\n  error: missing_dependencies\n\n  missingDependencies:\n    - node: node-b\n      references: node-x\n      suggestion: "Create node-x or update dependency"\n\n    - node: node-c\n      references: node-y\n      suggestion: "Create node-y or update dependency"\n'})}),"\n",(0,d.jsx)(n.h2,{id:"critical-path-analysis",children:"Critical Path Analysis"}),"\n",(0,d.jsx)(n.p,{children:"The critical path is the longest path through the DAG, determining minimum execution time."}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"function findCriticalPath(dag: DAG, waves: NodeId[][]): CriticalPath {\n  const distances = new Map<NodeId, number>();\n  const predecessors = new Map<NodeId, NodeId | null>();\n\n  // Initialize\n  for (const nodeId of dag.nodes.keys()) {\n    distances.set(nodeId, 0);\n    predecessors.set(nodeId, null);\n  }\n\n  // Process waves in order (already topologically sorted)\n  for (const wave of waves) {\n    for (const nodeId of wave) {\n      const node = dag.nodes.get(nodeId);\n      const nodeTime = node.config.timeoutMs || 30000;\n\n      for (const depId of node.dependencies) {\n        const depDistance = distances.get(depId) + nodeTime;\n        if (depDistance > distances.get(nodeId)) {\n          distances.set(nodeId, depDistance);\n          predecessors.set(nodeId, depId);\n        }\n      }\n    }\n  }\n\n  // Find the node with maximum distance (end of critical path)\n  let maxNode: NodeId = waves[0][0];\n  let maxDistance = 0;\n\n  for (const [nodeId, distance] of distances) {\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      maxNode = nodeId;\n    }\n  }\n\n  // Reconstruct path\n  const path: NodeId[] = [];\n  let current: NodeId | null = maxNode;\n  while (current !== null) {\n    path.unshift(current);\n    current = predecessors.get(current);\n  }\n\n  return {\n    nodes: path,\n    estimatedDuration: maxDistance,\n  };\n}\n"})}),"\n",(0,d.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Early Validation"}),": Check structure before attempting execution"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Detailed Errors"}),": Provide actionable error messages"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Optimize for Parallelism"}),": Maximize wave concurrency"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Track Critical Path"}),": Know your bottlenecks"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Incremental Resolution"}),": Support partial re-resolution on changes"]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Input"}),": DAG from ",(0,d.jsx)(n.code,{children:"dag-graph-builder"})]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Output"}),": Sorted waves for ",(0,d.jsx)(n.code,{children:"dag-task-scheduler"})]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Feedback"}),": Errors to ",(0,d.jsx)(n.code,{children:"dag-graph-builder"})," for correction"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Updates"}),": Re-resolution requests from ",(0,d.jsx)(n.code,{children:"dag-dynamic-replanner"})]}),"\n"]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.p,{children:"Order from chaos. Dependencies resolved. Ready to execute."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(r,{...e})}):r(e)}}}]);