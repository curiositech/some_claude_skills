"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[46159],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},92860:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>a,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"skills/collage_layout_expert/references/line-detection","title":"Line Detection Algorithms (State of the Art)","description":"Algorithm Comparison (2025)","source":"@site/docs/skills/collage_layout_expert/references/line-detection.md","sourceDirName":"skills/collage_layout_expert/references","slug":"/skills/collage_layout_expert/references/line-detection","permalink":"/docs/skills/collage_layout_expert/references/line-detection","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Line Detection Algorithms (State of the Art)","sidebar_label":"Line Detection Algorithms (...","sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Practical Implementation Guide","permalink":"/docs/skills/collage_layout_expert/references/implementation-guide"},"next":{"title":"Mathematical Foundations","permalink":"/docs/skills/collage_layout_expert/references/mathematical-foundations"}}');var s=i(74848),r=i(28453);const l={title:"Line Detection Algorithms (State of the Art)",sidebar_label:"Line Detection Algorithms (...",sidebar_position:8},o="Line Detection Algorithms (State of the Art)",c={},d=[{value:"Algorithm Comparison (2025)",id:"algorithm-comparison-2025",level:2},{value:"EDLines: Optimal Choice for Collage Assembly",id:"edlines-optimal-choice-for-collage-assembly",level:2},{value:"EDLines Algorithm Overview",id:"edlines-algorithm-overview",level:3},{value:"Performance Benchmarks",id:"performance-benchmarks",level:3},{value:"LSD (Line Segment Detector)",id:"lsd-line-segment-detector",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Hough Transform",id:"hough-transform",level:2},{value:"Classical Hough",id:"classical-hough",level:3},{value:"Probabilistic Hough (faster variant)",id:"probabilistic-hough-faster-variant",level:3},{value:"When to Use Each Algorithm",id:"when-to-use-each-algorithm",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"line-detection-algorithms-state-of-the-art",children:"Line Detection Algorithms (State of the Art)"})}),"\n",(0,s.jsx)(n.h2,{id:"algorithm-comparison-2025",children:"Algorithm Comparison (2025)"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Algorithm"}),(0,s.jsx)(n.th,{children:"Speed vs LSD"}),(0,s.jsx)(n.th,{children:"Accuracy"}),(0,s.jsx)(n.th,{children:"Real-time?"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Hough Transform"})}),(0,s.jsx)(n.td,{children:"0.1x"}),(0,s.jsx)(n.td,{children:"Good"}),(0,s.jsx)(n.td,{children:"No"}),(0,s.jsx)(n.td,{children:"Traditional, needs Canny preprocessing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"LSD"})}),(0,s.jsx)(n.td,{children:"1x (baseline)"}),(0,s.jsx)(n.td,{children:"Excellent"}),(0,s.jsx)(n.td,{children:"Borderline"}),(0,s.jsx)(n.td,{children:"Baseline for modern methods"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"EDLines"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"10-11x"})}),(0,s.jsx)(n.td,{children:"Excellent"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Yes"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Recommended for your projects"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"LB-LSD"})}),(0,s.jsx)(n.td,{children:"8x"}),(0,s.jsx)(n.td,{children:"Good"}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Length-based optimization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"LETR"})," (Transformer)"]}),(0,s.jsx)(n.td,{children:"0.5x"}),(0,s.jsx)(n.td,{children:"Excellent"}),(0,s.jsx)(n.td,{children:"No"}),(0,s.jsx)(n.td,{children:"Deep learning, GPU-heavy"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"edlines-optimal-choice-for-collage-assembly",children:"EDLines: Optimal Choice for Collage Assembly"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why EDLines for Edge-Based Collage Assembly"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Speed"}),": 10x faster than LSD (critical for interactive generation)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Accuracy"}),": Produces precise line segments with false detection control"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No parameter tuning"}),": Works out-of-box (vs. Hough's many parameters)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edge-based"}),': Aligns perfectly with "edge-first assembly" approach']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time"}),": Suitable for live preview as users adjust parameters"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"edlines-algorithm-overview",children:"EDLines Algorithm Overview"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1. Edge Detection (Edge Drawing algorithm)\n   - Fast gradient-based edge extraction\n   - Produces clean edge chains (not noisy pixel maps)\n\n2. Line Segment Fitting\n   - Fit line segments to edge chains\n   - Use least-squares fitting with error threshold\n   - Validate line segments (reject false detections)\n\n3. Output\n   - List of line segments: [(x1, y1, x2, y2, angle, length, strength), ...]\n   - Angle in degrees (-90 to 90)\n   - Strength from gradient magnitude\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"1024\xd71024 image"}),": ~10-15ms on M2 GPU"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"4K image"}),": ~40-50ms on M2 GPU"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"iPhone 15 Pro"}),": ~20-30ms (1024\xd71024)"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lsd-line-segment-detector",children:"LSD (Line Segment Detector)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when"}),": You need maximum accuracy over speed (e.g., final high-res render)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Characteristics"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gradient grouping approach"}),"\n",(0,s.jsx)(n.li,{children:"Built-in false detection control (Helmholtz principle)"}),"\n",(0,s.jsx)(n.li,{children:"Parameter-free (adaptive thresholds)"}),"\n",(0,s.jsx)(n.li,{children:"Produces sub-pixel accurate line segments"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import cv2\n\n# OpenCV includes LSD\nlsd = cv2.createLineSegmentDetector(0)  # 0 = LSD_REFINE_NONE\nlines, width, prec, nfa = lsd.detect(gray_image)\n\n# lines: Nx1x4 array of [x1, y1, x2, y2]\n# width: line widths\n# nfa: Number of False Alarms (lower = more confident)\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"hough-transform",children:"Hough Transform"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use when"}),": Detecting specific geometric patterns (circles, ellipses) or teaching/legacy contexts"]}),"\n",(0,s.jsx)(n.h3,{id:"classical-hough",children:"Classical Hough"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import cv2\nimport numpy as np\n\n# 1. Preprocess: Edge detection\nedges = cv2.Canny(gray_image, 50, 150)\n\n# 2. Hough Transform\nlines = cv2.HoughLines(edges, rho=1, theta=np.pi/180, threshold=100)\n\n# 3. Convert from (\u03c1, \u03b8) to (x1, y1, x2, y2)\nfor rho, theta in lines:\n    a, b = np.cos(theta), np.sin(theta)\n    x0, y0 = a * rho, b * rho\n    x1 = int(x0 + 1000 * (-b))\n    y1 = int(y0 + 1000 * (a))\n    x2 = int(x0 - 1000 * (-b))\n    y2 = int(y0 - 1000 * (a))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"probabilistic-hough-faster-variant",children:"Probabilistic Hough (faster variant)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"lines = cv2.HoughLinesP(\n    edges,\n    rho=1,\n    theta=np.pi/180,\n    threshold=50,\n    minLineLength=30,\n    maxLineGap=10\n)\n# Returns line segments directly: [(x1, y1, x2, y2), ...]\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-each-algorithm",children:"When to Use Each Algorithm"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Context"}),(0,s.jsx)(n.th,{children:"Recommended"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Interactive generation"}),(0,s.jsx)(n.td,{children:"EDLines"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Final high-res render"}),(0,s.jsx)(n.td,{children:"LSD"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Teaching / legacy code"}),(0,s.jsx)(n.td,{children:"Hough"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Deep learning pipeline"}),(0,s.jsx)(n.td,{children:"LETR"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Mobile real-time"}),(0,s.jsx)(n.td,{children:"EDLines"})]})]})]})]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);