"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[58423],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var s=t(96540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},34333:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"skills/mobile_ux_optimizer/references/gestures","title":"Gesture Hooks","description":"Touch gesture handling for mobile interactions.","source":"@site/docs/skills/mobile_ux_optimizer/references/gestures.md","sourceDirName":"skills/mobile_ux_optimizer/references","slug":"/skills/mobile_ux_optimizer/references/gestures","permalink":"/docs/skills/mobile_ux_optimizer/references/gestures","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Gesture Hooks","sidebar_label":"Gesture Hooks","sidebar_position":1}}');var r=t(74848),i=t(28453);const o={title:"Gesture Hooks",sidebar_label:"Gesture Hooks",sidebar_position:1},l="Gesture Hooks",c={},a=[{value:"useSwipe Hook",id:"useswipe-hook",level:2},{value:"Usage",id:"usage",level:3},{value:"usePullToRefresh Hook",id:"usepulltorefresh-hook",level:2},{value:"Usage with Visual Indicator",id:"usage-with-visual-indicator",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"gesture-hooks",children:"Gesture Hooks"})}),"\n",(0,r.jsx)(n.p,{children:"Touch gesture handling for mobile interactions."}),"\n",(0,r.jsx)(n.h2,{id:"useswipe-hook",children:"useSwipe Hook"}),"\n",(0,r.jsx)(n.p,{children:"Directional swipe detection with configurable threshold."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// hooks/useSwipe.ts\n'use client';\n\nimport { useRef, TouchEvent } from 'react';\n\ninterface SwipeConfig {\n  onSwipeLeft?: () => void;\n  onSwipeRight?: () => void;\n  onSwipeUp?: () => void;\n  onSwipeDown?: () => void;\n  threshold?: number;  // Minimum distance in pixels (default: 50)\n}\n\nexport function useSwipe(config: SwipeConfig) {\n  const touchStart = useRef<{ x: number; y: number } | null>(null);\n  const threshold = config.threshold ?? 50;\n\n  const handleTouchStart = (e: TouchEvent) => {\n    touchStart.current = {\n      x: e.touches[0].clientX,\n      y: e.touches[0].clientY,\n    };\n  };\n\n  const handleTouchEnd = (e: TouchEvent) => {\n    if (!touchStart.current) return;\n\n    const deltaX = e.changedTouches[0].clientX - touchStart.current.x;\n    const deltaY = e.changedTouches[0].clientY - touchStart.current.y;\n\n    // Determine primary direction (larger delta wins)\n    if (Math.abs(deltaX) > Math.abs(deltaY)) {\n      if (deltaX > threshold) config.onSwipeRight?.();\n      if (deltaX < -threshold) config.onSwipeLeft?.();\n    } else {\n      if (deltaY > threshold) config.onSwipeDown?.();\n      if (deltaY < -threshold) config.onSwipeUp?.();\n    }\n\n    touchStart.current = null;\n  };\n\n  return { handleTouchStart, handleTouchEnd };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'function ImageGallery({ images, currentIndex, setCurrentIndex }) {\n  const { handleTouchStart, handleTouchEnd } = useSwipe({\n    onSwipeLeft: () => setCurrentIndex(i => Math.min(i + 1, images.length - 1)),\n    onSwipeRight: () => setCurrentIndex(i => Math.max(i - 1, 0)),\n    threshold: 75,  // Require more deliberate swipes\n  });\n\n  return (\n    <div\n      onTouchStart={handleTouchStart}\n      onTouchEnd={handleTouchEnd}\n    >\n      <img src={images[currentIndex]} alt="" />\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key patterns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only fires when threshold exceeded (prevents accidental triggers)"}),"\n",(0,r.jsx)(n.li,{children:"Primary direction detection (no diagonal confusion)"}),"\n",(0,r.jsx)(n.li,{children:"Optional callbacks for each direction"}),"\n",(0,r.jsx)(n.li,{children:"Refs for touch state (no re-renders during gesture)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"usepulltorefresh-hook",children:"usePullToRefresh Hook"}),"\n",(0,r.jsx)(n.p,{children:"Pull-to-refresh with visual feedback and resistance."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// hooks/usePullToRefresh.ts\n'use client';\n\nimport { useState, useRef } from 'react';\n\nexport function usePullToRefresh(onRefresh: () => Promise<void>) {\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [pullDistance, setPullDistance] = useState(0);\n  const startY = useRef<number | null>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const threshold = 80;  // Pixels to pull before triggering\n\n  const handleTouchStart = (e: React.TouchEvent) => {\n    // Only start if at top of scroll container\n    if (containerRef.current?.scrollTop === 0) {\n      startY.current = e.touches[0].clientY;\n    }\n  };\n\n  const handleTouchMove = (e: React.TouchEvent) => {\n    if (startY.current === null || isRefreshing) return;\n\n    const currentY = e.touches[0].clientY;\n    const distance = Math.max(0, currentY - startY.current);\n\n    // Apply resistance (0.5x) and cap at 120px\n    setPullDistance(Math.min(distance * 0.5, 120));\n  };\n\n  const handleTouchEnd = async () => {\n    if (pullDistance >= threshold && !isRefreshing) {\n      setIsRefreshing(true);\n      await onRefresh();\n      setIsRefreshing(false);\n    }\n    setPullDistance(0);\n    startY.current = null;\n  };\n\n  return {\n    containerRef,\n    pullDistance,\n    isRefreshing,\n    handlers: {\n      onTouchStart: handleTouchStart,\n      onTouchMove: handleTouchMove,\n      onTouchEnd: handleTouchEnd,\n    },\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usage-with-visual-indicator",children:"Usage with Visual Indicator"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'function RefreshableList({ items, onRefresh }) {\n  const { containerRef, pullDistance, isRefreshing, handlers } =\n    usePullToRefresh(onRefresh);\n\n  return (\n    <div\n      ref={containerRef}\n      {...handlers}\n      className="h-full overflow-y-auto"\n    >\n      {/* Pull indicator */}\n      <div\n        className="flex justify-center items-center overflow-hidden transition-all"\n        style={{ height: pullDistance }}\n      >\n        {isRefreshing ? (\n          <Spinner className="w-6 h-6 animate-spin" />\n        ) : (\n          <ArrowDown\n            className="w-6 h-6 transition-transform"\n            style={{\n              transform: `rotate(${Math.min(pullDistance / threshold, 1) * 180}deg)`\n            }}\n          />\n        )}\n      </div>\n\n      {/* Content */}\n      {items.map(item => <ItemCard key={item.id} item={item} />)}\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key patterns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only activates at scroll top (doesn't hijack normal scrolling)"}),"\n",(0,r.jsx)(n.li,{children:"0.5x resistance feels natural (not 1:1 with finger movement)"}),"\n",(0,r.jsx)(n.li,{children:"120px cap prevents over-pull"}),"\n",(0,r.jsx)(n.li,{children:"Arrow rotates as progress indicator"}),"\n",(0,r.jsx)(n.li,{children:"Async refresh with loading state"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);