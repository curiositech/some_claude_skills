"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[56632],{20551:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"skills/background_job_orchestrator/references/bullmq-patterns","title":"Advanced BullMQ Patterns","description":"Production patterns for complex job orchestration with BullMQ.","source":"@site/docs/skills/background_job_orchestrator/references/bullmq-patterns.md","sourceDirName":"skills/background_job_orchestrator/references","slug":"/skills/background_job_orchestrator/references/bullmq-patterns","permalink":"/docs/skills/background_job_orchestrator/references/bullmq-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Advanced BullMQ Patterns","sidebar_label":"Advanced BullMQ Patterns","sidebar_position":1}}');var s=r(74848),i=r(28453);const o={title:"Advanced BullMQ Patterns",sidebar_label:"Advanced BullMQ Patterns",sidebar_position:1},a="Advanced BullMQ Patterns",l={},d=[{value:"Pattern 1: Job Chaining (Sequential Workflows)",id:"pattern-1-job-chaining-sequential-workflows",level:2},{value:"Pattern 2: Fan-Out/Fan-In",id:"pattern-2-fan-outfan-in",level:2},{value:"Pattern 3: Rate-Limited API Calls",id:"pattern-3-rate-limited-api-calls",level:2},{value:"Pattern 4: Priority Queues",id:"pattern-4-priority-queues",level:2},{value:"Pattern 5: Delayed Jobs",id:"pattern-5-delayed-jobs",level:2},{value:"Pattern 6: Repeatable Jobs (Cron)",id:"pattern-6-repeatable-jobs-cron",level:2},{value:"Pattern 7: Job Progress Tracking",id:"pattern-7-job-progress-tracking",level:2},{value:"Pattern 8: Conditional Job Execution",id:"pattern-8-conditional-job-execution",level:2},{value:"Pattern 9: Graceful Shutdown",id:"pattern-9-graceful-shutdown",level:2},{value:"Pattern 10: Dead Letter Queue Recovery",id:"pattern-10-dead-letter-queue-recovery",level:2},{value:"Production Checklist",id:"production-checklist",level:2},{value:"Performance Tips",id:"performance-tips",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"advanced-bullmq-patterns",children:"Advanced BullMQ Patterns"})}),"\n",(0,s.jsx)(n.p,{children:"Production patterns for complex job orchestration with BullMQ."}),"\n",(0,s.jsx)(n.h2,{id:"pattern-1-job-chaining-sequential-workflows",children:"Pattern 1: Job Chaining (Sequential Workflows)"}),"\n",(0,s.jsx)(n.p,{children:"Execute jobs in sequence, passing results between steps."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Parent job spawns child jobs\nawait queue.add('process-order', {\n  orderId: 123\n}, {\n  attempts: 3\n});\n\nworker.process('process-order', async (job) => {\n  const { orderId } = job.data;\n\n  // Step 1: Validate inventory\n  const inventoryJob = await queue.add('check-inventory', {\n    orderId\n  }, {\n    parent: {\n      id: job.id,\n      queue: job.queueName\n    }\n  });\n\n  await inventoryJob.waitUntilFinished(queueEvents);\n\n  // Step 2: Charge payment\n  const paymentJob = await queue.add('charge-payment', {\n    orderId\n  }, {\n    parent: {\n      id: job.id,\n      queue: job.queueName\n    }\n  });\n\n  await paymentJob.waitUntilFinished(queueEvents);\n\n  // Step 3: Ship order\n  return await queue.add('ship-order', {\n    orderId\n  }, {\n    parent: {\n      id: job.id,\n      queue: job.queueName\n    }\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-2-fan-outfan-in",children:"Pattern 2: Fan-Out/Fan-In"}),"\n",(0,s.jsx)(n.p,{children:"Process multiple jobs in parallel, then aggregate results."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Fan-out: Create parallel jobs\nconst userIds = [1, 2, 3, 4, 5];\n\nconst jobs = await Promise.all(\n  userIds.map(userId =>\n    queue.add('send-notification', {\n      userId\n    }, {\n      parent: { id: 'batch-123', queue: 'aggregator' }\n    })\n  )\n);\n\n// Fan-in: Aggregate when all complete\nconst aggregatorWorker = new Worker('aggregator', async (job) => {\n  const children = await job.getChildrenValues();\n\n  const successCount = Object.values(children).filter(\n    r => r.status === 'sent'\n  ).length;\n\n  console.log(`Sent ${successCount}/${userIds.length} notifications`);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-3-rate-limited-api-calls",children:"Pattern 3: Rate-Limited API Calls"}),"\n",(0,s.jsx)(n.p,{children:"Respect third-party API rate limits."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Configure rate limiter\nconst apiQueue = new Queue('external-api', {\n  connection,\n  limiter: {\n    max: 100,        // Max 100 requests\n    duration: 60000, // Per 60 seconds\n    groupKey: 'apiKey' // Rate limit per API key\n  }\n});\n\n// Group jobs by API key\nawait apiQueue.add('fetch-data', {\n  endpoint: '/users',\n  apiKey: 'key123'\n}, {\n  rateLimiter: {\n    groupKey: 'key123' // This key gets 100 req/min\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-4-priority-queues",children:"Pattern 4: Priority Queues"}),"\n",(0,s.jsx)(n.p,{children:"Process high-priority jobs first."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Add jobs with priority (lower number = higher priority)\nawait queue.add('send-email', {\n  to: 'premium@user.com'\n}, {\n  priority: 1  // Premium users\n});\n\nawait queue.add('send-email', {\n  to: 'free@user.com'\n}, {\n  priority: 10  // Free users\n});\n\n// Worker processes priority 1 jobs before priority 10\nconst worker = new Worker('email-queue', processEmail, {\n  connection,\n  concurrency: 5\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-5-delayed-jobs",children:"Pattern 5: Delayed Jobs"}),"\n",(0,s.jsx)(n.p,{children:"Schedule jobs for future execution."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Send reminder email in 24 hours\nawait queue.add('send-reminder', {\n  userId: 123\n}, {\n  delay: 24 * 60 * 60 * 1000 // 24 hours in ms\n});\n\n// Or: Specific timestamp\nconst scheduledTime = new Date('2026-01-15T09:00:00Z');\nawait queue.add('daily-report', {\n  type: 'sales'\n}, {\n  delay: scheduledTime.getTime() - Date.now()\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-6-repeatable-jobs-cron",children:"Pattern 6: Repeatable Jobs (Cron)"}),"\n",(0,s.jsx)(n.p,{children:"Schedule recurring jobs with cron syntax."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Daily at 9 AM\nawait queue.add('daily-digest', {\n  recipients: ['admin@company.com']\n}, {\n  repeat: {\n    pattern: '0 9 * * *',  // Cron syntax\n    tz: 'America/New_York'\n  }\n});\n\n// Every 15 minutes\nawait queue.add('health-check', {\n  service: 'api'\n}, {\n  repeat: {\n    every: 15 * 60 * 1000 // 15 minutes in ms\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-7-job-progress-tracking",children:"Pattern 7: Job Progress Tracking"}),"\n",(0,s.jsx)(n.p,{children:"Update progress for long-running jobs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"worker.process('video-transcode', async (job) => {\n  const { videoId, formats } = job.data;\n\n  for (let i = 0; i < formats.length; i++) {\n    const progress = ((i + 1) / formats.length) * 100;\n\n    // Update progress\n    await job.updateProgress(progress);\n\n    // Log current step\n    await job.log(`Transcoding ${formats[i]}...`);\n\n    await transcodeVideo(videoId, formats[i]);\n  }\n\n  return { completed: formats.length };\n});\n\n// Client polls progress\nconst job = await queue.getJob(jobId);\nconsole.log(`Progress: ${job.progress}%`);\n\n// Or: Listen to progress events\nqueueEvents.on('progress', ({ jobId, data }) => {\n  console.log(`Job ${jobId}: ${data}%`);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-8-conditional-job-execution",children:"Pattern 8: Conditional Job Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute jobs based on previous results."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"worker.process('process-upload', async (job) => {\n  const { fileUrl } = job.data;\n\n  // Download file\n  const file = await downloadFile(fileUrl);\n\n  // Conditional: Only process if valid\n  if (!isValidFile(file)) {\n    await job.log('Invalid file, skipping processing');\n    return { skipped: true };\n  }\n\n  // Process valid files\n  const result = await processFile(file);\n\n  // Add follow-up job only if needed\n  if (result.needsTranscoding) {\n    await queue.add('transcode', {\n      fileId: result.fileId\n    }, {\n      parent: { id: job.id, queue: job.queueName }\n    });\n  }\n\n  return result;\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-9-graceful-shutdown",children:"Pattern 9: Graceful Shutdown"}),"\n",(0,s.jsx)(n.p,{children:"Handle in-flight jobs during shutdown."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"let isShuttingDown = false;\n\nconst worker = new Worker('email-queue', async (job) => {\n  if (isShuttingDown) {\n    throw new Error('Shutting down, job will be requeued');\n  }\n\n  await processEmail(job.data);\n}, {\n  connection\n});\n\n// Graceful shutdown handler\nprocess.on('SIGTERM', async () => {\n  console.log('Received SIGTERM, shutting down gracefully...');\n\n  isShuttingDown = true;\n\n  // Stop accepting new jobs\n  await worker.pause();\n\n  // Wait for active jobs to complete (max 30 seconds)\n  await worker.close();\n\n  console.log('All jobs completed, exiting');\n  process.exit(0);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pattern-10-dead-letter-queue-recovery",children:"Pattern 10: Dead Letter Queue Recovery"}),"\n",(0,s.jsx)(n.p,{children:"Retry failed jobs with modified data."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get all failed jobs\nconst failedJobs = await queue.getFailed();\n\n// Analyze and retry with fixes\nfor (const job of failedJobs) {\n  const { failedReason } = job;\n\n  if (failedReason.includes('Invalid email')) {\n    // Fix email and retry\n    const fixedEmail = sanitizeEmail(job.data.email);\n\n    await queue.add('send-email', {\n      ...job.data,\n      email: fixedEmail\n    }, {\n      attempts: 1 // Only 1 more attempt\n    });\n\n    // Remove original failed job\n    await job.remove();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"production-checklist",children:"Production Checklist"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u25a1 Dead letter queue monitoring\n\u25a1 Exponential backoff configured\n\u25a1 Job timeouts set appropriately\n\u25a1 Rate limiting for external APIs\n\u25a1 Idempotency keys for critical jobs\n\u25a1 Worker concurrency tuned\n\u25a1 Graceful shutdown implemented\n\u25a1 Queue depth alerts configured\n\u25a1 Failed job inspection workflow\n\u25a1 Redis persistence enabled\n\u25a1 Job data sanitized (no PII in logs)\n\u25a1 Progress tracking for long jobs\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use bulk operations"}),": ",(0,s.jsx)(n.code,{children:"queue.addBulk()"})," is 10x faster than individual ",(0,s.jsx)(n.code,{children:"add()"})," calls"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tune concurrency"}),": Start with ",(0,s.jsx)(n.code,{children:"CPU cores * 2"}),", adjust based on job type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remove completed jobs"}),": Set ",(0,s.jsx)(n.code,{children:"removeOnComplete"})," to prevent Redis bloat"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use priorities sparingly"}),": Too many priority levels hurt performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Partition queues"}),": Separate queues for different job types improves isolation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor Redis memory"}),": Set ",(0,s.jsx)(n.code,{children:"maxmemory-policy"})," to ",(0,s.jsx)(n.code,{children:"allkeys-lru"})," for Redis"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Not handling job failures"}),": Always have dead letter queue inspection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Forgetting idempotency"}),": Jobs can run twice, design for it"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Blocking workers"}),": Don't do synchronous I/O in workers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Not monitoring queue depth"}),": Set up alerts before it's too late"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Over-using repeatable jobs"}),": They create Redis bloat, use sparingly"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(96540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);