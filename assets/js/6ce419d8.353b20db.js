"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[18055],{28453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var t=a(96540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},52746:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"skills/drone_inspection_specialist/references/roof-inspection","title":"Roof Inspection Reference","description":"Damage Detection Pipeline","source":"@site/docs/skills/drone_inspection_specialist/references/roof-inspection.md","sourceDirName":"skills/drone_inspection_specialist/references","slug":"/skills/drone_inspection_specialist/references/roof-inspection","permalink":"/docs/skills/drone_inspection_specialist/references/roof-inspection","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Roof Inspection Reference","sidebar_label":"Roof Inspection Reference","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Insurance & Risk Assessment...","permalink":"/docs/skills/drone_inspection_specialist/references/insurance-risk-assessment"},"next":{"title":"Bot Developer","permalink":"/docs/skills/bot_developer/"}}');var s=a(74848),i=a(28453);const o={title:"Roof Inspection Reference",sidebar_label:"Roof Inspection Reference",sidebar_position:4},r="Roof Inspection Reference",l={},m=[{value:"Damage Detection Pipeline",id:"damage-detection-pipeline",level:2},{value:"Thermal Roof Analysis",id:"thermal-roof-analysis",level:2},{value:"Material Classification",id:"material-classification",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"roof-inspection-reference",children:"Roof Inspection Reference"})}),"\n",(0,s.jsx)(n.h2,{id:"damage-detection-pipeline",children:"Damage Detection Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import cv2\nimport numpy as np\nfrom ultralytics import YOLO\nfrom typing import List, Dict, Tuple, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass DamageType(Enum):\n    MISSING_SHINGLE = \'missing_shingle\'\n    CRACK = \'crack\'\n    WEAR = \'wear\'\n    DEBRIS = \'debris\'\n    MOSS = \'moss\'\n    PONDING = \'ponding\'\n    FLASHING_DAMAGE = \'flashing_damage\'\n    GUTTER_DAMAGE = \'gutter_damage\'\n\nclass SeverityLevel(Enum):\n    LOW = \'low\'\n    MEDIUM = \'medium\'\n    HIGH = \'high\'\n    CRITICAL = \'critical\'\n\n\n@dataclass\nclass RoofDamage:\n    damage_type: DamageType\n    severity: SeverityLevel\n    confidence: float\n    bbox: Tuple[int, int, int, int]\n    gps_coords: Optional[Tuple[float, float]] = None\n    image_id: int = 0\n    area_sqft: Optional[float] = None\n    repair_cost_estimate: Optional[Tuple[float, float]] = None\n\n\nclass RoofInspector:\n    """\n    Comprehensive roof inspection using drone imagery.\n    Detects damage, estimates severity, generates repair estimates.\n    """\n    def __init__(self, damage_model_path: str = \'roof_damage_yolov8.pt\',\n                 segment_model_path: str = \'roof_segmentation.pt\',\n                 device: str = \'cuda\'):\n        self.damage_model = YOLO(damage_model_path)\n        self.damage_model.to(device)\n\n        self.segment_model = YOLO(segment_model_path)\n        self.segment_model.to(device)\n\n        # Damage class mapping\n        self.class_map = {\n            0: DamageType.MISSING_SHINGLE,\n            1: DamageType.CRACK,\n            2: DamageType.WEAR,\n            3: DamageType.DEBRIS,\n            4: DamageType.MOSS,\n            5: DamageType.PONDING,\n            6: DamageType.FLASHING_DAMAGE,\n            7: DamageType.GUTTER_DAMAGE\n        }\n\n        # Repair cost estimates (USD per sq ft)\n        self.repair_costs = {\n            DamageType.MISSING_SHINGLE: (5, 15),\n            DamageType.CRACK: (10, 25),\n            DamageType.WEAR: (3, 10),\n            DamageType.DEBRIS: (1, 3),\n            DamageType.MOSS: (2, 5),\n            DamageType.PONDING: (15, 40),\n            DamageType.FLASHING_DAMAGE: (20, 50),\n            DamageType.GUTTER_DAMAGE: (10, 30)\n        }\n\n    def inspect_roof(self, image_sequence: List[np.ndarray],\n                     gps_data: List[Tuple[float, float, float]],\n                     altitude: float = 30.0) -> Dict:\n        """\n        Full roof inspection from drone image sequence.\n\n        Args:\n            image_sequence: List of BGR images\n            gps_data: List of (lat, lon, alt) for each image\n            altitude: Average flight altitude for scale calculation\n\n        Returns:\n            Inspection report with damages and recommendations\n        """\n        all_damages = []\n\n        for idx, (img, gps) in enumerate(zip(image_sequence, gps_data)):\n            # Segment roof area\n            roof_mask = self._segment_roof(img)\n\n            # Detect damages\n            damages = self._detect_damages(img, roof_mask, idx)\n\n            # Add GPS coordinates\n            for damage in damages:\n                damage.gps_coords = self._pixel_to_gps(\n                    damage.bbox, img.shape, gps, altitude\n                )\n\n            all_damages.extend(damages)\n\n        # Deduplicate overlapping detections\n        all_damages = self._deduplicate_damages(all_damages)\n\n        # Generate report\n        report = self._generate_report(all_damages, image_sequence)\n\n        return report\n\n    def _segment_roof(self, image: np.ndarray) -> np.ndarray:\n        """Segment roof area from image"""\n        results = self.segment_model(image, verbose=False)[0]\n\n        if results.masks is not None:\n            # Combine all roof segment masks\n            mask = np.zeros(image.shape[:2], dtype=np.uint8)\n            for m in results.masks.data:\n                mask |= m.cpu().numpy().astype(np.uint8)\n            return mask\n\n        # Fallback: assume entire image is roof\n        return np.ones(image.shape[:2], dtype=np.uint8)\n\n    def _detect_damages(self, image: np.ndarray,\n                        roof_mask: np.ndarray, image_id: int) -> List[RoofDamage]:\n        """Detect damages within roof area"""\n        results = self.damage_model(image, conf=0.4, verbose=False)[0]\n\n        damages = []\n        for box in results.boxes:\n            x1, y1, x2, y2 = map(int, box.xyxy[0].cpu().numpy())\n            class_id = int(box.cls[0].item())\n            confidence = float(box.conf[0].item())\n\n            # Check if detection is within roof area\n            center_x = (x1 + x2) // 2\n            center_y = (y1 + y2) // 2\n            if roof_mask[center_y, center_x] == 0:\n                continue  # Skip detections outside roof\n\n            damage_type = self.class_map.get(class_id, DamageType.WEAR)\n            severity = self._assess_severity(damage_type, image[y1:y2, x1:x2])\n\n            damage = RoofDamage(\n                damage_type=damage_type,\n                severity=severity,\n                confidence=confidence,\n                bbox=(x1, y1, x2, y2),\n                image_id=image_id\n            )\n            damages.append(damage)\n\n        return damages\n\n    def _assess_severity(self, damage_type: DamageType,\n                         damage_region: np.ndarray) -> SeverityLevel:\n        """Assess damage severity based on type and visual analysis"""\n        area = damage_region.shape[0] * damage_region.shape[1]\n\n        if damage_type == DamageType.MISSING_SHINGLE:\n            return SeverityLevel.HIGH  # Always high - water can enter\n\n        elif damage_type == DamageType.CRACK:\n            # Larger cracks are more severe\n            if area > 5000:\n                return SeverityLevel.CRITICAL\n            elif area > 2000:\n                return SeverityLevel.HIGH\n            else:\n                return SeverityLevel.MEDIUM\n\n        elif damage_type == DamageType.WEAR:\n            # Analyze darkness (more wear = darker)\n            gray = cv2.cvtColor(damage_region, cv2.COLOR_BGR2GRAY) if len(damage_region.shape) == 3 else damage_region\n            mean_brightness = np.mean(gray) / 255\n            if mean_brightness < 0.3:\n                return SeverityLevel.HIGH\n            elif mean_brightness < 0.5:\n                return SeverityLevel.MEDIUM\n            return SeverityLevel.LOW\n\n        elif damage_type == DamageType.PONDING:\n            return SeverityLevel.HIGH  # Standing water is always concerning\n\n        elif damage_type in [DamageType.DEBRIS, DamageType.MOSS]:\n            if area > 10000:\n                return SeverityLevel.MEDIUM\n            return SeverityLevel.LOW\n\n        return SeverityLevel.MEDIUM\n\n    def _pixel_to_gps(self, bbox: Tuple, img_shape: Tuple,\n                      drone_gps: Tuple[float, float, float],\n                      altitude: float) -> Tuple[float, float]:\n        """Convert pixel coordinates to GPS (simplified)"""\n        img_h, img_w = img_shape[:2]\n        lat, lon, _ = drone_gps\n\n        # Approximate ground coverage (assuming nadir shot)\n        # Typical drone camera: 84\xb0 FOV diagonal\n        ground_width = 2 * altitude * np.tan(np.radians(42))  # meters\n        ground_height = ground_width * img_h / img_w\n\n        # Pixel center\n        cx = (bbox[0] + bbox[2]) / 2\n        cy = (bbox[1] + bbox[3]) / 2\n\n        # Offset from image center\n        dx = (cx - img_w/2) / img_w * ground_width\n        dy = (cy - img_h/2) / img_h * ground_height\n\n        # Convert to GPS offset (rough)\n        dlat = -dy / 111000  # North is up in image\n        dlon = dx / (111000 * np.cos(np.radians(lat)))\n\n        return (lat + dlat, lon + dlon)\n\n    def _deduplicate_damages(self, damages: List[RoofDamage]) -> List[RoofDamage]:\n        """Remove duplicate detections of same damage from different images"""\n        if not damages:\n            return []\n\n        # Sort by confidence\n        damages = sorted(damages, key=lambda d: d.confidence, reverse=True)\n\n        unique = []\n        for damage in damages:\n            is_duplicate = False\n            for existing in unique:\n                if damage.gps_coords and existing.gps_coords:\n                    dist = self._gps_distance(damage.gps_coords, existing.gps_coords)\n                    if dist < 1.0 and damage.damage_type == existing.damage_type:\n                        is_duplicate = True\n                        break\n            if not is_duplicate:\n                unique.append(damage)\n\n        return unique\n\n    def _gps_distance(self, coord1: Tuple, coord2: Tuple) -> float:\n        """Distance between GPS coordinates in meters"""\n        lat1, lon1 = coord1\n        lat2, lon2 = coord2\n        dlat = (lat2 - lat1) * 111000\n        dlon = (lon2 - lon1) * 111000 * np.cos(np.radians(lat1))\n        return np.sqrt(dlat**2 + dlon**2)\n\n    def _generate_report(self, damages: List[RoofDamage],\n                         images: List[np.ndarray]) -> Dict:\n        """Generate comprehensive inspection report"""\n        # Count by type and severity\n        damage_summary = {}\n        for damage in damages:\n            key = (damage.damage_type.value, damage.severity.value)\n            damage_summary[key] = damage_summary.get(key, 0) + 1\n\n        # Calculate repair estimates\n        total_cost_low = 0\n        total_cost_high = 0\n        for damage in damages:\n            cost_range = self.repair_costs.get(damage.damage_type, (5, 15))\n            # Assume average damage is 2 sq ft\n            total_cost_low += cost_range[0] * 2\n            total_cost_high += cost_range[1] * 2\n\n        # Overall condition rating\n        critical_count = sum(1 for d in damages if d.severity == SeverityLevel.CRITICAL)\n        high_count = sum(1 for d in damages if d.severity == SeverityLevel.HIGH)\n\n        if critical_count > 0:\n            condition = \'POOR - Immediate attention required\'\n        elif high_count > 2:\n            condition = \'FAIR - Repairs recommended within 3 months\'\n        elif high_count > 0:\n            condition = \'GOOD - Minor repairs needed\'\n        else:\n            condition = \'EXCELLENT - No significant issues\'\n\n        return {\n            \'total_damages\': len(damages),\n            \'damage_summary\': damage_summary,\n            \'damages\': [\n                {\n                    \'type\': d.damage_type.value,\n                    \'severity\': d.severity.value,\n                    \'confidence\': d.confidence,\n                    \'location\': d.gps_coords\n                }\n                for d in damages\n            ],\n            \'repair_cost_estimate\': {\n                \'low\': total_cost_low,\n                \'high\': total_cost_high,\n                \'currency\': \'USD\'\n            },\n            \'overall_condition\': condition,\n            \'images_analyzed\': len(images),\n            \'recommendations\': self._get_recommendations(damages)\n        }\n\n    def _get_recommendations(self, damages: List[RoofDamage]) -> List[str]:\n        """Generate actionable recommendations"""\n        recs = []\n\n        damage_types = set(d.damage_type for d in damages)\n\n        if DamageType.MISSING_SHINGLE in damage_types:\n            recs.append("Replace missing shingles immediately to prevent water damage")\n\n        if DamageType.CRACK in damage_types:\n            recs.append("Seal cracks with roofing cement or schedule professional repair")\n\n        if DamageType.PONDING in damage_types:\n            recs.append("Address drainage issues causing water ponding")\n\n        if DamageType.MOSS in damage_types:\n            recs.append("Apply moss killer and consider zinc strips for prevention")\n\n        if DamageType.FLASHING_DAMAGE in damage_types:\n            recs.append("Reseal or replace damaged flashing around vents and chimneys")\n\n        if not recs:\n            recs.append("Continue regular maintenance and annual inspections")\n\n        return recs\n'})}),"\n",(0,s.jsx)(n.h2,{id:"thermal-roof-analysis",children:"Thermal Roof Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import cv2\nimport numpy as np\nfrom typing import List, Dict, Tuple\nfrom dataclasses import dataclass\n\n@dataclass\nclass ThermalAnomaly:\n    anomaly_type: str  # 'moisture', 'insulation_loss', 'hvac_leak', 'electrical'\n    severity: str\n    bbox: Tuple[int, int, int, int]\n    temp_delta: float  # Temperature difference from surrounding\n    avg_temp: float\n\n\nclass ThermalRoofAnalyzer:\n    \"\"\"\n    Thermal analysis for roof inspection.\n    Detects moisture, insulation issues, and HVAC problems.\n    \"\"\"\n    def __init__(self):\n        self.moisture_threshold = -5.0  # Degrees colder than average\n        self.insulation_threshold = 3.0  # Degrees warmer than average\n        self.hvac_threshold = 8.0  # Significant heat anomaly\n\n    def analyze(self, thermal_frame: np.ndarray,\n                rgb_frame: Optional[np.ndarray] = None) -> List[ThermalAnomaly]:\n        \"\"\"\n        Analyze thermal image for roof anomalies.\n\n        Args:\n            thermal_frame: Temperature array in Celsius\n            rgb_frame: Optional RGB image for context\n\n        Returns:\n            List of detected anomalies\n        \"\"\"\n        anomalies = []\n\n        # Calculate baseline statistics\n        mean_temp = np.mean(thermal_frame)\n        std_temp = np.std(thermal_frame)\n\n        # Detect cold spots (potential moisture)\n        cold_anomalies = self._detect_cold_spots(thermal_frame, mean_temp, std_temp)\n        anomalies.extend(cold_anomalies)\n\n        # Detect hot spots (insulation/HVAC issues)\n        hot_anomalies = self._detect_hot_spots(thermal_frame, mean_temp, std_temp)\n        anomalies.extend(hot_anomalies)\n\n        return anomalies\n\n    def _detect_cold_spots(self, thermal: np.ndarray,\n                           mean_temp: float, std_temp: float) -> List[ThermalAnomaly]:\n        \"\"\"Detect moisture or missing insulation (cold spots)\"\"\"\n        threshold = mean_temp + self.moisture_threshold\n\n        cold_mask = (thermal < threshold).astype(np.uint8)\n\n        # Morphological cleanup\n        kernel = np.ones((5, 5), np.uint8)\n        cold_mask = cv2.morphologyEx(cold_mask, cv2.MORPH_OPEN, kernel)\n        cold_mask = cv2.morphologyEx(cold_mask, cv2.MORPH_CLOSE, kernel)\n\n        contours, _ = cv2.findContours(cold_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        anomalies = []\n        for contour in contours:\n            area = cv2.contourArea(contour)\n            if area < 500:  # Min area threshold\n                continue\n\n            x, y, w, h = cv2.boundingRect(contour)\n            region_temp = thermal[y:y+h, x:x+w]\n            avg_temp = float(np.mean(region_temp))\n            temp_delta = avg_temp - mean_temp\n\n            severity = 'high' if temp_delta < -8 else 'medium' if temp_delta < -5 else 'low'\n\n            anomaly = ThermalAnomaly(\n                anomaly_type='moisture' if temp_delta < -6 else 'insulation_loss',\n                severity=severity,\n                bbox=(x, y, x+w, y+h),\n                temp_delta=temp_delta,\n                avg_temp=avg_temp\n            )\n            anomalies.append(anomaly)\n\n        return anomalies\n\n    def _detect_hot_spots(self, thermal: np.ndarray,\n                          mean_temp: float, std_temp: float) -> List[ThermalAnomaly]:\n        \"\"\"Detect heat buildup or HVAC leaks\"\"\"\n        threshold = mean_temp + self.insulation_threshold\n\n        hot_mask = (thermal > threshold).astype(np.uint8)\n\n        # Morphological cleanup\n        kernel = np.ones((5, 5), np.uint8)\n        hot_mask = cv2.morphologyEx(hot_mask, cv2.MORPH_OPEN, kernel)\n\n        contours, _ = cv2.findContours(hot_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        anomalies = []\n        for contour in contours:\n            area = cv2.contourArea(contour)\n            if area < 500:\n                continue\n\n            x, y, w, h = cv2.boundingRect(contour)\n            region_temp = thermal[y:y+h, x:x+w]\n            avg_temp = float(np.mean(region_temp))\n            max_temp = float(np.max(region_temp))\n            temp_delta = avg_temp - mean_temp\n\n            # Classify type based on characteristics\n            if temp_delta > self.hvac_threshold:\n                anomaly_type = 'hvac_leak'\n                severity = 'high'\n            elif max_temp > mean_temp + 15:\n                anomaly_type = 'electrical'  # Potential electrical issue\n                severity = 'critical'\n            else:\n                anomaly_type = 'insulation_loss'\n                severity = 'medium' if temp_delta > 5 else 'low'\n\n            anomaly = ThermalAnomaly(\n                anomaly_type=anomaly_type,\n                severity=severity,\n                bbox=(x, y, x+w, y+h),\n                temp_delta=temp_delta,\n                avg_temp=avg_temp\n            )\n            anomalies.append(anomaly)\n\n        return anomalies\n\n    def generate_thermal_report(self, anomalies: List[ThermalAnomaly]) -> Dict:\n        \"\"\"Generate thermal inspection report\"\"\"\n        if not anomalies:\n            return {\n                'status': 'pass',\n                'message': 'No significant thermal anomalies detected',\n                'anomalies': []\n            }\n\n        critical = [a for a in anomalies if a.severity == 'critical']\n        high = [a for a in anomalies if a.severity == 'high']\n\n        recommendations = []\n        if any(a.anomaly_type == 'moisture' for a in anomalies):\n            recommendations.append(\"Investigate potential moisture infiltration\")\n        if any(a.anomaly_type == 'hvac_leak' for a in anomalies):\n            recommendations.append(\"Check HVAC system for leaks\")\n        if any(a.anomaly_type == 'electrical' for a in anomalies):\n            recommendations.append(\"URGENT: Have electrician inspect hot spots\")\n\n        return {\n            'status': 'fail' if critical else 'warning' if high else 'minor_issues',\n            'total_anomalies': len(anomalies),\n            'critical_count': len(critical),\n            'high_count': len(high),\n            'anomalies': [\n                {\n                    'type': a.anomaly_type,\n                    'severity': a.severity,\n                    'temp_delta': a.temp_delta,\n                    'location': a.bbox\n                }\n                for a in anomalies\n            ],\n            'recommendations': recommendations\n        }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"material-classification",children:"Material Classification"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import torch\nimport numpy as np\nfrom typing import List, Dict, Tuple\nfrom ultralytics import YOLO\n\nclass RoofMaterialClassifier:\n    \"\"\"\n    Classify roofing materials from aerial imagery.\n    Important for accurate repair cost estimation.\n    \"\"\"\n    MATERIALS = [\n        'asphalt_shingle',\n        'metal_standing_seam',\n        'metal_corrugated',\n        'clay_tile',\n        'concrete_tile',\n        'slate',\n        'wood_shake',\n        'flat_membrane',\n        'solar_panel'\n    ]\n\n    COST_PER_SQFT = {\n        'asphalt_shingle': (3, 7),\n        'metal_standing_seam': (8, 14),\n        'metal_corrugated': (5, 10),\n        'clay_tile': (10, 18),\n        'concrete_tile': (8, 12),\n        'slate': (15, 30),\n        'wood_shake': (6, 12),\n        'flat_membrane': (4, 8),\n        'solar_panel': (0, 0)  # Special handling\n    }\n\n    def __init__(self, model_path: str = 'roof_material_classifier.pt'):\n        self.model = YOLO(model_path)\n\n    def classify(self, image: np.ndarray) -> Dict:\n        \"\"\"\n        Classify roofing material from image.\n\n        Returns:\n            Material type and confidence\n        \"\"\"\n        results = self.model(image, verbose=False)[0]\n\n        if results.probs is not None:\n            probs = results.probs.data.cpu().numpy()\n            top_idx = np.argmax(probs)\n            return {\n                'material': self.MATERIALS[top_idx],\n                'confidence': float(probs[top_idx]),\n                'all_probabilities': {\n                    self.MATERIALS[i]: float(probs[i])\n                    for i in range(len(self.MATERIALS))\n                }\n            }\n\n        return {'material': 'unknown', 'confidence': 0.0}\n\n    def estimate_replacement_cost(self, material: str,\n                                   area_sqft: float) -> Dict:\n        \"\"\"Estimate full roof replacement cost\"\"\"\n        if material not in self.COST_PER_SQFT:\n            material = 'asphalt_shingle'  # Default\n\n        cost_low, cost_high = self.COST_PER_SQFT[material]\n\n        return {\n            'material': material,\n            'area_sqft': area_sqft,\n            'cost_per_sqft': {'low': cost_low, 'high': cost_high},\n            'total_cost': {\n                'low': cost_low * area_sqft,\n                'high': cost_high * area_sqft\n            },\n            'note': 'Estimate only. Get professional quotes for accurate pricing.'\n        }\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);