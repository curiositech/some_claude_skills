"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3889],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},43453:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"skills/drone_inspection_specialist/references/insurance-risk-assessment","title":"Insurance & Risk Assessment Reference","description":"Hail Damage Detection System","source":"@site/docs/skills/drone_inspection_specialist/references/insurance-risk-assessment.md","sourceDirName":"skills/drone_inspection_specialist/references","slug":"/skills/drone_inspection_specialist/references/insurance-risk-assessment","permalink":"/docs/skills/drone_inspection_specialist/references/insurance-risk-assessment","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Insurance & Risk Assessment Reference","sidebar_label":"Insurance & Risk Assessment...","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Gaussian Splatting 3D Recon...","permalink":"/docs/skills/drone_inspection_specialist/references/gaussian-splatting-3d"},"next":{"title":"Roof Inspection Reference","permalink":"/docs/skills/drone_inspection_specialist/references/roof-inspection"}}');var s=t(74848),i=t(28453);const r={title:"Insurance & Risk Assessment Reference",sidebar_label:"Insurance & Risk Assessment...",sidebar_position:3},o="Insurance & Risk Assessment Reference",l={},c=[{value:"Hail Damage Detection System",id:"hail-damage-detection-system",level:2},{value:"Wildfire Risk Assessment",id:"wildfire-risk-assessment",level:2},{value:"Satellite &amp; Aerial Data Integration",id:"satellite--aerial-data-integration",level:2},{value:"Reinsurance Risk Modeling",id:"reinsurance-risk-modeling",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"insurance--risk-assessment-reference",children:"Insurance & Risk Assessment Reference"})}),"\n",(0,s.jsx)(n.h2,{id:"hail-damage-detection-system",children:"Hail Damage Detection System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import cv2\nimport numpy as np\nfrom ultralytics import YOLO\nfrom typing import List, Dict, Tuple, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport datetime\n\nclass HailDamageType(Enum):\n    DENT = 'dent'                    # Impact dent on metal/shingle\n    CRACK = 'crack'                  # Impact crack\n    GRANULE_LOSS = 'granule_loss'    # Asphalt shingle granule displacement\n    BRUISE = 'bruise'                # Soft spot from impact\n    PUNCTURE = 'puncture'            # Complete penetration\n\nclass DamagePattern(Enum):\n    RANDOM = 'random'                # True hail pattern (random distribution)\n    LINEAR = 'linear'                # Foot traffic or other cause\n    CLUSTERED = 'clustered'          # Localized damage\n    AGE_RELATED = 'age_related'      # Wear, not hail\n\n\n@dataclass\nclass HailImpact:\n    damage_type: HailDamageType\n    diameter_mm: float              # Estimated impact diameter\n    confidence: float\n    bbox: Tuple[int, int, int, int]\n    severity_score: float           # 0-1 scale\n\n\nclass HailDamageDetector:\n    \"\"\"\n    Detect and classify hail damage on roofing materials.\n    Critical for insurance claims validation.\n    \"\"\"\n    def __init__(self, model_path: str = 'hail_damage_yolov8.pt'):\n        self.model = YOLO(model_path)\n\n        # Hail size categories (diameter in mm)\n        self.hail_categories = {\n            'pea': (6, 10),\n            'marble': (10, 15),\n            'quarter': (25, 30),\n            'golf_ball': (40, 45),\n            'tennis_ball': (65, 70),\n            'softball': (100, 115)\n        }\n\n    def detect_hail_damage(self, image: np.ndarray,\n                           pixels_per_mm: float = 2.0) -> Dict:\n        \"\"\"\n        Detect hail damage and estimate hail size.\n\n        Args:\n            image: BGR image of roof surface\n            pixels_per_mm: Scale factor (depends on altitude and camera)\n\n        Returns:\n            Analysis with damage count, pattern, and hail size estimate\n        \"\"\"\n        results = self.model(image, conf=0.3, verbose=False)[0]\n\n        impacts = []\n        for box in results.boxes:\n            x1, y1, x2, y2 = map(int, box.xyxy[0].cpu().numpy())\n            class_id = int(box.cls[0].item())\n            confidence = float(box.conf[0].item())\n\n            # Estimate impact diameter\n            width_px = x2 - x1\n            height_px = y2 - y1\n            diameter_px = (width_px + height_px) / 2\n            diameter_mm = diameter_px / pixels_per_mm\n\n            impact = HailImpact(\n                damage_type=self._classify_damage(class_id),\n                diameter_mm=diameter_mm,\n                confidence=confidence,\n                bbox=(x1, y1, x2, y2),\n                severity_score=self._calculate_severity(diameter_mm, class_id)\n            )\n            impacts.append(impact)\n\n        # Analyze pattern\n        pattern = self._analyze_pattern(impacts, image.shape)\n\n        # Estimate hail size from impacts\n        hail_size = self._estimate_hail_size(impacts)\n\n        return {\n            'total_impacts': len(impacts),\n            'impacts': impacts,\n            'pattern': pattern.value,\n            'is_consistent_with_hail': pattern == DamagePattern.RANDOM,\n            'estimated_hail_size': hail_size,\n            'damage_density': len(impacts) / (image.shape[0] * image.shape[1]) * 1e6,\n            'recommended_action': self._get_recommendation(impacts, pattern)\n        }\n\n    def _classify_damage(self, class_id: int) -> HailDamageType:\n        mapping = {\n            0: HailDamageType.DENT,\n            1: HailDamageType.CRACK,\n            2: HailDamageType.GRANULE_LOSS,\n            3: HailDamageType.BRUISE,\n            4: HailDamageType.PUNCTURE\n        }\n        return mapping.get(class_id, HailDamageType.DENT)\n\n    def _calculate_severity(self, diameter_mm: float, class_id: int) -> float:\n        \"\"\"Calculate damage severity score 0-1\"\"\"\n        # Base score from size\n        size_score = min(diameter_mm / 50, 1.0)\n\n        # Damage type multiplier\n        type_multipliers = {0: 0.6, 1: 0.8, 2: 0.5, 3: 0.7, 4: 1.0}\n        type_mult = type_multipliers.get(class_id, 0.5)\n\n        return min(size_score * type_mult * 1.5, 1.0)\n\n    def _analyze_pattern(self, impacts: List[HailImpact],\n                         img_shape: Tuple) -> DamagePattern:\n        \"\"\"Analyze spatial distribution of impacts\"\"\"\n        if len(impacts) < 5:\n            return DamagePattern.CLUSTERED\n\n        # Extract centroids\n        centroids = np.array([\n            ((i.bbox[0] + i.bbox[2])/2, (i.bbox[1] + i.bbox[3])/2)\n            for i in impacts\n        ])\n\n        # Calculate nearest neighbor distances\n        from scipy.spatial import distance_matrix\n        distances = distance_matrix(centroids, centroids)\n        np.fill_diagonal(distances, np.inf)\n        nn_distances = np.min(distances, axis=1)\n\n        # Check for randomness using coefficient of variation\n        cv = np.std(nn_distances) / np.mean(nn_distances)\n\n        # True hail has relatively random distribution\n        if 0.3 < cv < 0.8:\n            return DamagePattern.RANDOM\n\n        # Very uniform spacing suggests artificial\n        if cv < 0.3:\n            return DamagePattern.LINEAR\n\n        return DamagePattern.CLUSTERED\n\n    def _estimate_hail_size(self, impacts: List[HailImpact]) -> Dict:\n        \"\"\"Estimate hail size from impact diameters\"\"\"\n        if not impacts:\n            return {'category': 'unknown', 'diameter_mm': 0}\n\n        diameters = [i.diameter_mm for i in impacts]\n        median_diameter = np.median(diameters)\n        max_diameter = np.max(diameters)\n\n        # Find closest category\n        for name, (min_d, max_d) in self.hail_categories.items():\n            if min_d <= median_diameter <= max_d:\n                return {\n                    'category': name,\n                    'median_diameter_mm': median_diameter,\n                    'max_diameter_mm': max_diameter,\n                    'estimated_impact_force': self._impact_force(median_diameter)\n                }\n\n        return {\n            'category': 'unknown',\n            'median_diameter_mm': median_diameter,\n            'max_diameter_mm': max_diameter\n        }\n\n    def _impact_force(self, diameter_mm: float) -> str:\n        \"\"\"Estimate impact force category\"\"\"\n        if diameter_mm < 15:\n            return 'minimal'\n        elif diameter_mm < 30:\n            return 'moderate'\n        elif diameter_mm < 50:\n            return 'significant'\n        else:\n            return 'severe'\n\n    def _get_recommendation(self, impacts: List[HailImpact],\n                            pattern: DamagePattern) -> str:\n        if not impacts:\n            return \"No damage detected - document current condition\"\n\n        if pattern != DamagePattern.RANDOM:\n            return \"Damage pattern inconsistent with hail - investigate other causes\"\n\n        severe_count = sum(1 for i in impacts if i.severity_score > 0.7)\n        if severe_count > 5:\n            return \"Significant hail damage - recommend full roof replacement claim\"\n        elif severe_count > 0:\n            return \"Moderate hail damage - recommend repair claim\"\n        else:\n            return \"Minor hail damage - monitor and document\"\n\n\nclass InsuranceClaimPackager:\n    \"\"\"\n    Package drone inspection data for insurance claims.\n    Generates documentation meeting industry standards.\n    \"\"\"\n    def __init__(self):\n        self.inspection_date = None\n        self.property_address = None\n        self.policy_number = None\n\n    def generate_claim_package(self, inspection_data: Dict,\n                               property_info: Dict,\n                               weather_data: Optional[Dict] = None) -> Dict:\n        \"\"\"\n        Generate comprehensive claim documentation.\n\n        Args:\n            inspection_data: Output from drone inspection\n            property_info: Property details (address, policy, etc.)\n            weather_data: Historical weather data for event correlation\n\n        Returns:\n            Structured claim package\n        \"\"\"\n        package = {\n            'metadata': {\n                'generated_date': datetime.datetime.now().isoformat(),\n                'inspection_date': inspection_data.get('date'),\n                'inspector': 'Autonomous Drone System',\n                'methodology': 'AI-assisted aerial imagery analysis'\n            },\n            'property': property_info,\n            'damage_assessment': {\n                'total_damage_areas': inspection_data.get('total_impacts', 0),\n                'damage_types': self._summarize_damage_types(inspection_data),\n                'affected_area_sqft': inspection_data.get('affected_area', 0),\n                'severity_rating': self._calculate_severity_rating(inspection_data)\n            },\n            'weather_correlation': None,\n            'cost_estimate': self._estimate_costs(inspection_data, property_info),\n            'supporting_evidence': {\n                'images': inspection_data.get('image_urls', []),\n                'thermal_analysis': inspection_data.get('thermal', {}),\n                'gps_coordinates': inspection_data.get('damage_locations', [])\n            },\n            'recommendations': inspection_data.get('recommendations', [])\n        }\n\n        if weather_data:\n            package['weather_correlation'] = self._correlate_weather(\n                weather_data, inspection_data\n            )\n\n        return package\n\n    def _summarize_damage_types(self, data: Dict) -> Dict:\n        \"\"\"Summarize damage by type\"\"\"\n        impacts = data.get('impacts', [])\n        summary = {}\n        for impact in impacts:\n            dtype = impact.damage_type.value if hasattr(impact, 'damage_type') else str(impact.get('type', 'unknown'))\n            summary[dtype] = summary.get(dtype, 0) + 1\n        return summary\n\n    def _calculate_severity_rating(self, data: Dict) -> str:\n        \"\"\"Calculate overall severity rating\"\"\"\n        impacts = data.get('impacts', [])\n        if not impacts:\n            return 'none'\n\n        avg_severity = np.mean([\n            i.severity_score if hasattr(i, 'severity_score') else 0.5\n            for i in impacts\n        ])\n\n        if avg_severity > 0.7:\n            return 'severe'\n        elif avg_severity > 0.5:\n            return 'moderate'\n        elif avg_severity > 0.3:\n            return 'minor'\n        return 'minimal'\n\n    def _estimate_costs(self, inspection_data: Dict, property_info: Dict) -> Dict:\n        \"\"\"Generate repair/replacement cost estimate\"\"\"\n        roof_area = property_info.get('roof_area_sqft', 2000)\n        material = property_info.get('roof_material', 'asphalt_shingle')\n\n        # Base costs per sq ft\n        costs = {\n            'asphalt_shingle': {'repair': 8, 'replace': 5},\n            'metal': {'repair': 12, 'replace': 10},\n            'tile': {'repair': 15, 'replace': 12},\n            'slate': {'repair': 25, 'replace': 20}\n        }\n\n        base_cost = costs.get(material, costs['asphalt_shingle'])\n        damage_ratio = min(inspection_data.get('damage_density', 0) / 100, 1.0)\n\n        if damage_ratio > 0.3:  # > 30% damage typically means replacement\n            estimated_cost = roof_area * base_cost['replace']\n            action = 'full_replacement'\n        else:\n            estimated_cost = roof_area * damage_ratio * base_cost['repair'] * 1.5\n            action = 'repair'\n\n        return {\n            'recommended_action': action,\n            'estimated_cost_low': estimated_cost * 0.8,\n            'estimated_cost_high': estimated_cost * 1.2,\n            'confidence': 'medium',\n            'note': 'Final costs subject to contractor assessment'\n        }\n\n    def _correlate_weather(self, weather_data: Dict, inspection_data: Dict) -> Dict:\n        \"\"\"Correlate damage with weather events\"\"\"\n        # Look for hail events in the area\n        hail_events = weather_data.get('hail_events', [])\n\n        if not hail_events:\n            return {\n                'correlated_event': None,\n                'correlation_confidence': 'low',\n                'note': 'No recorded hail events in area'\n            }\n\n        # Find most likely event based on timing and severity\n        best_match = None\n        for event in hail_events:\n            if event.get('hail_size_mm', 0) > 20:\n                best_match = event\n                break\n\n        if best_match:\n            return {\n                'correlated_event': best_match,\n                'correlation_confidence': 'high',\n                'event_date': best_match.get('date'),\n                'hail_size': best_match.get('hail_size_mm'),\n                'affected_area': best_match.get('affected_radius_km')\n            }\n\n        return {\n            'correlated_event': None,\n            'correlation_confidence': 'medium',\n            'note': 'Unable to correlate with specific event'\n        }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"wildfire-risk-assessment",children:"Wildfire Risk Assessment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom typing import List, Dict, Tuple, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport json\n\nclass VegetationType(Enum):\n    GRASS = 'grass'\n    BRUSH = 'brush'\n    TIMBER = 'timber'\n    SLASH = 'slash'          # Logging debris\n    CHAPARRAL = 'chaparral'\n\nclass DefensibleSpaceZone(Enum):\n    ZONE_0 = 0    # 0-5 ft: Ember-resistant zone\n    ZONE_1 = 1    # 5-30 ft: Lean, clean, green zone\n    ZONE_2 = 2    # 30-100 ft: Reduced fuel zone\n    ZONE_3 = 3    # 100+ ft: Extended buffer\n\n\n@dataclass\nclass FireRiskFactor:\n    factor_name: str\n    score: float          # 0-1 normalized\n    weight: float         # Importance weight\n    details: Dict\n\n\nclass WildfireRiskAssessor:\n    \"\"\"\n    Assess wildfire risk for properties using drone/satellite data.\n    Based on NFPA 1144 and CAL FIRE defensible space guidelines.\n    \"\"\"\n    def __init__(self):\n        # Risk factor weights (sum to 1)\n        self.weights = {\n            'vegetation_density': 0.20,\n            'vegetation_type': 0.15,\n            'slope': 0.15,\n            'defensible_space': 0.20,\n            'roof_material': 0.10,\n            'structure_spacing': 0.10,\n            'access_egress': 0.10\n        }\n\n    def assess_property_risk(self, property_data: Dict,\n                             drone_imagery: Optional[Dict] = None,\n                             satellite_data: Optional[Dict] = None) -> Dict:\n        \"\"\"\n        Comprehensive wildfire risk assessment.\n\n        Args:\n            property_data: Property characteristics\n            drone_imagery: Analyzed drone imagery data\n            satellite_data: NDVI, fuel load, etc. from satellite\n\n        Returns:\n            Risk assessment with mitigation recommendations\n        \"\"\"\n        risk_factors = []\n\n        # 1. Vegetation analysis\n        veg_risk = self._assess_vegetation(drone_imagery, satellite_data)\n        risk_factors.append(veg_risk)\n\n        # 2. Topography/slope\n        slope_risk = self._assess_slope(property_data)\n        risk_factors.append(slope_risk)\n\n        # 3. Defensible space compliance\n        space_risk = self._assess_defensible_space(drone_imagery, property_data)\n        risk_factors.append(space_risk)\n\n        # 4. Structure vulnerability\n        struct_risk = self._assess_structure(property_data, drone_imagery)\n        risk_factors.append(struct_risk)\n\n        # Calculate overall risk score\n        overall_score = sum(\n            f.score * f.weight for f in risk_factors\n        )\n\n        # Generate risk category\n        if overall_score > 0.7:\n            risk_category = 'EXTREME'\n        elif overall_score > 0.5:\n            risk_category = 'HIGH'\n        elif overall_score > 0.3:\n            risk_category = 'MODERATE'\n        else:\n            risk_category = 'LOW'\n\n        return {\n            'overall_risk_score': overall_score,\n            'risk_category': risk_category,\n            'risk_factors': [\n                {\n                    'name': f.factor_name,\n                    'score': f.score,\n                    'weight': f.weight,\n                    'contribution': f.score * f.weight,\n                    'details': f.details\n                }\n                for f in risk_factors\n            ],\n            'mitigation_recommendations': self._generate_mitigations(risk_factors),\n            'insurance_implications': self._insurance_implications(overall_score, risk_factors),\n            'estimated_mitigation_cost': self._estimate_mitigation_cost(risk_factors)\n        }\n\n    def _assess_vegetation(self, drone_data: Optional[Dict],\n                           satellite_data: Optional[Dict]) -> FireRiskFactor:\n        \"\"\"Assess vegetation-related fire risk\"\"\"\n        if satellite_data:\n            ndvi = satellite_data.get('ndvi', 0.5)\n            fuel_load = satellite_data.get('fuel_load_tons_acre', 10)\n            veg_type = satellite_data.get('dominant_vegetation', 'brush')\n        else:\n            ndvi = 0.5\n            fuel_load = 10\n            veg_type = 'brush'\n\n        # NDVI interpretation (0.2-0.8 typical range)\n        # Higher NDVI = more vegetation = more fuel\n        ndvi_score = min(max((ndvi - 0.2) / 0.6, 0), 1)\n\n        # Fuel load scoring\n        fuel_score = min(fuel_load / 30, 1)  # 30 tons/acre = max risk\n\n        # Vegetation type risk\n        type_scores = {\n            'grass': 0.4,      # Fast spread but low intensity\n            'brush': 0.7,      # High intensity\n            'chaparral': 0.9,  # Very high intensity\n            'timber': 0.6,     # Moderate, depends on undergrowth\n            'slash': 0.8       # Accumulated fuel\n        }\n        type_score = type_scores.get(veg_type, 0.5)\n\n        combined_score = (ndvi_score * 0.3 + fuel_score * 0.4 + type_score * 0.3)\n\n        return FireRiskFactor(\n            factor_name='vegetation',\n            score=combined_score,\n            weight=self.weights['vegetation_density'] + self.weights['vegetation_type'],\n            details={\n                'ndvi': ndvi,\n                'fuel_load_tons_acre': fuel_load,\n                'vegetation_type': veg_type,\n                'ndvi_score': ndvi_score,\n                'fuel_score': fuel_score,\n                'type_score': type_score\n            }\n        )\n\n    def _assess_slope(self, property_data: Dict) -> FireRiskFactor:\n        \"\"\"Assess slope-related risk (fire spreads faster uphill)\"\"\"\n        slope_percent = property_data.get('slope_percent', 0)\n\n        # Slope scoring: &gt;40% is extreme\n        if slope_percent < 10:\n            score = 0.2\n        elif slope_percent < 20:\n            score = 0.4\n        elif slope_percent < 30:\n            score = 0.6\n        elif slope_percent < 40:\n            score = 0.8\n        else:\n            score = 1.0\n\n        return FireRiskFactor(\n            factor_name='slope',\n            score=score,\n            weight=self.weights['slope'],\n            details={\n                'slope_percent': slope_percent,\n                'fire_behavior_note': 'Fire rate of spread doubles every 20% slope increase'\n            }\n        )\n\n    def _assess_defensible_space(self, drone_data: Optional[Dict],\n                                  property_data: Dict) -> FireRiskFactor:\n        \"\"\"Assess defensible space compliance by zone\"\"\"\n        zone_scores = []\n\n        # Zone 0: 0-5 ft (ember-resistant)\n        zone0_clear = property_data.get('zone0_cleared', False)\n        zone_scores.append(0.0 if zone0_clear else 1.0)\n\n        # Zone 1: 5-30 ft (lean, clean, green)\n        zone1_compliance = property_data.get('zone1_compliance', 0.5)\n        zone_scores.append(1.0 - zone1_compliance)\n\n        # Zone 2: 30-100 ft (reduced fuel)\n        zone2_compliance = property_data.get('zone2_compliance', 0.5)\n        zone_scores.append(1.0 - zone2_compliance)\n\n        # Weighted by proximity importance\n        weighted_score = zone_scores[0] * 0.5 + zone_scores[1] * 0.35 + zone_scores[2] * 0.15\n\n        return FireRiskFactor(\n            factor_name='defensible_space',\n            score=weighted_score,\n            weight=self.weights['defensible_space'],\n            details={\n                'zone_0_compliant': zone0_clear,\n                'zone_1_compliance': zone1_compliance,\n                'zone_2_compliance': zone2_compliance,\n                'zone_scores': zone_scores\n            }\n        )\n\n    def _assess_structure(self, property_data: Dict,\n                          drone_data: Optional[Dict]) -> FireRiskFactor:\n        \"\"\"Assess structure vulnerability\"\"\"\n        roof_material = property_data.get('roof_material', 'asphalt_shingle')\n        siding_material = property_data.get('siding_material', 'wood')\n        vents_screened = property_data.get('vents_screened', False)\n        deck_material = property_data.get('deck_material', 'wood')\n\n        # Roof fire rating\n        roof_scores = {\n            'metal': 0.1,\n            'tile': 0.2,\n            'asphalt_shingle_class_a': 0.3,\n            'asphalt_shingle': 0.4,\n            'wood_shake_treated': 0.7,\n            'wood_shake': 1.0\n        }\n        roof_score = roof_scores.get(roof_material, 0.5)\n\n        # Siding vulnerability\n        siding_scores = {\n            'stucco': 0.1,\n            'brick': 0.1,\n            'fiber_cement': 0.2,\n            'vinyl': 0.5,\n            'wood': 0.8\n        }\n        siding_score = siding_scores.get(siding_material, 0.5)\n\n        # Vent protection\n        vent_score = 0.0 if vents_screened else 0.8\n\n        combined = roof_score * 0.4 + siding_score * 0.3 + vent_score * 0.3\n\n        return FireRiskFactor(\n            factor_name='structure_vulnerability',\n            score=combined,\n            weight=self.weights['roof_material'],\n            details={\n                'roof_material': roof_material,\n                'roof_score': roof_score,\n                'siding_material': siding_material,\n                'siding_score': siding_score,\n                'vents_screened': vents_screened\n            }\n        )\n\n    def _generate_mitigations(self, risk_factors: List[FireRiskFactor]) -> List[Dict]:\n        \"\"\"Generate prioritized mitigation recommendations\"\"\"\n        mitigations = []\n\n        # Sort by contribution to risk\n        sorted_factors = sorted(\n            risk_factors,\n            key=lambda f: f.score * f.weight,\n            reverse=True\n        )\n\n        for factor in sorted_factors:\n            if factor.factor_name == 'vegetation' and factor.score > 0.5:\n                mitigations.append({\n                    'priority': 'high',\n                    'action': 'Reduce vegetation density within 100ft',\n                    'estimated_risk_reduction': 0.15,\n                    'cost_range': '$500-$3000'\n                })\n\n            if factor.factor_name == 'defensible_space' and factor.score > 0.5:\n                mitigations.append({\n                    'priority': 'critical',\n                    'action': 'Create compliant defensible space zones',\n                    'estimated_risk_reduction': 0.20,\n                    'cost_range': '$1000-$5000'\n                })\n\n            if factor.factor_name == 'structure_vulnerability' and factor.score > 0.5:\n                if factor.details.get('roof_score', 0) > 0.5:\n                    mitigations.append({\n                        'priority': 'medium',\n                        'action': 'Upgrade to Class A fire-rated roofing',\n                        'estimated_risk_reduction': 0.10,\n                        'cost_range': '$5000-$15000'\n                    })\n                if not factor.details.get('vents_screened', True):\n                    mitigations.append({\n                        'priority': 'high',\n                        'action': 'Install 1/8\" mesh screens on all vents',\n                        'estimated_risk_reduction': 0.08,\n                        'cost_range': '$200-$800'\n                    })\n\n        return mitigations\n\n    def _insurance_implications(self, overall_score: float,\n                                risk_factors: List[FireRiskFactor]) -> Dict:\n        \"\"\"Calculate insurance implications\"\"\"\n        # Premium adjustment factors\n        if overall_score > 0.7:\n            premium_factor = 2.0\n            coverage_note = 'May require high-risk carrier'\n            deductible_note = 'Expect higher deductibles (2-5% of dwelling)'\n        elif overall_score > 0.5:\n            premium_factor = 1.5\n            coverage_note = 'Standard carriers with surcharge'\n            deductible_note = 'Standard deductibles may apply'\n        elif overall_score > 0.3:\n            premium_factor = 1.2\n            coverage_note = 'Standard coverage available'\n            deductible_note = 'Standard deductibles'\n        else:\n            premium_factor = 1.0\n            coverage_note = 'Standard coverage, possible discount available'\n            deductible_note = 'Standard deductibles'\n\n        return {\n            'estimated_premium_factor': premium_factor,\n            'coverage_availability': coverage_note,\n            'deductible_expectations': deductible_note,\n            'mitigation_credit_available': overall_score > 0.3,\n            'note': 'Implementing mitigations may reduce premiums significantly'\n        }\n\n    def _estimate_mitigation_cost(self, risk_factors: List[FireRiskFactor]) -> Dict:\n        \"\"\"Estimate total mitigation costs\"\"\"\n        total_low = 0\n        total_high = 0\n\n        for factor in risk_factors:\n            if factor.score > 0.5:\n                if factor.factor_name == 'vegetation':\n                    total_low += 500\n                    total_high += 3000\n                elif factor.factor_name == 'defensible_space':\n                    total_low += 1000\n                    total_high += 5000\n                elif factor.factor_name == 'structure_vulnerability':\n                    total_low += 500\n                    total_high += 15000\n\n        return {\n            'estimated_low': total_low,\n            'estimated_high': total_high,\n            'roi_note': 'Mitigation costs typically offset by 10-30% premium reduction over 5 years'\n        }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"satellite--aerial-data-integration",children:"Satellite & Aerial Data Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom typing import Dict, List, Tuple, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\n\n@dataclass\nclass SatellitePass:\n    satellite: str        # 'sentinel-2', 'landsat-8', 'planet'\n    timestamp: datetime\n    resolution_m: float\n    bands: List[str]\n    cloud_cover_pct: float\n\n\nclass PreconditionDataCollector:\n    \"\"\"\n    Collect precondition data for insurance risk assessment.\n    Integrates drone, aircraft, and satellite data sources.\n    \"\"\"\n\n    # Data requirements by assessment type\n    DATA_REQUIREMENTS = {\n        'wildfire_risk': {\n            'satellite': ['ndvi', 'fuel_moisture', 'land_cover'],\n            'drone': ['vegetation_density', 'defensible_space', 'structure_materials'],\n            'ground': ['slope', 'aspect', 'soil_moisture']\n        },\n        'hail_damage': {\n            'satellite': ['historical_imagery'],\n            'drone': ['damage_detection', 'material_classification'],\n            'weather': ['hail_reports', 'storm_tracks']\n        },\n        'flood_risk': {\n            'satellite': ['dem', 'historical_flooding', 'land_use'],\n            'drone': ['drainage_patterns', 'elevation_mapping'],\n            'ground': ['soil_type', 'water_table']\n        }\n    }\n\n    def __init__(self):\n        self.satellite_sources = {\n            'sentinel-2': {'resolution': 10, 'revisit_days': 5},\n            'landsat-8': {'resolution': 30, 'revisit_days': 16},\n            'planet': {'resolution': 3, 'revisit_days': 1}\n        }\n\n    def plan_data_collection(self, property_locations: List[Tuple[float, float]],\n                             assessment_type: str,\n                             timeline_days: int = 30) -> Dict:\n        \"\"\"\n        Plan comprehensive data collection campaign.\n\n        Args:\n            property_locations: List of (lat, lon) coordinates\n            assessment_type: Type of assessment (e.g., 'wildfire_risk')\n            timeline_days: Days available for collection\n\n        Returns:\n            Collection plan with satellite passes, drone missions, ground tasks\n        \"\"\"\n        requirements = self.DATA_REQUIREMENTS.get(assessment_type, {})\n\n        plan = {\n            'assessment_type': assessment_type,\n            'properties': len(property_locations),\n            'timeline_days': timeline_days,\n            'satellite_plan': self._plan_satellite_collection(\n                property_locations, requirements.get('satellite', [])\n            ),\n            'drone_missions': self._plan_drone_missions(\n                property_locations, requirements.get('drone', [])\n            ),\n            'ground_verification': self._plan_ground_tasks(\n                property_locations, requirements.get('ground', [])\n            ),\n            'estimated_cost': None,\n            'data_fusion_strategy': self._fusion_strategy(assessment_type)\n        }\n\n        plan['estimated_cost'] = self._estimate_collection_cost(plan)\n\n        return plan\n\n    def _plan_satellite_collection(self, locations: List[Tuple],\n                                    data_needs: List[str]) -> Dict:\n        \"\"\"Plan satellite data acquisition\"\"\"\n        # Determine best satellite based on needs\n        if 'fuel_moisture' in data_needs:\n            best_satellite = 'sentinel-2'  # Has SWIR bands\n        elif any('high_res' in need for need in data_needs):\n            best_satellite = 'planet'\n        else:\n            best_satellite = 'landsat-8'\n\n        source = self.satellite_sources[best_satellite]\n\n        return {\n            'primary_source': best_satellite,\n            'resolution_m': source['resolution'],\n            'revisit_days': source['revisit_days'],\n            'required_bands': self._get_required_bands(data_needs),\n            'cloud_threshold_pct': 20,\n            'historical_baseline': True,\n            'years_of_baseline': 5,\n            'derived_products': data_needs\n        }\n\n    def _plan_drone_missions(self, locations: List[Tuple],\n                              data_needs: List[str]) -> List[Dict]:\n        \"\"\"Plan drone missions for each property\"\"\"\n        missions = []\n\n        for i, (lat, lon) in enumerate(locations):\n            mission = {\n                'property_id': i,\n                'location': (lat, lon),\n                'flight_plans': []\n            }\n\n            # RGB mapping flight\n            if any(need in ['vegetation_density', 'structure_materials']\n                   for need in data_needs):\n                mission['flight_plans'].append({\n                    'type': 'rgb_mapping',\n                    'altitude_m': 50,\n                    'overlap_pct': 80,\n                    'estimated_duration_min': 20,\n                    'outputs': ['orthomosaic', '3d_model']\n                })\n\n            # Thermal flight (if needed)\n            if 'defensible_space' in data_needs:\n                mission['flight_plans'].append({\n                    'type': 'thermal_survey',\n                    'altitude_m': 40,\n                    'overlap_pct': 70,\n                    'estimated_duration_min': 15,\n                    'outputs': ['thermal_mosaic', 'heat_signature_map']\n                })\n\n            # Detail inspection\n            if 'damage_detection' in data_needs:\n                mission['flight_plans'].append({\n                    'type': 'close_inspection',\n                    'altitude_m': 10,\n                    'pattern': 'orbit_structure',\n                    'estimated_duration_min': 10,\n                    'outputs': ['high_res_images', 'damage_annotations']\n                })\n\n            missions.append(mission)\n\n        return missions\n\n    def _plan_ground_tasks(self, locations: List[Tuple],\n                           data_needs: List[str]) -> List[Dict]:\n        \"\"\"Plan ground-based data collection\"\"\"\n        tasks = []\n\n        for i, (lat, lon) in enumerate(locations):\n            property_tasks = {\n                'property_id': i,\n                'location': (lat, lon),\n                'tasks': []\n            }\n\n            if 'slope' in data_needs:\n                property_tasks['tasks'].append({\n                    'type': 'topographic_survey',\n                    'method': 'gps_transect',\n                    'estimated_time_hours': 2\n                })\n\n            if 'soil_moisture' in data_needs:\n                property_tasks['tasks'].append({\n                    'type': 'soil_sampling',\n                    'method': 'tdr_probe',\n                    'sample_count': 5,\n                    'estimated_time_hours': 1\n                })\n\n            tasks.append(property_tasks)\n\n        return tasks\n\n    def _get_required_bands(self, data_needs: List[str]) -> List[str]:\n        \"\"\"Determine satellite bands needed\"\"\"\n        bands = ['red', 'green', 'blue', 'nir']  # Always need these\n\n        if 'fuel_moisture' in data_needs:\n            bands.extend(['swir1', 'swir2'])\n        if 'ndvi' in data_needs:\n            pass  # Already have red and nir\n\n        return list(set(bands))\n\n    def _fusion_strategy(self, assessment_type: str) -> Dict:\n        \"\"\"Define data fusion approach\"\"\"\n        strategies = {\n            'wildfire_risk': {\n                'primary_framework': 'weighted_overlay',\n                'temporal_fusion': 'multi_temporal_composite',\n                'spatial_resolution': 'upsample_to_drone',\n                'model_type': 'ensemble_ml',\n                'validation': 'ground_truth_sampling'\n            },\n            'hail_damage': {\n                'primary_framework': 'change_detection',\n                'temporal_fusion': 'before_after_comparison',\n                'spatial_resolution': 'native_drone',\n                'model_type': 'object_detection',\n                'validation': 'field_verification'\n            }\n        }\n        return strategies.get(assessment_type, strategies['wildfire_risk'])\n\n    def _estimate_collection_cost(self, plan: Dict) -> Dict:\n        \"\"\"Estimate data collection costs\"\"\"\n        satellite_cost = 500  # Per scene, roughly\n\n        drone_cost = sum(\n            sum(fp['estimated_duration_min'] * 5  # $5/minute flight time\n                for fp in mission['flight_plans'])\n            for mission in plan['drone_missions']\n        )\n\n        ground_cost = sum(\n            sum(task.get('estimated_time_hours', 0) * 75  # $75/hour field work\n                for task in prop['tasks'])\n            for prop in plan['ground_verification']\n        )\n\n        return {\n            'satellite_data': satellite_cost,\n            'drone_operations': drone_cost,\n            'ground_verification': ground_cost,\n            'total': satellite_cost + drone_cost + ground_cost,\n            'per_property': (satellite_cost + drone_cost + ground_cost) / max(plan['properties'], 1)\n        }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reinsurance-risk-modeling",children:"Reinsurance Risk Modeling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass PropertyRisk:\n    property_id: str\n    location: Tuple[float, float]\n    tiv: float                    # Total Insured Value\n    risk_score: float\n    peril_exposures: Dict[str, float]\n\n\nclass CatastropheRiskModel:\n    \"\"\"\n    Catastrophe risk modeling for reinsurance applications.\n    Integrates drone-collected data into probabilistic models.\n    \"\"\"\n\n    def __init__(self):\n        # Return period probabilities (annual exceedance probability)\n        self.return_periods = [10, 25, 50, 100, 250, 500]\n\n    def build_portfolio_model(self, properties: List[PropertyRisk],\n                              peril: str = 'wildfire') -> Dict:\n        \"\"\"\n        Build catastrophe model for property portfolio.\n\n        Args:\n            properties: List of properties with risk data\n            peril: Peril type (wildfire, hail, flood, etc.)\n\n        Returns:\n            Portfolio risk metrics and loss distribution\n        \"\"\"\n        # Aggregate TIV\n        total_tiv = sum(p.tiv for p in properties)\n\n        # Calculate loss distribution\n        losses_by_return_period = {}\n        for rp in self.return_periods:\n            loss = self._calculate_loss_at_return_period(properties, peril, rp)\n            losses_by_return_period[rp] = loss\n\n        # Calculate key metrics\n        aal = self._calculate_aal(losses_by_return_period)  # Average Annual Loss\n        pml_250 = losses_by_return_period.get(250, 0)        # Probable Maximum Loss\n        tce_250 = self._calculate_tce(losses_by_return_period, 250)  # Tail Conditional Expectation\n\n        return {\n            'portfolio_summary': {\n                'property_count': len(properties),\n                'total_tiv': total_tiv,\n                'peril': peril\n            },\n            'loss_metrics': {\n                'aal': aal,\n                'aal_rate': aal / total_tiv if total_tiv > 0 else 0,\n                'pml_250': pml_250,\n                'pml_250_rate': pml_250 / total_tiv if total_tiv > 0 else 0,\n                'tce_250': tce_250\n            },\n            'exceedance_curve': losses_by_return_period,\n            'concentration_risk': self._assess_concentration(properties),\n            'risk_drivers': self._identify_risk_drivers(properties, peril)\n        }\n\n    def _calculate_loss_at_return_period(self, properties: List[PropertyRisk],\n                                         peril: str, return_period: int) -> float:\n        \"\"\"Calculate aggregate loss at given return period\"\"\"\n        aep = 1 / return_period  # Annual Exceedance Probability\n\n        # Event intensity factor (increases with return period)\n        intensity_factor = np.log(return_period) / np.log(100)\n\n        total_loss = 0\n        for prop in properties:\n            exposure = prop.peril_exposures.get(peril, 0.5)\n            vulnerability = prop.risk_score * intensity_factor\n\n            # Loss = TIV * damage ratio\n            damage_ratio = min(exposure * vulnerability, 1.0)\n            loss = prop.tiv * damage_ratio\n\n            # Apply spatial correlation (nearby properties affected together)\n            # Simplified - real model would use event footprints\n            total_loss += loss\n\n        return total_loss\n\n    def _calculate_aal(self, loss_curve: Dict[int, float]) -> float:\n        \"\"\"Calculate Average Annual Loss from exceedance curve\"\"\"\n        sorted_rps = sorted(loss_curve.keys())\n\n        aal = 0\n        for i in range(len(sorted_rps) - 1):\n            rp1 = sorted_rps[i]\n            rp2 = sorted_rps[i + 1]\n\n            aep1 = 1 / rp1\n            aep2 = 1 / rp2\n\n            loss1 = loss_curve[rp1]\n            loss2 = loss_curve[rp2]\n\n            # Trapezoid rule integration\n            aal += (aep1 - aep2) * (loss1 + loss2) / 2\n\n        return aal\n\n    def _calculate_tce(self, loss_curve: Dict[int, float],\n                       threshold_rp: int) -> float:\n        \"\"\"Calculate Tail Conditional Expectation (expected loss given exceedance)\"\"\"\n        threshold_loss = loss_curve.get(threshold_rp, 0)\n        higher_losses = [loss for rp, loss in loss_curve.items()\n                        if rp >= threshold_rp]\n        return np.mean(higher_losses) if higher_losses else threshold_loss\n\n    def _assess_concentration(self, properties: List[PropertyRisk]) -> Dict:\n        \"\"\"Assess geographic concentration risk\"\"\"\n        locations = np.array([p.location for p in properties])\n\n        if len(locations) < 2:\n            return {'risk_level': 'low', 'note': 'Single property'}\n\n        # Calculate centroid\n        centroid = np.mean(locations, axis=0)\n\n        # Calculate distances from centroid (rough km)\n        distances = np.sqrt(\n            ((locations[:, 0] - centroid[0]) * 111) ** 2 +\n            ((locations[:, 1] - centroid[1]) * 111 * np.cos(np.radians(centroid[0]))) ** 2\n        )\n\n        avg_distance = np.mean(distances)\n        max_distance = np.max(distances)\n\n        if avg_distance < 10:  # Within 10km average\n            risk_level = 'high'\n        elif avg_distance < 50:\n            risk_level = 'medium'\n        else:\n            risk_level = 'low'\n\n        return {\n            'risk_level': risk_level,\n            'avg_distance_km': avg_distance,\n            'max_distance_km': max_distance,\n            'centroid': tuple(centroid)\n        }\n\n    def _identify_risk_drivers(self, properties: List[PropertyRisk],\n                               peril: str) -> List[Dict]:\n        \"\"\"Identify main risk drivers in portfolio\"\"\"\n        drivers = []\n\n        # Sort by contribution to risk\n        sorted_props = sorted(\n            properties,\n            key=lambda p: p.tiv * p.risk_score * p.peril_exposures.get(peril, 0.5),\n            reverse=True\n        )\n\n        # Top 10 risk contributors\n        for prop in sorted_props[:10]:\n            contribution = prop.tiv * prop.risk_score * prop.peril_exposures.get(peril, 0.5)\n            drivers.append({\n                'property_id': prop.property_id,\n                'tiv': prop.tiv,\n                'risk_score': prop.risk_score,\n                'peril_exposure': prop.peril_exposures.get(peril, 0.5),\n                'risk_contribution': contribution\n            })\n\n        return drivers\n\n    def generate_reinsurance_report(self, portfolio_model: Dict) -> Dict:\n        \"\"\"Generate report for reinsurance placement\"\"\"\n        metrics = portfolio_model['loss_metrics']\n\n        # Suggested reinsurance structure\n        suggested_retention = metrics['pml_250'] * 0.1  # 10% of PML as retention\n        suggested_limit = metrics['pml_250'] * 0.9      # Cover 90% of PML\n\n        return {\n            'summary': portfolio_model['portfolio_summary'],\n            'key_metrics': {\n                'aal': metrics['aal'],\n                'aal_rate_pct': metrics['aal_rate'] * 100,\n                'pml_250': metrics['pml_250'],\n                'pml_250_rate_pct': metrics['pml_250_rate'] * 100\n            },\n            'suggested_structure': {\n                'retention': suggested_retention,\n                'limit': suggested_limit,\n                'attachment_point': suggested_retention,\n                'exhaustion_point': suggested_retention + suggested_limit,\n                'structure_type': 'excess_of_loss'\n            },\n            'pricing_indication': {\n                'technical_rate': metrics['aal_rate'] * 1.25,  # Load factor\n                'risk_load': 0.15,  # 15% risk load\n                'cat_load': 0.10    # 10% cat load\n            },\n            'concentration_warning': portfolio_model['concentration_risk'],\n            'top_risk_drivers': portfolio_model['risk_drivers'][:5]\n        }\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}}}]);