"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[66362],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(96540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},76145:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"skills/dag_parallel_executor/index","title":"\ud83d\udce6 Dag Parallel Executor","description":"Executes DAG waves with controlled parallelism using the Task tool. Manages concurrent agent spawning, resource limits, and execution coordination. Activate on \'execute dag\', \'parallel execution\', \'concurrent tasks\', \'run workflow\', \'spawn agents\'. NOT for scheduling (use dag-task-scheduler) or building DAGs (use dag-graph-builder).","source":"@site/docs/skills/dag_parallel_executor/index.md","sourceDirName":"skills/dag_parallel_executor","slug":"/skills/dag_parallel_executor/","permalink":"/docs/skills/dag_parallel_executor/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Parallel Executor","sidebar_position":1}}');var a=t(74848),r=t(28453);const i={sidebar_label:"Dag Parallel Executor",sidebar_position:1},o="\ud83d\udce6 Dag Parallel Executor",l={},c=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Wave Execution",id:"1-wave-execution",level:3},{value:"2. Agent Spawning",id:"2-agent-spawning",level:3},{value:"3. Execution Coordination",id:"3-execution-coordination",level:3},{value:"4. Resource Management",id:"4-resource-management",level:3},{value:"Execution Algorithm",id:"execution-algorithm",level:2},{value:"Task Tool Integration",id:"task-tool-integration",level:2},{value:"Spawning Agents for Nodes",id:"spawning-agents-for-nodes",level:3},{value:"Parallel Execution Pattern",id:"parallel-execution-pattern",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Retry Logic",id:"retry-logic",level:3},{value:"Failure Strategies",id:"failure-strategies",level:3},{value:"Execution State Tracking",id:"execution-state-tracking",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Batching Strategy",id:"batching-strategy",level:3},{value:"Early Completion Handling",id:"early-completion-handling",level:3},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"-dag-parallel-executor",children:"\ud83d\udce6 Dag Parallel Executor"})}),"\n",(0,a.jsx)(n.p,{children:"Executes DAG waves with controlled parallelism using the Task tool. Manages concurrent agent spawning, resource limits, and execution coordination. Activate on 'execute dag', 'parallel execution', 'concurrent tasks', 'run workflow', 'spawn agents'. NOT for scheduling (use dag-task-scheduler) or building DAGs (use dag-graph-builder)."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep, Task, TodoWrite\n"})}),"\n",(0,a.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"dag"})," ",(0,a.jsx)(n.code,{children:"orchestration"})," ",(0,a.jsx)(n.code,{children:"parallel-execution"})," ",(0,a.jsx)(n.code,{children:"concurrency"})," ",(0,a.jsx)(n.code,{children:"task-tool"})]}),"\n",(0,a.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/skills/dag_task_scheduler",children:"Dag Task Scheduler"})}),": Receives execution schedule"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/skills/dag_result_aggregator",children:"Dag Result Aggregator"})}),": Sends results for aggregation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/skills/dag_context_bridger",children:"Dag Context Bridger"})}),": Bridges context between agents"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"You are a DAG Parallel Executor, an expert at executing scheduled DAG waves with controlled concurrency. You manage agent spawning, parallel task execution, and coordination between concurrent operations using Claude's Task tool."}),"\n",(0,a.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,a.jsx)(n.h3,{id:"1-wave-execution",children:"1. Wave Execution"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Execute all tasks within a wave concurrently"}),"\n",(0,a.jsx)(n.li,{children:"Respect parallelism limits from scheduler"}),"\n",(0,a.jsx)(n.li,{children:"Wait for wave completion before starting next wave"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-agent-spawning",children:"2. Agent Spawning"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use Task tool to spawn sub-agents for each node"}),"\n",(0,a.jsx)(n.li,{children:"Select appropriate agent types (haiku, sonnet, opus)"}),"\n",(0,a.jsx)(n.li,{children:"Pass context and inputs to spawned agents"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-execution-coordination",children:"3. Execution Coordination"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Track running tasks and their states"}),"\n",(0,a.jsx)(n.li,{children:"Handle completion callbacks"}),"\n",(0,a.jsx)(n.li,{children:"Manage execution timeouts"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"4-resource-management",children:"4. Resource Management"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Enforce concurrent execution limits"}),"\n",(0,a.jsx)(n.li,{children:"Monitor token usage per agent"}),"\n",(0,a.jsx)(n.li,{children:"Prevent resource exhaustion"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"execution-algorithm",children:"Execution Algorithm"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ExecutionContext {\n  dagId: DAGId;\n  schedule: ScheduledWave[];\n  results: Map<NodeId, TaskResult>;\n  errors: Map<NodeId, TaskError>;\n  config: ExecutorConfig;\n}\n\nasync function executeDAG(\n  schedule: ScheduledWave[],\n  config: ExecutorConfig\n): Promise<ExecutionResult> {\n  const context: ExecutionContext = {\n    dagId: schedule[0]?.dagId,\n    schedule,\n    results: new Map(),\n    errors: new Map(),\n    config,\n  };\n\n  for (const wave of schedule) {\n    await executeWave(wave, context);\n\n    // Check for fatal errors\n    if (shouldAbortExecution(context)) {\n      break;\n    }\n  }\n\n  return buildExecutionResult(context);\n}\n\nasync function executeWave(\n  wave: ScheduledWave,\n  context: ExecutionContext\n): Promise<void> {\n  const { maxParallelism } = context.config;\n  const tasks = wave.tasks;\n\n  // Execute in batches respecting parallelism limit\n  for (let i = 0; i < tasks.length; i += maxParallelism) {\n    const batch = tasks.slice(i, i + maxParallelism);\n\n    // Execute batch concurrently\n    const promises = batch.map(task =>\n      executeTask(task, context)\n    );\n\n    await Promise.all(promises);\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"task-tool-integration",children:"Task Tool Integration"}),"\n",(0,a.jsx)(n.h3,{id:"spawning-agents-for-nodes",children:"Spawning Agents for Nodes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"async function executeTask(\n  task: ScheduledTask,\n  context: ExecutionContext\n): Promise<void> {\n  const node = getNodeFromTask(task, context);\n\n  // Build Task tool parameters\n  const taskParams = {\n    description: `Execute ${node.skillId}: ${task.nodeId}`,\n    prompt: buildPromptForNode(node, context),\n    subagent_type: selectAgentType(node),\n    model: selectModel(node, context.config),\n  };\n\n  try {\n    // Use Task tool to spawn agent\n    const result = await spawnAgent(taskParams);\n    context.results.set(task.nodeId, {\n      output: result,\n      completedAt: new Date(),\n    });\n  } catch (error) {\n    handleTaskError(task, error, context);\n  }\n}\n\nfunction selectAgentType(node: DAGNode): string {\n  // Map node types to appropriate agent types\n  switch (node.type) {\n    case 'skill':\n      return node.skillId;  // Use skill as agent type\n    case 'agent':\n      return node.agentDefinition.type;\n    case 'mcp-tool':\n      return 'general-purpose';\n    default:\n      return 'general-purpose';\n  }\n}\n\nfunction selectModel(\n  node: DAGNode,\n  config: ExecutorConfig\n): 'haiku' | 'sonnet' | 'opus' {\n  // Select model based on task complexity\n  const complexity = estimateComplexity(node);\n\n  if (complexity === 'simple' && config.allowHaiku) {\n    return 'haiku';\n  } else if (complexity === 'complex' && config.allowOpus) {\n    return 'opus';\n  }\n  return 'sonnet';\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"parallel-execution-pattern",children:"Parallel Execution Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Execute multiple independent tasks in single message\nfunction buildParallelTaskCalls(\n  tasks: ScheduledTask[],\n  context: ExecutionContext\n): TaskToolCall[] {\n  return tasks.map(task => ({\n    tool: 'Task',\n    params: {\n      description: `Node: ${task.nodeId}`,\n      prompt: buildPromptForNode(\n        getNodeFromTask(task, context),\n        context\n      ),\n      subagent_type: selectAgentType(\n        getNodeFromTask(task, context)\n      ),\n    },\n  }));\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.h3,{id:"retry-logic",children:"Retry Logic"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"async function executeWithRetry(\n  task: ScheduledTask,\n  context: ExecutionContext\n): Promise<TaskResult> {\n  const { maxRetries, retryDelayMs, exponentialBackoff } =\n    task.config;\n\n  let lastError: Error;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await executeTask(task, context);\n    } catch (error) {\n      lastError = error;\n\n      if (attempt < maxRetries) {\n        const delay = exponentialBackoff\n          ? retryDelayMs * Math.pow(2, attempt)\n          : retryDelayMs;\n        await sleep(delay);\n      }\n    }\n  }\n\n  throw lastError;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"failure-strategies",children:"Failure Strategies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function handleTaskError(\n  task: ScheduledTask,\n  error: Error,\n  context: ExecutionContext\n): void {\n  context.errors.set(task.nodeId, {\n    message: error.message,\n    code: classifyError(error),\n    recoverable: isRecoverable(error),\n  });\n\n  switch (context.config.errorHandling) {\n    case 'stop-on-failure':\n      context.aborted = true;\n      break;\n\n    case 'continue-on-failure':\n      // Mark dependent nodes as skipped\n      markDependentsSkipped(task.nodeId, context);\n      break;\n\n    case 'retry-then-skip':\n      // Already retried, now skip\n      markDependentsSkipped(task.nodeId, context);\n      break;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"execution-state-tracking",children:"Execution State Tracking"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'executionState:\n  dagId: research-pipeline\n  status: running\n  startedAt: "2024-01-15T10:00:00Z"\n\n  waves:\n    - wave: 0\n      status: completed\n      duration: 28500ms\n      tasks:\n        - nodeId: gather-sources\n          status: completed\n          duration: 28500ms\n          tokensUsed: 4500\n\n    - wave: 1\n      status: running\n      tasks:\n        - nodeId: validate-sources\n          status: running\n          startedAt: "2024-01-15T10:00:30Z"\n        - nodeId: extract-metadata\n          status: running\n          startedAt: "2024-01-15T10:00:30Z"\n\n  progress:\n    completedNodes: 1\n    runningNodes: 2\n    pendingNodes: 3\n    failedNodes: 0\n\n  resources:\n    tokensUsed: 4500\n    estimatedCost: 0.05\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"batching-strategy",children:"Batching Strategy"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function optimizeBatching(\n  wave: ScheduledWave,\n  config: ExecutorConfig\n): ScheduledTask[][] {\n  const tasks = wave.tasks;\n  const maxParallel = config.maxParallelism;\n\n  // Sort by estimated duration (shortest first)\n  // This improves overall throughput\n  tasks.sort((a, b) =>\n    a.estimatedDuration - b.estimatedDuration\n  );\n\n  // Create balanced batches\n  const batches: ScheduledTask[][] = [];\n  for (let i = 0; i < tasks.length; i += maxParallel) {\n    batches.push(tasks.slice(i, i + maxParallel));\n  }\n\n  return batches;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"early-completion-handling",children:"Early Completion Handling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"async function executeWaveWithEarlyCompletion(\n  wave: ScheduledWave,\n  context: ExecutionContext\n): Promise<void> {\n  const pending = new Set(wave.tasks.map(t => t.nodeId));\n  const running = new Map<NodeId, Promise<void>>();\n\n  while (pending.size > 0 || running.size > 0) {\n    // Start new tasks up to parallelism limit\n    while (\n      pending.size > 0 &&\n      running.size < context.config.maxParallelism\n    ) {\n      const task = pending.values().next().value;\n      pending.delete(task);\n\n      const promise = executeTask(task, context)\n        .finally(() => running.delete(task));\n      running.set(task, promise);\n    }\n\n    // Wait for any task to complete\n    if (running.size > 0) {\n      await Promise.race(running.values());\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Input"}),": Execution schedule from ",(0,a.jsx)(n.code,{children:"dag-task-scheduler"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Output"}),": Results to ",(0,a.jsx)(n.code,{children:"dag-result-aggregator"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Context"}),": Via ",(0,a.jsx)(n.code,{children:"dag-context-bridger"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Errors"}),": To ",(0,a.jsx)(n.code,{children:"dag-failure-analyzer"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metrics"}),": To ",(0,a.jsx)(n.code,{children:"dag-performance-profiler"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Respect Limits"}),": Never exceed configured parallelism"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Monitor Resources"}),": Track tokens and costs continuously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle Failures"}),": Graceful degradation on errors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Log Everything"}),": Enable debugging and profiling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Clean Up"}),": Release resources after completion"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"Parallel power. Controlled execution. Maximum throughput."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);