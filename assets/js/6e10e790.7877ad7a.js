"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[56044],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var d=i(96540);const r={},t=d.createContext(r);function s(e){const n=d.useContext(t);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),d.createElement(t.Provider,{value:n},e.children)}},96479:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>g,frontMatter:()=>s,metadata:()=>d,toc:()=>l});const d=JSON.parse('{"id":"skills/dag_dynamic_replanner/index","title":"\ud83d\udce6 Dag Dynamic Replanner","description":"Modifies DAG structure during execution in response to failures, new requirements, or runtime discoveries. Supports node insertion, removal, and dependency rewiring. Activate on \'replan dag\', \'modify workflow\', \'add node\', \'remove node\', \'dynamic modification\'. NOT for initial DAG building (use dag-graph-builder) or scheduling (use dag-task-scheduler).","source":"@site/docs/skills/dag_dynamic_replanner/index.md","sourceDirName":"skills/dag_dynamic_replanner","slug":"/skills/dag_dynamic_replanner/","permalink":"/docs/skills/dag_dynamic_replanner/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Dag Dynamic Replanner","sidebar_position":1}}');var r=i(74848),t=i(28453);const s={sidebar_label:"Dag Dynamic Replanner",sidebar_position:1},a="\ud83d\udce6 Dag Dynamic Replanner",o={},l=[{value:"Allowed Tools",id:"allowed-tools",level:2},{value:"Tags",id:"tags",level:2},{value:"\ud83e\udd1d Pairs Great With",id:"-pairs-great-with",level:2},{value:"Core Responsibilities",id:"core-responsibilities",level:2},{value:"1. Runtime Modification",id:"1-runtime-modification",level:3},{value:"2. Failure Recovery",id:"2-failure-recovery",level:3},{value:"3. Requirement Adaptation",id:"3-requirement-adaptation",level:3},{value:"4. Graph Integrity",id:"4-graph-integrity",level:3},{value:"Modification Operations",id:"modification-operations",level:2},{value:"Insert Node",id:"insert-node",level:3},{value:"Remove Node",id:"remove-node",level:3},{value:"Rewire Dependencies",id:"rewire-dependencies",level:3},{value:"Failure Recovery Strategies",id:"failure-recovery-strategies",level:2},{value:"Strategy 1: Fallback Node",id:"strategy-1-fallback-node",level:3},{value:"Strategy 2: Retry with Different Config",id:"strategy-2-retry-with-different-config",level:3},{value:"Strategy 3: Alternative Path",id:"strategy-3-alternative-path",level:3},{value:"Replanning Triggers",id:"replanning-triggers",level:2},{value:"Modification History",id:"modification-history",level:2},{value:"Validation",id:"validation",level:2},{value:"Integration Points",id:"integration-points",level:2},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"-dag-dynamic-replanner",children:"\ud83d\udce6 Dag Dynamic Replanner"})}),"\n",(0,r.jsx)(n.p,{children:"Modifies DAG structure during execution in response to failures, new requirements, or runtime discoveries. Supports node insertion, removal, and dependency rewiring. Activate on 'replan dag', 'modify workflow', 'add node', 'remove node', 'dynamic modification'. NOT for initial DAG building (use dag-graph-builder) or scheduling (use dag-task-scheduler)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"allowed-tools",children:"Allowed Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Read, Write, Edit, Glob, Grep, Task, TodoWrite\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"dag"})," ",(0,r.jsx)(n.code,{children:"orchestration"})," ",(0,r.jsx)(n.code,{children:"replanning"})," ",(0,r.jsx)(n.code,{children:"dynamic"})," ",(0,r.jsx)(n.code,{children:"adaptation"})]}),"\n",(0,r.jsx)(n.h2,{id:"-pairs-great-with",children:"\ud83e\udd1d Pairs Great With"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_graph_builder",children:"Dag Graph Builder"})}),": Uses same graph construction patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_dependency_resolver",children:"Dag Dependency Resolver"})}),": Re-validates after modifications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/skills/dag_failure_analyzer",children:"Dag Failure Analyzer"})}),": Receives failure triggers for replanning"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"You are a DAG Dynamic Replanner, an expert at modifying DAG structures during execution. You handle runtime adaptations including node insertion, removal, dependency rewiring, and recovery strategies in response to failures or changing requirements."}),"\n",(0,r.jsx)(n.h2,{id:"core-responsibilities",children:"Core Responsibilities"}),"\n",(0,r.jsx)(n.h3,{id:"1-runtime-modification",children:"1. Runtime Modification"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Insert new nodes during execution"}),"\n",(0,r.jsx)(n.li,{children:"Remove or skip nodes that are no longer needed"}),"\n",(0,r.jsx)(n.li,{children:"Rewire dependencies based on runtime conditions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-failure-recovery",children:"2. Failure Recovery"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement fallback strategies for failed nodes"}),"\n",(0,r.jsx)(n.li,{children:"Create alternative execution paths"}),"\n",(0,r.jsx)(n.li,{children:"Handle cascading failure prevention"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-requirement-adaptation",children:"3. Requirement Adaptation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add nodes for newly discovered requirements"}),"\n",(0,r.jsx)(n.li,{children:"Modify node configurations based on results"}),"\n",(0,r.jsx)(n.li,{children:"Adjust parallelism and resource allocation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-graph-integrity",children:"4. Graph Integrity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maintain DAG properties after modifications"}),"\n",(0,r.jsx)(n.li,{children:"Validate changes before applying"}),"\n",(0,r.jsx)(n.li,{children:"Track modification history"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"modification-operations",children:"Modification Operations"}),"\n",(0,r.jsx)(n.h3,{id:"insert-node",children:"Insert Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface NodeInsertion {\n  node: DAGNode;\n  insertAfter: NodeId[];   // Dependencies\n  insertBefore: NodeId[];  // Dependents\n}\n\nfunction insertNode(\n  dag: DAG,\n  insertion: NodeInsertion\n): DAG {\n  const { node, insertAfter, insertBefore } = insertion;\n\n  // Validate insertion\n  validateInsertion(dag, insertion);\n\n  // Add the new node\n  dag.nodes.set(node.id, {\n    ...node,\n    dependencies: insertAfter,\n    state: { status: 'pending' },\n  });\n\n  // Update dependents to depend on new node\n  for (const dependentId of insertBefore) {\n    const dependent = dag.nodes.get(dependentId);\n    if (dependent) {\n      // Replace old dependencies with new node\n      dependent.dependencies = [\n        ...dependent.dependencies.filter(\n          d => !insertAfter.includes(d)\n        ),\n        node.id,\n      ];\n    }\n  }\n\n  // Update edges\n  rebuildEdges(dag);\n\n  return dag;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"remove-node",children:"Remove Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface NodeRemoval {\n  nodeId: NodeId;\n  strategy: 'skip' | 'bridge' | 'cascade';\n}\n\nfunction removeNode(\n  dag: DAG,\n  removal: NodeRemoval\n): DAG {\n  const { nodeId, strategy } = removal;\n  const node = dag.nodes.get(nodeId);\n\n  if (!node) return dag;\n\n  switch (strategy) {\n    case 'skip':\n      // Mark as skipped, keep structure\n      node.state = { status: 'skipped', reason: 'Removed by replanner' };\n      break;\n\n    case 'bridge':\n      // Connect predecessors directly to successors\n      const dependents = findDependents(dag, nodeId);\n      for (const depId of dependents) {\n        const dependent = dag.nodes.get(depId);\n        if (dependent) {\n          dependent.dependencies = [\n            ...dependent.dependencies.filter(d => d !== nodeId),\n            ...node.dependencies,\n          ];\n        }\n      }\n      dag.nodes.delete(nodeId);\n      break;\n\n    case 'cascade':\n      // Remove node and all dependents\n      const toRemove = findAllDependents(dag, nodeId);\n      for (const id of [nodeId, ...toRemove]) {\n        dag.nodes.delete(id);\n      }\n      break;\n  }\n\n  rebuildEdges(dag);\n  return dag;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"rewire-dependencies",children:"Rewire Dependencies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface DependencyRewire {\n  nodeId: NodeId;\n  oldDependencies: NodeId[];\n  newDependencies: NodeId[];\n}\n\nfunction rewireDependencies(\n  dag: DAG,\n  rewire: DependencyRewire\n): DAG {\n  const { nodeId, newDependencies } = rewire;\n  const node = dag.nodes.get(nodeId);\n\n  if (!node) return dag;\n\n  // Validate new dependencies exist and won't create cycles\n  for (const depId of newDependencies) {\n    if (!dag.nodes.has(depId)) {\n      throw new Error(`Dependency ${depId} does not exist`);\n    }\n    if (wouldCreateCycle(dag, nodeId, depId)) {\n      throw new Error(`Would create cycle: ${nodeId} -> ${depId}`);\n    }\n  }\n\n  node.dependencies = newDependencies;\n  rebuildEdges(dag);\n\n  return dag;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"failure-recovery-strategies",children:"Failure Recovery Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"strategy-1-fallback-node",children:"Strategy 1: Fallback Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function addFallbackNode(\n  dag: DAG,\n  failedNodeId: NodeId,\n  fallback: DAGNode\n): DAG {\n  const failedNode = dag.nodes.get(failedNodeId);\n  if (!failedNode) return dag;\n\n  // Insert fallback with same dependencies\n  return insertNode(dag, {\n    node: {\n      ...fallback,\n      id: `${failedNodeId}-fallback` as NodeId,\n      dependencies: failedNode.dependencies,\n    },\n    insertAfter: failedNode.dependencies,\n    insertBefore: findDependents(dag, failedNodeId),\n  });\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"strategy-2-retry-with-different-config",children:"Strategy 2: Retry with Different Config"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function retryWithModification(\n  dag: DAG,\n  failedNodeId: NodeId,\n  modifications: Partial<TaskConfig>\n): DAG {\n  const node = dag.nodes.get(failedNodeId);\n  if (!node) return dag;\n\n  // Reset state and update config\n  node.state = { status: 'pending' };\n  node.config = { ...node.config, ...modifications };\n\n  // Maybe increase timeout, change model, etc.\n  return dag;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"strategy-3-alternative-path",children:"Strategy 3: Alternative Path"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function createAlternativePath(\n  dag: DAG,\n  blockedPath: NodeId[],\n  alternativeNodes: DAGNode[]\n): DAG {\n  // Mark blocked path as skipped\n  for (const nodeId of blockedPath) {\n    const node = dag.nodes.get(nodeId);\n    if (node) {\n      node.state = { status: 'skipped', reason: 'Path blocked' };\n    }\n  }\n\n  // Insert alternative path\n  let prevNodeId = findLastCompletedBefore(dag, blockedPath[0]);\n  for (const altNode of alternativeNodes) {\n    dag = insertNode(dag, {\n      node: altNode,\n      insertAfter: prevNodeId ? [prevNodeId] : [],\n      insertBefore: [],\n    });\n    prevNodeId = altNode.id;\n  }\n\n  // Connect to nodes after blocked path\n  const afterBlocked = findNodesAfter(dag, blockedPath);\n  for (const nodeId of afterBlocked) {\n    const node = dag.nodes.get(nodeId);\n    if (node && prevNodeId) {\n      node.dependencies = [\n        ...node.dependencies.filter(d => !blockedPath.includes(d)),\n        prevNodeId,\n      ];\n    }\n  }\n\n  return dag;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"replanning-triggers",children:"Replanning Triggers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface ReplanTrigger {\n  type: 'failure' | 'timeout' | 'requirement' | 'optimization';\n  nodeId?: NodeId;\n  reason: string;\n  suggestedAction: ReplanAction;\n}\n\ntype ReplanAction =\n  | { type: 'insert'; node: DAGNode; position: NodeInsertion }\n  | { type: 'remove'; nodeId: NodeId; strategy: 'skip' | 'bridge' | 'cascade' }\n  | { type: 'retry'; nodeId: NodeId; modifications: Partial<TaskConfig> }\n  | { type: 'fallback'; failedNodeId: NodeId; fallback: DAGNode }\n  | { type: 'rewire'; rewire: DependencyRewire };\n\nfunction handleReplanTrigger(\n  dag: DAG,\n  trigger: ReplanTrigger\n): DAG {\n  logReplanEvent(trigger);\n\n  switch (trigger.suggestedAction.type) {\n    case 'insert':\n      return insertNode(dag, trigger.suggestedAction.position);\n    case 'remove':\n      return removeNode(dag, trigger.suggestedAction);\n    case 'retry':\n      return retryWithModification(\n        dag,\n        trigger.suggestedAction.nodeId,\n        trigger.suggestedAction.modifications\n      );\n    case 'fallback':\n      return addFallbackNode(\n        dag,\n        trigger.suggestedAction.failedNodeId,\n        trigger.suggestedAction.fallback\n      );\n    case 'rewire':\n      return rewireDependencies(dag, trigger.suggestedAction.rewire);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"modification-history",children:"Modification History"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'modificationHistory:\n  dagId: research-pipeline\n  originalVersion: 1\n  currentVersion: 3\n\n  modifications:\n    - version: 2\n      timestamp: "2024-01-15T10:01:00Z"\n      trigger:\n        type: failure\n        nodeId: analyze-code\n        reason: "Timeout exceeded"\n      action:\n        type: retry\n        modifications:\n          timeoutMs: 60000\n          maxRetries: 5\n\n    - version: 3\n      timestamp: "2024-01-15T10:02:30Z"\n      trigger:\n        type: failure\n        nodeId: analyze-code\n        reason: "Still failing after retry"\n      action:\n        type: fallback\n        fallback:\n          id: analyze-code-simple\n          skillId: code-analyzer-basic\n'})}),"\n",(0,r.jsx)(n.h2,{id:"validation",children:"Validation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function validateModification(\n  dag: DAG,\n  modification: ReplanAction\n): ValidationResult {\n  const issues: string[] = [];\n\n  // Check DAG properties\n  if (hasCycle(dag)) {\n    issues.push('Modification would create a cycle');\n  }\n\n  // Check for orphan nodes\n  const orphans = findOrphanNodes(dag);\n  if (orphans.length > 0) {\n    issues.push(`Would create orphan nodes: ${orphans.join(', ')}`);\n  }\n\n  // Check resource constraints\n  if (exceedsResourceLimits(dag)) {\n    issues.push('Modification exceeds resource limits');\n  }\n\n  return {\n    valid: issues.length === 0,\n    issues,\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"integration-points",children:"Integration Points"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Triggers"}),": From ",(0,r.jsx)(n.code,{children:"dag-failure-analyzer"})," and ",(0,r.jsx)(n.code,{children:"dag-parallel-executor"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": Via ",(0,r.jsx)(n.code,{children:"dag-dependency-resolver"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scheduling"}),": Updates to ",(0,r.jsx)(n.code,{children:"dag-task-scheduler"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"History"}),": Logged to ",(0,r.jsx)(n.code,{children:"dag-execution-tracer"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate First"}),": Always validate before applying modifications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Track History"}),": Log all modifications for debugging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Preserve Progress"}),": Don't lose completed work"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limit Cascades"}),": Prevent runaway modification chains"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test Fallbacks"}),": Verify alternative paths work"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Adapt and overcome. Dynamic execution. Resilient workflows."})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);