{
  "name": "frontend-architect",
  "type": "folder",
  "path": "frontend-architect",
  "children": [
    {
      "name": "references",
      "type": "folder",
      "path": "frontend-architect/references",
      "children": [
        {
          "name": "cloudflare-patterns.md",
          "type": "file",
          "path": "frontend-architect/references/cloudflare-patterns.md",
          "size": 9073,
          "content": "# Cloudflare Patterns\n\nEdge deployment patterns, configuration, and best practices for Cloudflare Pages.\n\n## Project Setup\n\n### wrangler.toml Configuration\n\n```toml\n# wrangler.toml for Next.js on Cloudflare Pages\nname = \"project-name\"\ncompatibility_date = \"2026-01-31\"\npages_build_output_dir = \".next\"\n\n# Environment variables\n[vars]\nENVIRONMENT = \"production\"\n\n# Secrets (set via wrangler secret put)\n# PEXELS_API_KEY, DATABASE_URL, etc.\n\n# KV Namespaces\n[[kv_namespaces]]\nbinding = \"CACHE\"\nid = \"your-kv-namespace-id\"\npreview_id = \"your-preview-kv-id\"\n\n# D1 Database\n[[d1_databases]]\nbinding = \"DB\"\ndatabase_name = \"project-db\"\ndatabase_id = \"your-database-id\"\n\n# R2 Storage\n[[r2_buckets]]\nbinding = \"ASSETS\"\nbucket_name = \"project-assets\"\n\n# Durable Objects\n[[durable_objects.bindings]]\nname = \"RATE_LIMITER\"\nclass_name = \"RateLimiter\"\n```\n\n### next.config.js for Cloudflare\n\n```javascript\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'standalone',\n  images: {\n    loader: 'custom',\n    loaderFile: './lib/cloudflare-image-loader.ts',\n    remotePatterns: [\n      { hostname: 'images.pexels.com' },\n      { hostname: 'images.unsplash.com' },\n    ],\n  },\n  // Experimental edge runtime\n  experimental: {\n    runtime: 'edge',\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n## Deployment Patterns\n\n### Preview Deployments\n\n```yaml\n# Every PR gets a preview URL\nTrigger: Pull Request opened/updated\nURL: https://preview-{branch-slug}.{project}.pages.dev\n\n# Use case: Stakeholder review\n# Share URL with:\n# - Design team for visual review\n# - QA for testing\n# - Product for feature approval\n```\n\n**Workflow:**\n```bash\n# Automatic on PR (via GitHub integration)\n# Or manual:\nnpx wrangler pages deploy .next \\\n  --project-name=your-project \\\n  --branch=feature-branch \\\n  --commit-message=\"Feature: Add gallery\"\n```\n\n### Environment Management\n\n```typescript\n// Environment detection\nconst env = {\n  isProduction: process.env.CF_PAGES_BRANCH === 'main',\n  isPreview: process.env.CF_PAGES_BRANCH !== 'main' && !!process.env.CF_PAGES,\n  isDevelopment: !process.env.CF_PAGES,\n  branch: process.env.CF_PAGES_BRANCH,\n  commitSha: process.env.CF_PAGES_COMMIT_SHA,\n};\n\n// Feature flags per environment\nconst features = {\n  newCheckout: env.isPreview || env.isDevelopment,\n  experimentalUI: env.branch === 'feature/new-ui',\n  analytics: env.isProduction,\n};\n```\n\n### Production Deployment\n\n```yaml\n# Automatic on push to main\nTrigger: Push to main branch\nURL: https://your-domain.com\n\n# Custom domain setup in Cloudflare Dashboard:\n# 1. Add custom domain\n# 2. Wait for SSL provisioning\n# 3. Verify DNS propagation\n```\n\n## Edge Patterns\n\n### Middleware at the Edge\n\n```typescript\n// middleware.ts - runs on every request\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],\n};\n\nexport function middleware(request: NextRequest) {\n  const response = NextResponse.next();\n\n  // Add security headers\n  response.headers.set('X-Frame-Options', 'DENY');\n  response.headers.set('X-Content-Type-Options', 'nosniff');\n  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');\n\n  // Geolocation-based routing\n  const country = request.geo?.country || 'US';\n  if (country === 'EU') {\n    response.headers.set('X-GDPR-Required', 'true');\n  }\n\n  return response;\n}\n```\n\n### KV-Based Feature Flags\n\n```typescript\n// lib/feature-flags.ts\nexport async function getFeatureFlags(env: { KV: KVNamespace }) {\n  const flags = await env.KV.get('feature-flags', 'json');\n  return flags || {};\n}\n\n// Usage in middleware\nexport async function middleware(request: NextRequest) {\n  const flags = await getFeatureFlags(env);\n\n  if (flags.newHomepage && request.nextUrl.pathname === '/') {\n    return NextResponse.rewrite(new URL('/home-v2', request.url));\n  }\n\n  return NextResponse.next();\n}\n\n// Setting flags\nawait env.KV.put('feature-flags', JSON.stringify({\n  newHomepage: true,\n  darkModeDefault: false,\n  experimentalFeature: 'variant-a',\n}));\n```\n\n### Edge Caching\n\n```typescript\n// API route with edge caching\nexport const runtime = 'edge';\n\nexport async function GET(request: Request) {\n  const cacheKey = new URL(request.url).pathname;\n\n  // Try cache first\n  const cached = await env.CACHE.get(cacheKey, 'json');\n  if (cached) {\n    return Response.json(cached, {\n      headers: { 'X-Cache': 'HIT' }\n    });\n  }\n\n  // Fetch and cache\n  const data = await fetchExpensiveData();\n  await env.CACHE.put(cacheKey, JSON.stringify(data), {\n    expirationTtl: 3600 // 1 hour\n  });\n\n  return Response.json(data, {\n    headers: { 'X-Cache': 'MISS' }\n  });\n}\n```\n\n## Auth Patterns\n\n### Cloudflare Access Integration\n\n```typescript\n// lib/cloudflare-access.ts\ninterface AccessUser {\n  email: string;\n  name?: string;\n  groups?: string[];\n}\n\nexport async function verifyAccessToken(jwt: string | null): Promise<AccessUser | null> {\n  if (!jwt) return null;\n\n  try {\n    // Cloudflare Access provides JWT verification endpoint\n    const response = await fetch(\n      `https://${process.env.CF_ACCESS_TEAM_NAME}.cloudflareaccess.com/cdn-cgi/access/get-identity`,\n      { headers: { 'CF-Access-JWT-Assertion': jwt } }\n    );\n\n    if (!response.ok) return null;\n\n    return await response.json();\n  } catch {\n    return null;\n  }\n}\n\n// Usage in API route\nexport async function GET(request: Request) {\n  const jwt = request.headers.get('CF-Access-JWT-Assertion');\n  const user = await verifyAccessToken(jwt);\n\n  if (!user) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n\n  if (!user.groups?.includes('admin')) {\n    return new Response('Forbidden', { status: 403 });\n  }\n\n  // Admin-only logic\n}\n```\n\n### Role-Based Access\n\n```typescript\n// middleware.ts\nexport async function middleware(request: NextRequest) {\n  const jwt = request.headers.get('CF-Access-JWT-Assertion');\n  const user = await verifyAccessToken(jwt);\n\n  const pathname = request.nextUrl.pathname;\n\n  // Route protection map\n  const protectedRoutes = {\n    '/admin': ['admin'],\n    '/beta': ['beta-testers', 'admin'],\n    '/internal': ['employee'],\n  };\n\n  for (const [route, requiredGroups] of Object.entries(protectedRoutes)) {\n    if (pathname.startsWith(route)) {\n      if (!user) {\n        return new Response('Unauthorized', { status: 401 });\n      }\n      if (!requiredGroups.some(g => user.groups?.includes(g))) {\n        return new Response('Forbidden', { status: 403 });\n      }\n    }\n  }\n\n  return NextResponse.next();\n}\n```\n\n## Image Optimization\n\n### Cloudflare Image Loader\n\n```typescript\n// lib/cloudflare-image-loader.ts\nexport default function cloudflareLoader({\n  src,\n  width,\n  quality,\n}: {\n  src: string;\n  width: number;\n  quality?: number;\n}) {\n  // For external URLs (Pexels, Unsplash)\n  if (src.startsWith('http')) {\n    // Use Cloudflare Image Resizing\n    return `https://your-domain.com/cdn-cgi/image/width=${width},quality=${quality || 75}/${src}`;\n  }\n\n  // For local images\n  return `/_next/image?url=${encodeURIComponent(src)}&w=${width}&q=${quality || 75}`;\n}\n```\n\n### R2 Asset Storage\n\n```typescript\n// API route for uploading to R2\nexport const runtime = 'edge';\n\nexport async function POST(request: Request, { env }: { env: { ASSETS: R2Bucket } }) {\n  const formData = await request.formData();\n  const file = formData.get('file') as File;\n\n  if (!file) {\n    return Response.json({ error: 'No file provided' }, { status: 400 });\n  }\n\n  const key = `uploads/${Date.now()}-${file.name}`;\n  await env.ASSETS.put(key, await file.arrayBuffer(), {\n    httpMetadata: { contentType: file.type },\n  });\n\n  return Response.json({\n    url: `https://assets.your-domain.com/${key}`,\n  });\n}\n```\n\n## Monitoring & Debugging\n\n### Request Logging\n\n```typescript\n// Log to Workers Analytics Engine\nexport async function middleware(request: NextRequest) {\n  const start = Date.now();\n  const response = NextResponse.next();\n  const duration = Date.now() - start;\n\n  // Log to analytics (if using Workers Analytics Engine)\n  env.ANALYTICS?.writeDataPoint({\n    blobs: [request.nextUrl.pathname],\n    doubles: [duration, response.status],\n    indexes: [request.method],\n  });\n\n  return response;\n}\n```\n\n### Error Tracking\n\n```typescript\n// lib/error-tracking.ts\nexport async function logError(error: Error, context: Record<string, unknown>) {\n  console.error('Application Error:', {\n    message: error.message,\n    stack: error.stack,\n    ...context,\n    timestamp: new Date().toISOString(),\n    environment: process.env.CF_PAGES_BRANCH,\n  });\n\n  // If using external service\n  if (process.env.SENTRY_DSN) {\n    // Send to Sentry\n  }\n}\n```\n\n## CLI Reference\n\n```bash\n# Deploy preview\nnpx wrangler pages deploy .next --project-name=gallery\n\n# Deploy production\nnpx wrangler pages deploy .next --project-name=gallery --branch=main\n\n# View logs\nnpx wrangler pages deployment tail\n\n# Set secrets\nnpx wrangler pages secret put PEXELS_API_KEY\n\n# List deployments\nnpx wrangler pages deployments list\n\n# Rollback\nnpx wrangler pages deployments rollback\n```\n"
        },
        {
          "name": "internal-tools.md",
          "type": "file",
          "path": "frontend-architect/references/internal-tools.md",
          "size": 12133,
          "content": "# Internal Tools Architecture\n\nPatterns for building private prototypes, admin dashboards, and internal-only features.\n\n## Architecture Overview\n\n```\ninternal.yourapp.com/\n├── Cloudflare Access          # SSO authentication layer\n│   └── Policy: Allow @company.com emails\n│\n├── app/\n│   ├── (public)/              # No auth required\n│   │   └── page.tsx           # Public landing (optional)\n│   │\n│   ├── (internal)/            # Auth required via middleware\n│   │   ├── layout.tsx         # Internal layout with nav\n│   │   ├── page.tsx           # Internal dashboard\n│   │   ├── admin/             # Admin-only section\n│   │   ├── beta/              # Beta feature previews\n│   │   └── debug/             # Developer tools\n│   │\n│   └── api/\n│       └── internal/          # Internal-only APIs\n│           └── route.ts\n│\n└── middleware.ts              # Auth + feature flag routing\n```\n\n## Authentication Layer\n\n### Cloudflare Access Setup\n\n```yaml\n# Configure in Cloudflare Dashboard > Access > Applications\n\nApplication Name: Internal Tools\nDomain: internal.yourapp.com\n\nAccess Policy:\n  Name: Allow Company Employees\n  Action: Allow\n  Include:\n    - Emails ending in: @company.com\n\n  Name: Allow Specific Contractors\n  Action: Allow\n  Include:\n    - Email: contractor@external.com\n\nSession Duration: 24 hours\n```\n\n### Middleware Integration\n\n```typescript\n// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\ninterface CloudflareAccessUser {\n  email: string;\n  name?: string;\n  groups?: string[];\n}\n\nasync function getAccessUser(request: NextRequest): Promise<CloudflareAccessUser | null> {\n  const jwt = request.headers.get('CF-Access-JWT-Assertion');\n  if (!jwt) return null;\n\n  try {\n    const response = await fetch(\n      `https://${process.env.CF_ACCESS_TEAM}.cloudflareaccess.com/cdn-cgi/access/get-identity`,\n      { headers: { 'CF-Access-JWT-Assertion': jwt } }\n    );\n    if (!response.ok) return null;\n    return await response.json();\n  } catch {\n    return null;\n  }\n}\n\nexport async function middleware(request: NextRequest) {\n  const pathname = request.nextUrl.pathname;\n\n  // Skip auth for public routes\n  if (pathname.startsWith('/(public)') || pathname === '/') {\n    return NextResponse.next();\n  }\n\n  // Get authenticated user\n  const user = await getAccessUser(request);\n  if (!user) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n\n  // Role-based access\n  const routePermissions: Record<string, string[]> = {\n    '/admin': ['admin'],\n    '/beta': ['beta-tester', 'admin'],\n    '/debug': ['developer', 'admin'],\n  };\n\n  for (const [route, requiredRoles] of Object.entries(routePermissions)) {\n    if (pathname.startsWith(route)) {\n      const hasPermission = requiredRoles.some(role =>\n        user.groups?.includes(role)\n      );\n      if (!hasPermission) {\n        return new Response('Forbidden', { status: 403 });\n      }\n    }\n  }\n\n  // Add user to request headers for downstream use\n  const response = NextResponse.next();\n  response.headers.set('X-User-Email', user.email);\n  response.headers.set('X-User-Groups', user.groups?.join(',') || '');\n\n  return response;\n}\n\nexport const config = {\n  matcher: ['/((?!_next|static|favicon.ico).*)'],\n};\n```\n\n## Feature Flags\n\n### Per-User Feature Flags\n\n```typescript\n// lib/feature-flags.ts\nimport { kv } from '@cloudflare/workers-kv';\n\nexport interface FeatureFlags {\n  newDashboard: boolean;\n  experimentalSearch: boolean;\n  betaEditor: boolean;\n}\n\nconst defaultFlags: FeatureFlags = {\n  newDashboard: false,\n  experimentalSearch: false,\n  betaEditor: false,\n};\n\nexport async function getFeatureFlags(\n  email: string,\n  env: { KV: KVNamespace }\n): Promise<FeatureFlags> {\n  // Check user-specific flags\n  const userFlags = await env.KV.get(`flags:${email}`, 'json');\n  if (userFlags) {\n    return { ...defaultFlags, ...userFlags };\n  }\n\n  // Check global flags\n  const globalFlags = await env.KV.get('flags:global', 'json');\n  if (globalFlags) {\n    return { ...defaultFlags, ...globalFlags };\n  }\n\n  return defaultFlags;\n}\n\nexport async function setFeatureFlag(\n  email: string,\n  flag: keyof FeatureFlags,\n  value: boolean,\n  env: { KV: KVNamespace }\n): Promise<void> {\n  const existing = await env.KV.get(`flags:${email}`, 'json') || {};\n  await env.KV.put(`flags:${email}`, JSON.stringify({\n    ...existing,\n    [flag]: value,\n  }));\n}\n```\n\n### Feature Flag Admin UI\n\n```typescript\n// app/(internal)/admin/flags/page.tsx\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Switch } from '@/components/ui/switch';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\n\nexport default function FeatureFlagsAdmin() {\n  const [email, setEmail] = useState('');\n  const [flags, setFlags] = useState<Record<string, boolean>>({});\n\n  async function loadFlags() {\n    const res = await fetch(`/api/internal/flags?email=${email}`);\n    const data = await res.json();\n    setFlags(data);\n  }\n\n  async function toggleFlag(flag: string, value: boolean) {\n    await fetch('/api/internal/flags', {\n      method: 'POST',\n      body: JSON.stringify({ email, flag, value }),\n    });\n    setFlags({ ...flags, [flag]: value });\n  }\n\n  return (\n    <div className=\"container py-8\">\n      <Card>\n        <CardHeader>\n          <CardTitle>Feature Flags</CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className=\"flex gap-4\">\n            <Input\n              placeholder=\"user@company.com\"\n              value={email}\n              onChange={(e) => setEmail(e.target.value)}\n            />\n            <Button onClick={loadFlags}>Load Flags</Button>\n          </div>\n\n          {Object.entries(flags).map(([flag, enabled]) => (\n            <div key={flag} className=\"flex items-center justify-between\">\n              <span className=\"font-mono\">{flag}</span>\n              <Switch\n                checked={enabled}\n                onCheckedChange={(value) => toggleFlag(flag, value)}\n              />\n            </div>\n          ))}\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n```\n\n## Beta Feature Previews\n\n### Version Comparison Component\n\n```typescript\n// app/(internal)/beta/page.tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\nexport default function BetaPreview() {\n  return (\n    <div className=\"container py-8\">\n      <h1 className=\"text-2xl font-bold mb-6\">Beta Feature Previews</h1>\n\n      <Tabs defaultValue=\"comparison\">\n        <TabsList>\n          <TabsTrigger value=\"comparison\">Side by Side</TabsTrigger>\n          <TabsTrigger value=\"current\">Current Version</TabsTrigger>\n          <TabsTrigger value=\"beta\">Beta Version</TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"comparison\">\n          <div className=\"grid grid-cols-2 gap-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Current</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <iframe\n                  src=\"/embed/dashboard?version=current\"\n                  className=\"w-full h-[600px] border rounded\"\n                />\n              </CardContent>\n            </Card>\n            <Card>\n              <CardHeader>\n                <CardTitle>Beta</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <iframe\n                  src=\"/embed/dashboard?version=beta\"\n                  className=\"w-full h-[600px] border rounded\"\n                />\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n```\n\n## Debug Tools\n\n### Request Inspector\n\n```typescript\n// app/(internal)/debug/requests/page.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\n\ninterface RequestLog {\n  id: string;\n  timestamp: string;\n  method: string;\n  path: string;\n  status: number;\n  duration: number;\n}\n\nexport default function RequestInspector() {\n  const [logs, setLogs] = useState<RequestLog[]>([]);\n\n  useEffect(() => {\n    // Real implementation would use SSE or WebSocket\n    const eventSource = new EventSource('/api/internal/debug/requests');\n    eventSource.onmessage = (event) => {\n      const log = JSON.parse(event.data);\n      setLogs((prev) => [log, ...prev].slice(0, 100));\n    };\n    return () => eventSource.close();\n  }, []);\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>Live Request Log</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Table>\n          <TableHeader>\n            <TableRow>\n              <TableHead>Time</TableHead>\n              <TableHead>Method</TableHead>\n              <TableHead>Path</TableHead>\n              <TableHead>Status</TableHead>\n              <TableHead>Duration</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {logs.map((log) => (\n              <TableRow key={log.id}>\n                <TableCell className=\"font-mono text-xs\">\n                  {new Date(log.timestamp).toLocaleTimeString()}\n                </TableCell>\n                <TableCell>{log.method}</TableCell>\n                <TableCell className=\"font-mono text-sm\">{log.path}</TableCell>\n                <TableCell>\n                  <span className={log.status >= 400 ? 'text-red-500' : 'text-green-500'}>\n                    {log.status}\n                  </span>\n                </TableCell>\n                <TableCell>{log.duration}ms</TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n### Environment Info\n\n```typescript\n// app/(internal)/debug/env/page.tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport default function EnvironmentInfo() {\n  const env = {\n    branch: process.env.CF_PAGES_BRANCH,\n    commit: process.env.CF_PAGES_COMMIT_SHA?.slice(0, 7),\n    nodeVersion: process.version,\n    nextVersion: require('next/package.json').version,\n    buildTime: process.env.BUILD_TIME,\n  };\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>Environment</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <dl className=\"grid grid-cols-2 gap-2\">\n          {Object.entries(env).map(([key, value]) => (\n            <>\n              <dt className=\"font-medium\">{key}</dt>\n              <dd className=\"font-mono text-muted-foreground\">{value || 'N/A'}</dd>\n            </>\n          ))}\n        </dl>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n## Deployment Workflow\n\n### Separate Deployment for Internal Tools\n\n```yaml\n# .github/workflows/deploy-internal.yml\nname: Deploy Internal Tools\n\non:\n  push:\n    branches: [main, develop]\n    paths:\n      - 'apps/internal/**'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n      - name: Install & Build\n        run: |\n          npm ci\n          npm run build:internal\n\n      - name: Deploy to Cloudflare Pages\n        uses: cloudflare/pages-action@v1\n        with:\n          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}\n          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}\n          projectName: internal-tools\n          directory: apps/internal/.next\n          gitHubToken: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Preview Deployments for Internal Review\n\n```bash\n# Every branch gets a preview\n# https://preview-feature-xyz.internal-tools.pages.dev\n\n# Protected by Cloudflare Access - same auth as production\n# Great for reviewing internal tool changes before merge\n```\n"
        }
      ]
    },
    {
      "name": "CHANGELOG.md",
      "type": "file",
      "path": "frontend-architect/CHANGELOG.md",
      "size": 729,
      "content": "# Changelog\n\n## [1.0.0] - 2026-01-31\n\n### Added\n- Initial release of frontend-architect skill\n- Stack selection decision matrix for common project types\n- Cloudflare Pages deployment patterns with preview URLs\n- shadcn/ui component patterns and customization\n- Internal tools architecture with Cloudflare Access\n- Design system bridge connecting catalog to components\n\n### Reference Documents\n- `stack-decisions.md` - Framework and library selection criteria\n- `cloudflare-patterns.md` - Edge deployment, KV, middleware patterns\n- `shadcn-components.md` - Component library best practices\n- `internal-tools.md` - Private prototype and admin dashboard patterns\n- `design-system-bridge.md` - Token generation and component mapping\n"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "frontend-architect/SKILL.md",
      "size": 8493,
      "content": "---\nname: frontend-architect\ndescription: Frontend stack expert for Cloudflare deployment, shadcn/ui components, and internal tools architecture. Guides technology choices, deployment patterns, and design system integration.\ncategory: development\nversion: 1.0.0\ntags: [frontend, cloudflare, deployment, components, internal-tools, architecture, stack-selection]\npairs-with: [web-design-expert, design-critic, cloudflare-worker-dev, design-system-generator]\nallowed-tools: [Read, Write, Edit, Bash, Glob, Grep, WebFetch, WebSearch]\n---\n\n# Frontend Architect\n\nYou are a senior frontend architect specializing in modern React stacks, Cloudflare deployment, and internal tools development. You guide technology decisions, deployment strategies, and design system integration.\n\n## When to Invoke\n\n- **Stack selection**: \"What framework should I use for X?\"\n- **Cloudflare deployment**: \"How do I deploy to Pages/Workers?\"\n- **Component library decisions**: \"Should I use shadcn, Radix, or build custom?\"\n- **Internal tools**: \"I need a private admin dashboard\"\n- **Design system bridge**: \"How do I connect design tokens to components?\"\n\n## Core Competencies\n\n### 1. Stack Selection\n\nWhen recommending a stack, always consider:\n\n| Factor | Questions to Ask |\n|--------|-----------------|\n| **Team Size** | Solo dev → simpler stack; Team → tooling/types matter |\n| **Timeline** | MVP → batteries-included; Long-term → flexibility |\n| **Deployment** | Cloudflare → Next.js 14+, SvelteKit; Vercel → wider options |\n| **Performance** | SSG where possible; SSR for dynamic; SPA for apps |\n| **Existing Code** | Migration cost vs. rewrite; incremental adoption paths |\n\n#### Recommended Stacks by Use Case\n\n```typescript\nconst stackRecommendations = {\n  // Marketing sites\n  marketingSite: {\n    framework: \"Next.js 14+ (App Router)\",\n    styling: \"Tailwind CSS\",\n    components: \"shadcn/ui\",\n    deployment: \"Cloudflare Pages\",\n    rationale: \"SSG for speed, great DX, edge deployment\"\n  },\n\n  // Internal tools\n  internalTools: {\n    framework: \"Next.js 14+ (App Router)\",\n    styling: \"Tailwind CSS\",\n    components: \"shadcn/ui + react-hook-form + zod\",\n    auth: \"Cloudflare Access\",\n    deployment: \"Cloudflare Pages (with Access protection)\",\n    rationale: \"Fast iteration, zero-config auth, preview URLs\"\n  },\n\n  // Interactive gallery/portfolio\n  gallery: {\n    framework: \"Next.js 14+ (App Router)\",\n    styling: \"Tailwind CSS + Framer Motion\",\n    components: \"shadcn/ui + custom\",\n    images: \"next/image + Pexels/Unsplash API\",\n    deployment: \"Cloudflare Pages\",\n    rationale: \"Optimized images, smooth animations, edge CDN\"\n  },\n\n  // E-commerce\n  ecommerce: {\n    framework: \"Next.js 14+ (App Router)\",\n    styling: \"Tailwind CSS\",\n    components: \"shadcn/ui + Stripe Elements\",\n    payments: \"Stripe\",\n    deployment: \"Vercel (better Next.js support) or Cloudflare\",\n    rationale: \"SSR for SEO, edge caching, Stripe integration\"\n  }\n};\n```\n\n### 2. Cloudflare Pages Deployment\n\n#### Configuration\n\n```toml\n# wrangler.toml\nname = \"your-project\"\ncompatibility_date = \"2026-01-31\"\npages_build_output_dir = \".next\"  # or \"out\" for static\n\n[vars]\nAPI_KEY = \"env:API_KEY\"\n\n[[kv_namespaces]]\nbinding = \"CACHE\"\nid = \"your-namespace-id\"\n```\n\n#### Deployment Workflow\n\n| Environment | Trigger | URL Pattern |\n|-------------|---------|-------------|\n| **Preview** | PR opened/updated | `preview-{branch}.{project}.pages.dev` |\n| **Staging** | Push to `develop` | `staging.{project}.pages.dev` |\n| **Production** | Push to `main` | `your-domain.com` |\n\n#### Key Patterns\n\n1. **Preview Deployments for Stakeholder Review**\n   ```bash\n   # Every PR gets a unique URL\n   npx wrangler pages deploy out --project-name=your-project\n   # → https://preview-feature-123.your-project.pages.dev\n   ```\n\n2. **Feature Flags at the Edge**\n   ```typescript\n   // middleware.ts\n   export async function middleware(request: Request) {\n     const flags = await env.KV.get('feature-flags', 'json');\n     if (flags?.newCheckout && request.url.includes('/checkout')) {\n       return NextResponse.rewrite(new URL('/checkout-v2', request.url));\n     }\n   }\n   ```\n\n3. **Auth with Cloudflare Access**\n   ```yaml\n   # Access policy (configure in Cloudflare dashboard)\n   Application: internal-tools.example.com\n   Policy: Allow authenticated users from @company.com\n   ```\n\n### 3. shadcn/ui Component Patterns\n\n#### When to Use What\n\n| Component Need | Recommendation |\n|---------------|----------------|\n| Basic UI (Button, Input, Dialog) | shadcn/ui - copy-paste, customize |\n| Complex forms | shadcn/ui Form + react-hook-form + zod |\n| Data tables | shadcn/ui Table + TanStack Table |\n| Date picking | shadcn/ui Calendar + date-fns |\n| Charts | Recharts (shadcn has examples) |\n| Drag &amp; drop | dnd-kit (not bundled, but compatible) |\n\n#### Component Customization Pattern\n\n```typescript\n// components/ui/button.tsx - shadcn baseline\nimport { cn } from \"@/lib/utils\";\nimport { buttonVariants } from \"./button-variants\";\n\n// Extend with your design tokens\nexport const Button = ({ className, variant, size, ...props }) =&gt; (\n  &lt;button\n    className={cn(\n      buttonVariants({ variant, size }),\n      \"transition-all duration-200\",  // Add your defaults\n      className\n    )}\n    {...props}\n  /&gt;\n);\n```\n\n### 4. Internal Tools Architecture\n\nFor \"prototypes/side ideas exposed as internal tools only a few users can see\":\n\n```\ninternal.yourapp.com/\n├── Cloudflare Access (SSO protection)\n│   └── Policy: Allow @company.com\n├── Feature Flags (per-user visibility)\n│   └── KV: { \"admin-tools\": [\"user1\", \"user2\"] }\n├── Preview Environments\n│   └── preview-{branch}.internal.yourapp.com\n└── Routes\n    ├── /admin → Full admin dashboard\n    ├── /beta → Beta feature preview\n    └── /debug → Developer tools\n```\n\n#### Access Control Pattern\n\n```typescript\n// middleware.ts\nexport async function middleware(request: Request) {\n  // Cloudflare Access provides JWT in CF-Access-JWT-Assertion header\n  const jwt = request.headers.get('CF-Access-JWT-Assertion');\n  const user = await verifyAccessToken(jwt);\n\n  const flags = await env.KV.get(`user:${user.email}:flags`, 'json');\n\n  if (request.url.includes('/admin') &amp;&amp; !flags?.admin) {\n    return new Response('Forbidden', { status: 403 });\n  }\n\n  return NextResponse.next();\n}\n```\n\n### 5. Design System Bridge\n\nConnect design tokens to components:\n\n```typescript\n// lib/design-bridge.ts\nimport { buttonPatterns } from '@/data/catalog/button-patterns.json';\n\n// Map catalog patterns to shadcn variants\nexport const variantMap = {\n  'primary-button': 'default',\n  'secondary-button': 'outline',\n  'destructive-button': 'destructive',\n  'tertiary-button': 'ghost',\n  'neobrutalism-button': 'brutalist',  // custom variant\n} as const;\n\n// Generate Tailwind classes from catalog specs\nexport function patternToClasses(patternId: string): string {\n  const pattern = buttonPatterns.find(p =&gt; p.id === patternId);\n  if (!pattern) return '';\n\n  return cn(\n    pattern.cssProperties.map(prop =&gt; propertyToTailwind(prop)),\n    pattern.variants?.hover &amp;&amp; 'hover:' + pattern.variants.hover\n  );\n}\n```\n\n## Decision Framework\n\nWhen asked to make a technology decision:\n\n1. **Understand constraints**: Team size, timeline, existing stack, deployment target\n2. **Consider maintenance**: Who will maintain this? What's their skill level?\n3. **Evaluate trade-offs**: Speed vs. flexibility, DX vs. bundle size\n4. **Provide alternatives**: Main recommendation + 1-2 alternatives with trade-offs\n5. **Include migration path**: How to evolve if needs change\n\n## Output Format\n\nWhen making recommendations:\n\n```markdown\n## Recommendation: [Technology/Approach]\n\n### Rationale\n[2-3 sentences on why this is the right choice]\n\n### Implementation\n[Code snippets, configuration, or setup steps]\n\n### Trade-offs\n| Pro | Con |\n|-----|-----|\n| [Benefit] | [Drawback] |\n\n### Alternatives Considered\n1. **[Alternative A]**: [Why not chosen]\n2. **[Alternative B]**: [When it would be better]\n\n### Migration Path\n[How to evolve if requirements change]\n```\n\n## References\n\n- `references/stack-decisions.md` - Framework selection criteria\n- `references/cloudflare-patterns.md` - Edge deployment patterns\n- `references/shadcn-components.md` - Component library guidance\n- `references/internal-tools.md` - Private prototype patterns\n- `references/design-system-bridge.md` - Connecting design to code\n"
    }
  ]
}